<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultimate Flagle</title>
  <style>
    :root{
      --accent:#93c5fd;
      --ok:#34d399;
      --bad:#fb7185;
      --warn:#fbbf24;
      /* Connections grid gap and card radius for consistent spacing. Default values emulate the
         comfortable spacing of our inspiration design. Users can adjust these via the UI panel. */
      --conn-gap:8px;
      --card-radius:6px;
      /* Control the speed of solved connections animations (seconds) */
      --conn-anim-speed:0.4;
    }
    [data-theme="dark"]{--bg:#000000;--panel:#111111;--text:#e5e7eb;--muted:#9ca3af}
    [data-theme="light"]{--bg:#f3f4f6;--panel:#ffffff;--text:#111827;--muted:#6b7280}

    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    /* Structure the header as a vertical column: first row is the title/mode/buttons, second row is the category tabs */
    header{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{margin:0;font-size:20px}

    .seg{display:flex;gap:4px;background:rgba(255,255,255,.06);padding:4px;border-radius:10px}
    .seg button{border:0;background:transparent;color:#c9d1ff;padding:6px 10px;border-radius:8px;font-weight:700;cursor:pointer}
    .seg button.active{background:var(--accent);color:#111827}

    .panel{
      background:var(--panel);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:12px;
      margin-top:10px;
      /* Slightly deeper shadow for modern look */
      box-shadow:0 2px 8px rgba(0,0,0,0.1);
    }
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .pill{padding:6px 12px;border-radius:999px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12)}
    .btn{
      border:0;
      border-radius:10px;
      padding:8px 12px;
      font-weight:700;
      background:var(--accent);
      color:#0b1020;
      cursor:pointer;
      /* Smooth hover and active animations */
      transition:background 0.15s ease, box-shadow 0.15s ease, transform 0.05s ease;
    }
    /* Visually indicate when buttons are disabled */
    .btn:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }
    /* Provide hover and active states for buttons */
    .btn:not(:disabled):hover{
      box-shadow:0 2px 6px rgba(0,0,0,0.3);
      filter:brightness(1.1);
    }
    .btn:not(:disabled):active{
      transform:scale(0.97);
    }
    /* Size and spacing for SVG icons inside buttons */
    .btn svg{
      width:1em;
      height:1em;
      margin-right:4px;
      vertical-align:middle;
    }

    /* Active drawing tool styles */
    #drawTools .btn.active{
      background: var(--accent);
      color: var(--panel);
    }
    /* Active state for select-based tools (shapes) */
    select.btn.active{
      background: var(--accent);
      color: var(--panel);
    }

    /* Swatch showing the currently selected brush colour */
    .color-swatch {
      display:inline-block;
      width:20px;
      height:20px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,0.2);
      margin-left:4px;
    }

    /* Style for the mode select dropdown to improve visibility */
    #modeSelect.btn{
      /* Slightly lighter card background for contrast within dark theme */
      background: rgba(255,255,255,0.05);
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.2);
      padding-right: 1.5rem; /* leave space for default arrow */
    }
    /* Provide a consistent appearance for select elements in both themes */
    #modeSelect.btn option{
      color: var(--text);
      background: var(--bg);
    }

    /* Connections game layout */
    .connections-grid{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:var(--conn-gap);
    }
    .connections-grid .flag-card{
      position:relative;
      cursor:pointer;
      border:2px solid transparent;
      border-radius:var(--card-radius);
      overflow:hidden;
      aspect-ratio:3/2;
      background: var(--panel);
    }
    .connections-grid .flag-card img{
      width:100%;
      height:100%;
      display:block;
      /* Use contain so that flags with unusual shapes like Nepal are fully visible */
      object-fit:contain;
      object-position:center;
    }
    .connections-grid .flag-card.selected{
      /* Highlight selected cards with a visible accent outline and slight scale */
      border-color: var(--accent);
      transform: scale(1.03);
      /* Use an outer box shadow so the highlight is visible on dark backgrounds */
      box-shadow: 0 0 0 3px var(--accent), 0 2px 6px rgba(0,0,0,0.4);
    }
    .connections-grid .flag-card.fade-out{
      opacity:0;
      transition: opacity 0.3s ease;
    }
    #connectionsTop{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .connection-group{
      position:relative;
      display:flex;
      gap:4px;
      padding:2px;
      border-radius:4px;
      background: var(--panel);
    }
    .connection-group img{
      /* Keep solved flag images the same size as cards in the grid. The width calculation
         matches the width of a single grid cell (four cards across with gaps) and
         preserves the aspect ratio for unusual flags like Nepal. */
      width: calc((100% - 3*var(--conn-gap)) / 4);
      height: auto;
      aspect-ratio: 3/2;
      object-fit: contain;
      border-radius: var(--card-radius);
    }

    /* Animation for a solved card moving up and fading out */
    .connections-grid .flag-card.anim-solve{
      /* Use CSS variable for animation duration to allow user adjustments */
      transition: transform var(--conn-anim-speed) ease, opacity var(--conn-anim-speed) ease;
      transform: translateY(-60px);
      opacity:0;
    }

    /* Animation for the solved group sliding in from below */
    @keyframes slideIn {
      from { transform: translateY(20px); opacity:0; }
      to   { transform: translateY(0); opacity:1; }
    }
    .connection-group.new{
      /* Use CSS variable for the animation speed */
      animation: slideIn var(--conn-anim-speed) ease forwards;
    }
    .connection-group .theme-overlay{
      position:absolute;
      /* Center overlay horizontally and vertically */
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:#ffffff;
      color:#000000;
      font-size:14px;
      font-weight:bold;
      text-align:center;
      padding:4px 8px;
      border-radius:6px;
      box-shadow:0 1px 4px rgba(0,0,0,0.15);
      pointer-events:none;
    }
    .btn.ghost{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,.2)}
    /* Style select elements that use the .btn classes similarly to buttons */
    select.btn{appearance:none; border:1px solid rgba(255,255,255,.2); border-radius:10px; padding:8px 12px; font-weight:700; cursor:pointer; background:var(--panel); color:var(--text); min-width:90px;}
    select.btn.ghost{background:transparent;}
    .hidden{display:none!important}

    canvas{max-width:100%;height:auto;border-radius:10px;background:#0a0f1f}

    input[type=text], select, input[type=color]{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.15);color:var(--text);padding:10px 12px;border-radius:10px}

    .range{display:flex;gap:8px;align-items:center;width:100%}
    .range input[type=range]{flex:1;min-width:160px;appearance:none;background:transparent;height:24px}
    .range input[type=range]::-webkit-slider-runnable-track{height:4px;background:rgba(255,255,255,.25);border-radius:999px}
    .range input[type=range]::-webkit-slider-thumb{appearance:none;margin-top:-6px;width:16px;height:16px;border-radius:50%;background:var(--accent);border:2px solid #000}
    .range input[type=range]::-moz-range-track{height:4px;background:rgba(255,255,255,.25);border-radius:999px}
    .range input[type=range]::-moz-range-thumb{width:16px;height:16px;border:0;border-radius:50%;background:var(--accent)}

    .list{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:10px;margin-top:8px}
    .item{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:8px;display:grid;gap:6px;place-items:center}
    .item img{width:100%;aspect-ratio:4/3;object-fit:cover;border-radius:8px}
    .item small{opacity:.9;text-align:center}

    .topright{display:flex;gap:8px;align-items:center}

    /* Header bar for title, current mode, and right-side buttons */
    .header-bar {
      /* Use a three‚Äëcolumn grid to center the mode display between the title and control buttons. */
      display:grid;
      grid-template-columns:auto 1fr auto;
      align-items:center;
      gap:8px;
    }
    /* Display of current game mode (centered text with icon) */
    #modeDisplay {
      /* Center the mode name within its grid column */
      justify-self:center;
      display:flex;
      align-items:center;
      font-weight:700;
      font-size:16px;
      white-space:nowrap;
      color:var(--text);
    }

    /* Mistake indicator dots */
    .mistake-dot {
      display:inline-block;
      width:12px;
      height:12px;
      border-radius:50%;
      background:var(--accent);
      margin-left:4px;
      margin-right:4px;
    }
    .mistake-dot.used {
      opacity:0.25;
    }

    /* Header inside pop-up panels used as drag handle */
    .panel-header{
      user-select:none;
      cursor:move;
    }

    .pop{
      position:fixed;
      /* Centered by default; draggable panels will override left/top */
      top:80px;
      left:50%;
      transform:translateX(-50%);
      z-index:60;
      width:clamp(280px,92vw,760px);
      max-height:min(78vh,640px);
      overflow:auto;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:12px;
    }
    .muted{color:var(--muted);font-size:12px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <!-- Header bar: title on left, current game mode in the middle, UI/Settings on the right -->
      <div class="header-bar" style="justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
        <h1>Ultimate Flagle</h1>
        <!-- Display the current game mode with its icon. Default to Classic Mode to ensure visibility before script runs -->
        <span id="modeDisplay" class="header-mode">üéÆ Classic Mode</span>
        <div class="topright">
          <button class="btn ghost" id="uiBtn">üé® UI</button>
          <button class="btn ghost" id="settingsBtn">‚öôÔ∏è Settings</button>
        </div>
      </div>
      <!-- Category selector remains below the header bar -->
      <div class="seg" id="flagCats">
        <button class="active" data-tab="UN">UN Members</button>
        <button data-tab="Territories">Territories</button>
        <button data-tab="ALL">ALL</button>
        <button data-tab="Custom">Custom</button>
      </div>
    </header>

    <section class="panel">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <span class="pill">Correct: <b id="ok">0</b></span>
          <span class="pill">Streak: <b id="streak">0</b></span>
          <!-- Mistakes pill: shown only in Flag Connections unlimited mistakes mode -->
          <span class="pill hidden" id="mistakesPill">Mistakes: <b id="mistakesCount">0</b></span>

          <!-- Header for draw mode showing which flag to draw -->
          <span id="drawHeader" class="hidden" style="margin-left:8px; font-weight:bold;"></span>
          <select id="customSelect" class="hidden"></select>
          <button class="btn ghost hidden" id="createCustomBtn">Create Custom</button>
        </div>
        <div class="row">
          <button class="btn" id="startBtn">Start</button>
          <!-- Game mode selector with clearer labels and icons for each mode -->
          <select id="modeSelect" class="btn">
            <option value="classic">üéÆ Classic Mode</option>
            <option value="memory">üß† Memory Quiz</option>
            <option value="draw">üñåÔ∏è Draw The Flag</option>
            <option value="endless">‚àû Endless Hardcore</option>
            <option value="connections">üîó Flag Connections</option>
          </select>
          <button class="btn ghost" id="revealBtn" disabled>Reveal</button>
          <button class="btn" id="nextBtn" disabled>Next</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <input id="answer" type="text" placeholder="Your guess‚Ä¶" list="allnames" disabled>
        <datalist id="allnames"></datalist>
        <button class="btn" id="submitBtn" disabled>Submit</button>
      </div>
      <!-- Draw mode controls: hidden by default -->
      <div class="row hidden" id="drawControls" style="margin-top:8px; gap:8px;">
        <label class="row" style="gap:4px; align-items:center;">
          Brush Color
          <input type="color" id="drawColor" value="#ff0000" list="flagColors">
          <!-- Show a swatch of the current brush colour for easy reference -->
          <span id="colorSwatch" class="color-swatch"></span>
        </label>
        <!-- Data list providing suggested colours from the current flag -->
        <datalist id="flagColors"></datalist>
        <label class="row" style="gap:4px; align-items:center;">
          Brush Size
          <input type="range" id="drawSize" min="1" max="30" value="5">
        </label>
        <!-- Primary drawing tools with icons -->
        <div class="row" id="drawTools" style="gap:4px; align-items:center;">
          <button class="btn ghost" id="toolPen" title="Freehand (Pen)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325"/></svg>Pen</button>
          <button class="btn ghost" id="toolEraser" title="Eraser"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293z"/></svg>Erase</button>
          <button class="btn ghost" id="toolFill" title="Fill (Bucket)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M6.192 2.78c-.458-.677-.927-1.248-1.35-1.643a3 3 0 0 0-.71-.515c-.217-.104-.56-.205-.882-.02-.367.213-.427.63-.43.896-.003.304.064.664.173 1.044.196.687.556 1.528 1.035 2.402L.752 8.22c-.277.277-.269.656-.218.918.055.283.187.593.36.903.348.627.92 1.361 1.626 2.068.707.707 1.441 1.278 2.068 1.626.31.173.62.305.903.36.262.05.64.059.918-.218l5.615-5.615c.118.257.092.512.05.939-.03.292-.068.665-.073 1.176v.123h.003a1 1 0 0 0 1.993 0H14v-.057a1 1 0 0 0-.004-.117c-.055-1.25-.7-2.738-1.86-3.494a4 4 0 0 0-.211-.434c-.349-.626-.92-1.36-1.627-2.067S8.857 3.052 8.23 2.704c-.31-.172-.62-.304-.903-.36-.262-.05-.64-.058-.918.219zM4.16 1.867c.381.356.844.922 1.311 1.632l-.704.705c-.382-.727-.66-1.402-.813-1.938a3.3 3.3 0 0 1-.131-.673q.137.09.337.274m.394 3.965c.54.852 1.107 1.567 1.607 2.033a.5.5 0 1 0 .682-.732c-.453-.422-1.017-1.136-1.564-2.027l1.088-1.088q.081.181.183.365c.349.627.92 1.361 1.627 2.068.706.707 1.44 1.278 2.068 1.626q.183.103.365.183l-4.861 4.862-.068-.01c-.137-.027-.342-.104-.608-.252-.524-.292-1.186-.8-1.846-1.46s-1.168-1.32-1.46-1.846c-.147-.265-.225-.47-.251-.607l-.01-.068zm2.87-1.935a2.4 2.4 0 0 1-.241-.561c.135.033.324.11.562.241.524.292 1.186.8 1.846 1.46.45.45.83.901 1.118 1.31a3.5 3.5 0 0 0-1.066.091 11 11 0 0 1-.76-.694c-.66-.66-1.167-1.322-1.458-1.847z"/></svg>Fill</button>
          <button class="btn ghost" id="toolPicker" title="Pick Colour"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708zM2 12.707l7-7L10.293 7l-7 7H2z"/></svg>Pick</button>
          <button class="btn ghost" id="toolUndo" title="Undo"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M14.5 1.5a.5.5 0 0 1 .5.5v4.8a2.5 2.5 0 0 1-2.5 2.5H2.707l3.347 3.346a.5.5 0 0 1-.708.708l-4.2-4.2a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 8.3H12.5A1.5 1.5 0 0 0 14 6.8V2a.5.5 0 0 1 .5-.5"/></svg>Undo</button>
          <button class="btn ghost" id="toolClear" title="Clear Canvas"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/><path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/></svg>Clear</button>
        </div>
        <select id="shapeSelect" class="btn ghost" title="Shape">
          <!-- Additional shapes have been added to allow more variety when drawing -->
          <option value="line">Line</option>
          <option value="rect">Rectangle</option>
          <option value="circle">Circle</option>
          <option value="ellipse">Ellipse</option>
          <option value="triangle">Triangle</option>
          <option value="pentagon">Pentagon</option>
          <option value="hexagon">Hexagon</option>
          <option value="star">Star</option>
          <option value="heart">Heart</option>
          <option value="diamond">Diamond</option>
        </select>
        <label class="row" style="gap:4px; align-items:center;"><input type="checkbox" id="shapeFill"> Fill shape</label>
        <!-- Removed grid overlay toggle as it proved distracting and unnecessary -->
      </div>
    </section>

    <section class="panel">
      <canvas id="flagCanvas" width="900" height="560"></canvas>
      <div id="result" style="margin-top:8px"></div>
    </section>

    <!-- Flag Connections game panel (hidden by default) -->
    <section class="panel hidden" id="connectionsPanel">
      <!-- Solved groups will appear here -->
      <div id="connectionsTop" class="row" style="flex-wrap:wrap; gap:8px; margin-bottom:8px;"></div>
      <!-- Grid of flags for connections -->
      <div id="connectionsGrid" class="connections-grid" style="margin-bottom:8px;"></div>
      <!-- Row showing remaining mistakes for connections mode; built dynamically -->
      <div class="row hidden" id="mistakesRow" style="gap:6px; align-items:center; margin-bottom:8px;"></div>
      <!-- Controls for shuffle, submit and status -->
      <div class="row" id="connectionsControls" style="gap:8px; align-items:center;">
        <button class="btn" id="connectionsShuffle">Shuffle</button>
        <!-- New button to clear the current selection in the connections grid -->
        <button class="btn ghost" id="connectionsDeselect" disabled>Deselect All</button>
        <button class="btn" id="connectionsSubmit" disabled>Submit</button>
        <span id="connectionsStatus" class="muted" style="margin-left:auto;"></span>
      </div>
    </section>

    <section class="panel" id="learnPanel">
      <details open>
        <summary><b>Browse / Learn</b> ‚Äî click to see what‚Äôs in the current pool</summary>
        <div class="list" id="learnList"></div>
      </details>
    </section>
  </div>

  <!-- UI panel -->
  <div class="panel pop hidden" id="uiPanel">
    <!-- Draggable header for the UI panel -->
    <div class="row panel-header" style="justify-content:space-between; cursor:move;">
      <b>UI Settings</b>
      <button class="btn ghost" id="closeUi" title="Close">‚úñ</button>
    </div>
    <div class="row" style="margin-top:8px; gap:12px; align-items:center; flex-wrap:wrap;">
      <label>Theme</label>
      <select id="themeSelect">
        <option value="dark">Dark (black)</option>
        <option value="light">Light (grey/white)</option>
      </select>
      <label>Accent</label>
      <input type="color" id="accentPicker" value="#93c5fd">
    </div>
    <!-- Additional UI options: grid gap and card corner radius for connections game -->
    <div class="range" style="margin-top:8px">
      <label>Grid Gap</label>
      <input id="gapRange" type="range" min="2" max="12" step="1" value="4"><span id="gapVal">4px</span>
    </div>
    <div class="range">
      <label>Card Radius</label>
      <input id="radiusRange" type="range" min="0" max="20" step="1" value="4"><span id="radiusVal">4px</span>
    </div>
    <!-- Animation speed for solved connections -->
    <div class="range">
      <label>Anim Speed</label>
      <input id="speedRange" type="range" min="0.1" max="2" step="0.1" value="0.4"><span id="speedVal">0.4s</span>
    </div>
  </div>

  <!-- Custom preset builder -->
  <div class="panel pop hidden" id="customPanel">
    <div class="row" style="justify-content:space-between"><b>Create Custom Preset</b><button class="btn ghost" id="closeCustom">Close</button></div>
    <div class="row" style="margin-top:8px;gap:12px">
      <input id="customSearch" type="text" placeholder="Search countries/territories‚Ä¶" style="flex:1;min-width:200px">
      <span class="pill">Selected: <b id="customCount">0</b></span>
    </div>
    <div class="list" id="customList" style="margin-top:10px"></div>
    <div class="row" style="margin-top:12px;justify-content:space-between">
      <input id="customName" type="text" placeholder="Preset name (e.g., My Speedrun)">
      <button class="btn" id="saveCustomBtn">Save Preset</button>
    </div>
    <div class="muted" style="margin-top:6px">Tip: click tiles to select/deselect. Your presets are saved to this browser.</div>
  </div>

  <!-- Settings panel (effects + timer) -->
  <div class="panel pop hidden" id="settingsPanel">
    <!-- Draggable header for the settings panel -->
    <div class="row panel-header" style="justify-content:space-between; cursor:move;">
      <b>Flag Effects</b>
      <button class="btn ghost" id="closeSettings" title="Close">‚úñ</button>
    </div>

    <div class="range" style="margin-top:8px">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Blur">üíß</span>
        <input type="checkbox" id="blurToggle"> Blur
      </label>
      <input id="blurRange" type="range" min="0" max="20" step="0.5" value="0"><span id="blurVal">0px</span>
    </div>

    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Pixelate">üî≤</span>
        <input type="checkbox" id="pixelToggle"> Pixelate
      </label>
      <input id="pixelRange" type="range" min="1" max="60" step="1" value="1"><span id="pixelVal">1</span>
    </div>

    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Random Zoom-in">üîç</span>
        <input type="checkbox" id="zoomToggle"> Random Zoom-in
      </label>
      <input id="zoomRange" type="range" min="1" max="6" step="0.1" value="2"><span id="zoomVal">2.0√ó</span>
    </div>

    <div class="row" style="align-items:center; gap:4px;">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="6‚ÄëPiece Reveal">üß©</span>
        <input type="checkbox" id="sixToggle"> 6‚ÄëPiece Reveal (on wrong guesses)
      </label>
    </div>
    <div class="row" style="align-items:center; gap:4px;">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Random Colours">üé®</span>
        <input type="checkbox" id="randColorToggle"> Random Colours (per flag)
      </label>
    </div>

    <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,.15)">

    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Grayscale">‚ö´</span> Grayscale
      </label>
      <input id="gsRange" type="range" min="0" max="1" step="0.05" value="0"><span id="gsVal">0</span>
    </div>
    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Invert">üîÅ</span> Invert
      </label>
      <input id="invRange" type="range" min="0" max="1" step="0.05" value="0"><span id="invVal">0</span>
    </div>
    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Hue">üåà</span> Hue
      </label>
      <input id="hueRange" type="range" min="0" max="360" step="1" value="0"><span id="hueVal">0¬∞</span>
    </div>
    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Saturation">üîÜ</span> Saturation
      </label>
      <input id="satRange" type="range" min="0" max="3" step="0.05" value="1"><span id="satVal">1.00√ó</span>
    </div>
    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Contrast">üåì</span> Contrast
      </label>
      <input id="conRange" type="range" min="0" max="3" step="0.05" value="1"><span id="conVal">1.00√ó</span>
    </div>

    <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,.15)">

    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Timer">‚è≤Ô∏è</span> Timer (show flag): <span id="timerVal">‚àû</span>
      </label>
      <input id="timerRange" type="range" min="0.01" max="5" step="0.01" value="5">
      <label class="row" style="align-items:center; gap:4px;"><input type="checkbox" id="timerInfinite" checked> ‚àû</label>
    </div>

    <!-- Option to disable mistake limit specifically for Flag Connections -->
    <div class="row" style="align-items:center; gap:4px; margin-top:8px;">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Unlimited mistakes">‚ôæÔ∏è</span>
        <input type="checkbox" id="unlimitedMistakesToggle"> Unlimited mistakes (Flag Connections)
      </label>
    </div>

    <div class="muted" id="applyNote">Changes apply to the <b>next</b> flag.</div>
    <!-- Preview canvas showing USA flag with current effect settings -->
    <div id="previewContainer" style="text-align:center;margin-top:12px;">
      <canvas id="effectsPreview" width="200" height="120" style="border:1px solid rgba(255,255,255,0.2); border-radius:8px;"></canvas>
      <div class="muted" style="margin-top:4px;">Preview (USA)</div>
    </div>
  </div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const $$ = s => [...document.querySelectorAll(s)];
  const startBtn = $('#startBtn');
  // Game mode selector
  const modeSelect = $('#modeSelect');
  // Current mode display in header
  const modeDisplay = $('#modeDisplay');
  // Mapping of internal mode names to display names with icons
  const modeNames = {
    classic: 'üéÆ Classic Mode',
    memory: 'üß† Memory Quiz',
    draw: 'üñåÔ∏è Draw The Flag',
    endless: '‚àû Endless Hardcore',
    connections: 'üîó Flag Connections'
  };
  const revealBtn = $('#revealBtn');
  const nextBtn = $('#nextBtn');
  const submitBtn = $('#submitBtn');
  const answer = $('#answer');
  const resultEl = $('#result');
  const canvas = $('#flagCanvas');
  const ctx = canvas.getContext('2d');
  const okEl = $('#ok');
  const streakEl = $('#streak');
  const mistakesPill = $('#mistakesPill');
  const mistakesCount = $('#mistakesCount');
  const mistakesRow = $('#mistakesRow');
  const connectionsDeselect = $('#connectionsDeselect');
  const learnList = $('#learnList');
  // Panel showing the browse/learn list (hidden in endless mode)
  const learnPanel = $('#learnPanel');
  const customSelect = $('#customSelect');
  const createCustomBtn = $('#createCustomBtn');
  const customPanel = $('#customPanel');
  const closeCustom = $('#closeCustom');
  const customSearch = $('#customSearch');
  const customList = $('#customList');
  const customCount = $('#customCount');
  const customName = $('#customName');
  const saveCustomBtn = $('#saveCustomBtn');

  // Additional elements for draw-from-memory mode
  const answerRow = answer.closest('.row');
  const drawControls = $('#drawControls');
  const drawColor = $('#drawColor');
  const drawSize = $('#drawSize');
  const drawHeader = $('#drawHeader');
  // Display swatch showing current colour
  const colorSwatch = $('#colorSwatch');
  // Drawing tool buttons and controls
  const toolPen = $('#toolPen');
  const toolEraser = $('#toolEraser');
  const toolFill = $('#toolFill');
  const toolPicker = $('#toolPicker');
  const toolUndo = $('#toolUndo');
  const toolClear = $('#toolClear');
  // Shape selection and fill toggle
  const shapeSelect = $('#shapeSelect');
  const shapeFill = $('#shapeFill');
  // Grid toggle removed; no longer used
  const gridToggle = null;

  // Elements for Flag Connections mode
  const connectionsPanel = $('#connectionsPanel');
  const connectionsTop = $('#connectionsTop');
  const connectionsGrid = $('#connectionsGrid');
  const connectionsShuffle = $('#connectionsShuffle');
  const connectionsSubmit = $('#connectionsSubmit');
  const connectionsStatus = $('#connectionsStatus');

  // Current drawing tool ('pen','eraser','fill','picker','line','rect','circle','ellipse','triangle')
  let currentTool = 'pen';
  // Keep track of previously selected tool (used to revert after using the colour picker)
  let prevTool = 'pen';

  // List of all shape tools. When one of these is active, the shape dropdown
  // should be highlighted instead of the individual tool buttons.
  // Include all supported shape tools.  When any of these shapes is
  // selected the shape dropdown will be highlighted instead of the
  // freehand tool buttons.  The order here should match the
  // <option> entries in the shapeSelect dropdown.
  const shapeTools = ['line','rect','circle','ellipse','triangle','pentagon','hexagon','star','heart','diamond'];
  // History stack for undo functionality. Each entry stores ImageData.
  const history = [];
  // Image data snapshot for shape preview drawing
  let shapePreviewImgData = null;
  // Track shape drawing start coordinates
  let startX = 0;
  let startY = 0;
  let drawingShape = false;

  /**
   * Update the canvas background grid based on the grid toggle. Uses a
   * repeating linear gradient to draw gridlines every 20 pixels. If the grid
   * is disabled, clears any custom background image.
   */
  function updateGrid() {
    if (gridToggle && gridToggle.checked) {
      canvas.style.backgroundImage =
        'linear-gradient(to right, rgba(0,0,0,0.15) 1px, transparent 1px), ' +
        'linear-gradient(to bottom, rgba(0,0,0,0.15) 1px, transparent 1px)';
      canvas.style.backgroundSize = '20px 20px';
    } else {
      canvas.style.backgroundImage = '';
    }
  }

  /**
   * Save the current canvas state into the history stack for undo.
   */
  function saveState() {
    try {
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      history.push(imgData);
      // Limit history length to avoid memory bloat
      if (history.length > 50) history.shift();
    } catch(err) {
      console.warn('Could not save state for undo', err);
    }
  }

  /**
   * Undo the last drawing operation by restoring the previous canvas state.
   */
  function undo() {
    if (history.length === 0) return;
    const prev = history.pop();
    ctx.putImageData(prev, 0, 0);
  }

  /**
   * Clear the drawing canvas and reset it to a white background. Saves the state
   * to the history stack so the action can be undone.
   */
  function clearCanvas() {
    // Save current state before clearing
    saveState();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  /**
   * Convert a hex colour string (e.g. '#ff0000') to an array [r,g,b].
   * @param {string} hex
   * @returns {number[]} RGB array
   */
  function hexToRgb(hex) {
    hex = hex.replace('#', '');
    if (hex.length === 3) {
      hex = hex.split('').map(c => c + c).join('');
    }
    const intVal = parseInt(hex, 16);
    return [(intVal >> 16) & 255, (intVal >> 8) & 255, intVal & 255];
  }

  /**
   * Flood fill starting at (x, y) with the current brush colour.
   * This fills contiguous regions of the same starting colour.
   * @param {number} x
   * @param {number} y
   */
  function floodFill(x, y) {
    // Clamp coordinates
    x = Math.floor(x);
    y = Math.floor(y);
    // Acquire image data once
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const idx = (y * width + x) * 4;
    const targetR = data[idx];
    const targetG = data[idx + 1];
    const targetB = data[idx + 2];
    const targetA = data[idx + 3];
    // Determine replacement colour
    const [repR, repG, repB] = hexToRgb(drawColor.value);
    // If target and replacement colours are the same, nothing to fill
    if (targetR === repR && targetG === repG && targetB === repB && targetA === 255) {
      return;
    }
    const queue = [];
    queue.push([x, y]);
    // Track visited pixels to avoid infinite loops
    const visited = new Uint8Array(width * height);
    while (queue.length > 0) {
      const [cx, cy] = queue.pop();
      if (cx < 0 || cy < 0 || cx >= width || cy >= height) continue;
      const index = (cy * width + cx);
      if (visited[index]) continue;
      const di = index * 4;
      const cr = data[di];
      const cg = data[di + 1];
      const cb = data[di + 2];
      const ca = data[di + 3];
      if (cr === targetR && cg === targetG && cb === targetB && ca === targetA) {
        // Replace pixel colour
        data[di] = repR;
        data[di + 1] = repG;
        data[di + 2] = repB;
        data[di + 3] = 255;
        visited[index] = 1;
        // Enqueue neighbouring pixels
        queue.push([cx + 1, cy]);
        queue.push([cx - 1, cy]);
        queue.push([cx, cy + 1]);
        queue.push([cx, cy - 1]);
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }

  // UI panels
  const uiBtn=$('#uiBtn'), uiPanel=$('#uiPanel'), closeUi=$('#closeUi');
  const settingsBtn=$('#settingsBtn'), settingsPanel=$('#settingsPanel'), closeSettings=$('#closeSettings');
  const themeSelect=$('#themeSelect');
  const accentPicker=$('#accentPicker');

  // Effect controls
  const blurToggle=$('#blurToggle');
  const blurRange=$('#blurRange');
  const blurVal=$('#blurVal');
  const pixelToggle=$('#pixelToggle');
  const pixelRange=$('#pixelRange');
  const pixelVal=$('#pixelVal');
  const zoomToggle=$('#zoomToggle');
  const zoomRange=$('#zoomRange');
  const zoomVal=$('#zoomVal');
  const sixToggle=$('#sixToggle');
  const randColorToggle=$('#randColorToggle');
  const gsRange=$('#gsRange');
  const gsVal=$('#gsVal');
  const invRange=$('#invRange');
  const invVal=$('#invVal');
  const hueRange=$('#hueRange');
  const hueVal=$('#hueVal');
  const satRange=$('#satRange');
  const satVal=$('#satVal');
  const conRange=$('#conRange');
  const conVal=$('#conVal');

  // Timer controls
  const timerRange=$('#timerRange');
  const timerInfinite=$('#timerInfinite');
  const timerVal=$('#timerVal');

  // Unlimited mistakes toggle for flag connections
  const unlimitedMistakesToggle = $('#unlimitedMistakesToggle');

  // Range controls for adjusting the spacing and corner radius of the
  // connections grid. When these inputs change, update the corresponding
  // CSS variables and update their labels.
  const gapRange = $('#gapRange');
  const gapVal = $('#gapVal');
  const radiusRange = $('#radiusRange');
  const radiusVal = $('#radiusVal');
  const speedRange = $('#speedRange');
  const speedVal = $('#speedVal');
  if (gapRange && gapVal) {
    const updateGap = () => {
      const val = gapRange.value;
      document.documentElement.style.setProperty('--conn-gap', val + 'px');
      gapVal.textContent = val + 'px';
    };
    gapRange.addEventListener('input', updateGap);
    updateGap();
  }
  if (radiusRange && radiusVal) {
    const updateRadius = () => {
      const val = radiusRange.value;
      document.documentElement.style.setProperty('--card-radius', val + 'px');
      radiusVal.textContent = val + 'px';
    };
    radiusRange.addEventListener('input', updateRadius);
    updateRadius();
  }

  // Update animation speed for solved connections
  if (speedRange && speedVal) {
    const updateSpeed = () => {
      const val = parseFloat(speedRange.value);
      document.documentElement.style.setProperty('--conn-anim-speed', val + 's');
      speedVal.textContent = val.toFixed(1) + 's';
    };
    speedRange.addEventListener('input', updateSpeed);
    updateSpeed();
  }

  // Update state.unlimitedMistakes when the toggle changes. Also update the mistakes display if currently in connections mode.
  if (unlimitedMistakesToggle) {
    const updateUnlimited = () => {
      state.unlimitedMistakes = unlimitedMistakesToggle.checked;
      // If already in connections mode, update the mistakes remaining display accordingly
      updateMistakesDisplay();
    };
    unlimitedMistakesToggle.addEventListener('change', updateUnlimited);
    // Do not call updateUnlimited() here because `state` may not yet be defined.  We'll
    // initialize the unlimited mistakes state after `state` is declared later in the file.
    // updateUnlimited();
  }

  // --- Preview of flag effects ---
  const previewCanvas = $('#effectsPreview');
  const previewCtx = previewCanvas ? previewCanvas.getContext('2d') : null;
  // Load the USA flag for the preview. Cross-origin is allowed for this domain.
  let previewImg = null;
  if (previewCanvas) {
    previewImg = new Image();
    previewImg.crossOrigin = 'anonymous';
    previewImg.src = 'https://flagcdn.com/w320/us.png';
    previewImg.onload = () => {
      updatePreview();
    };
  }

  /**
   * Draw the USA flag into the preview canvas with the currently pending effects.
   * Pixelation is approximated by downscaling and upscaling. Other filter
   * effects are applied using the canvas context filter property.
   */
  function updatePreview() {
    if (!previewCanvas || !previewImg || !previewCtx) return;
    const w = previewCanvas.width;
    const h = previewCanvas.height;
    previewCtx.save();
    // Clear the canvas
    previewCtx.clearRect(0, 0, w, h);
    const p = state.effectsPending;
    // Build filter string
    const parts = [];
    if (p.gs > 0) parts.push(`grayscale(${p.gs})`);
    if (p.inv > 0) parts.push(`invert(${p.inv})`);
    const hueTotal = ((p.hue || 0)) % 360;
    if (hueTotal !== 0) parts.push(`hue-rotate(${hueTotal}deg)`);
    if (p.sat !== 1) parts.push(`saturate(${p.sat})`);
    if (p.con !== 1) parts.push(`contrast(${p.con})`);
    if (p.blurOn && p.blurPx > 0) parts.push(`blur(${p.blurPx}px)`);
    previewCtx.filter = parts.join(' ');
    if (p.pixelOn && p.pixel > 1) {
      const scale = 1 / p.pixel;
      const offW = Math.max(1, Math.round(w * scale));
      const offH = Math.max(1, Math.round(h * scale));
      const off = document.createElement('canvas');
      off.width = offW;
      off.height = offH;
      const offCtx = off.getContext('2d');
      offCtx.imageSmoothingEnabled = false;
      offCtx.drawImage(previewImg, 0, 0, offW, offH);
      previewCtx.imageSmoothingEnabled = false;
      previewCtx.drawImage(off, 0, 0, offW, offH, 0, 0, w, h);
    } else {
      previewCtx.imageSmoothingEnabled = true;
      previewCtx.drawImage(previewImg, 0, 0, w, h);
    }
    previewCtx.restore();
  }

  /**
   * Update the mistakes display for Flag Connections mode.
   * If unlimited mistakes are enabled, hide the mistakes row and show the mistakes pill next to the streak counter.
   * Otherwise, show up to four mistake dots indicating remaining mistakes. Used mistakes are faded.
   */
  function updateMistakesDisplay() {
    // Only meaningful in connections mode
    if (state.mode !== 'connections') {
      // Hide mistakes UI outside of connections mode
      if (mistakesRow) mistakesRow.classList.add('hidden');
      if (mistakesPill) mistakesPill.classList.add('hidden');
      return;
    }
    // Unlimited mistakes case
    if (state.unlimitedMistakes) {
      // Hide the row of circles and show the pill
      if (mistakesRow) mistakesRow.classList.add('hidden');
      if (mistakesPill) {
        mistakesPill.classList.remove('hidden');
        if (mistakesCount) mistakesCount.textContent = state.connectionsMistakesUsed;
      }
    } else {
      // Limited mistakes: show row with up to maxMistakes dots; hide pill
      if (mistakesPill) mistakesPill.classList.add('hidden');
      if (mistakesRow) {
        mistakesRow.classList.remove('hidden');
        const maxMistakes = state.maxMistakes || 4;
        const remaining = Math.max(0, maxMistakes - state.connectionsMistakesUsed);
        let html = '';
        html += '<span class="muted">Mistakes Remaining:</span>';
        for (let i = 0; i < maxMistakes; i++) {
          const used = i >= remaining;
          html += `<span class="mistake-dot${used ? ' used' : ''}"></span>`;
        }
        mistakesRow.innerHTML = html;
      }
    }
  }

  // ----------------- Data (UN + Territories) -----------------
  const COMMON = {"United Kingdom of Great Britain and Northern Ireland":"United Kingdom","United States of America":"United States","Korea (Republic of)":"South Korea","Korea (Democratic People's Republic of)":"North Korea","C√¥te d‚ÄôIvoire":"Cote d'Ivoire","Viet Nam":"Vietnam","Syrian Arab Republic":"Syria","Iran (Islamic Republic of)":"Iran","Russian Federation":"Russia","Lao People's Democratic Republic":"Laos","Venezuela (Bolivarian Republic of)":"Venezuela","Tanzania, United Republic of":"Tanzania","T√ºrkiye":"Turkey","Timor-Leste":"East Timor"};
  const NICK = {"United States":["USA","US","U.S.","U.S.A","America","United States of America"],"United Kingdom":["UK","Britain","Great Britain"],"Russia":["Russian Federation"],"South Korea":["Korea, South","Republic of Korea","ROK"],"North Korea":["Korea, North","Democratic People's Republic of Korea","DPRK"],"Cote d'Ivoire":["Ivory Coast"],"Czech Republic":["Czechia"],"Myanmar":["Burma"],"Turkey":["T√ºrkiye"],"East Timor":["Timor-Leste"],"Laos":["Lao PDR","Lao People's Democratic Republic"],"Syria":["Syrian Arab Republic"],"Vietnam":["Viet Nam"],"Taiwan":["Republic of China","ROC"],"Palestine":["State of Palestine","Palestine, State of"],"Moldova":["Republic of Moldova"],"Micronesia":["Micronesia (Federated States of)","FSM"],"North Macedonia":["Macedonia"],"DR Congo":["Democratic Republic of the Congo","Congo (DRC)","Congo-Kinshasa","Congo, Democratic Republic of the"],"Republic of the Congo":["Congo-Brazzaville","Congo"]};

  const UN_CSV = `AF|Afghanistan|Asia|Southern Asia|38928346\nAL|Albania|Europe|Southern Europe|2877797\nDZ|Algeria|Africa|Northern Africa|43851044\nAD|Andorra|Europe|Southern Europe|77265\nAO|Angola|Africa|Middle Africa|32866272\nAG|Antigua and Barbuda|Americas|Caribbean|97929\nAR|Argentina|Americas|South America|45195774\nAM|Armenia|Asia|Western Asia|2963243\nAU|Australia|Oceania|Australia and New Zealand|25499884\nAT|Austria|Europe|Western Europe|9006398\nAZ|Azerbaijan|Asia|Western Asia|10139177\nBS|Bahamas|Americas|Caribbean|393244\nBH|Bahrain|Asia|Western Asia|1701575\nBD|Bangladesh|Asia|Southern Asia|164689383\nBB|Barbados|Americas|Caribbean|287375\nBY|Belarus|Europe|Eastern Europe|9449323\nBE|Belgium|Europe|Western Europe|11589623\nBZ|Belize|Americas|Central America|397621\nBJ|Benin|Africa|Western Africa|12123200\nBT|Bhutan|Asia|Southern Asia|771608\nBO|Bolivia|Americas|South America|11673029\nBA|Bosnia and Herzegovina|Europe|Southern Europe|3280819\nBW|Botswana|Africa|Southern Africa|2351627\nBR|Brazil|Americas|South America|212559417\nBN|Brunei Darussalam|Asia|South-Eastern Asia|437483\nBG|Bulgaria|Europe|Eastern Europe|6948445\nBF|Burkina Faso|Africa|Western Africa|20903273\nBI|Burundi|Africa|Eastern Africa|11890784\nCV|Cabo Verde|Africa|Western Africa|555987\nKH|Cambodia|Asia|South-Eastern Asia|16718965\nCM|Cameroon|Africa|Middle Africa|26545863\nCA|Canada|Americas|North America|37742154\nCF|Central African Republic|Africa|Middle Africa|4829767\nTD|Chad|Africa|Middle Africa|16425864\nCL|Chile|Americas|South America|19116201\nCN|China|Asia|Eastern Asia|1439323776\nCO|Colombia|Americas|South America|50882891\nKM|Comoros|Africa|Eastern Africa|869601\nCD|Congo (Democratic Republic of the)|Africa|Middle Africa|89561403\nCG|Congo|Africa|Middle Africa|5518087\nCR|Costa Rica|Americas|Central America|5094118\nCI|C√¥te d‚ÄôIvoire|Africa|Western Africa|26378274\nHR|Croatia|Europe|Southern Europe|4105267\nCU|Cuba|Americas|Caribbean|11326616\nCY|Cyprus|Asia|Western Asia|1207359\nCZ|Czechia|Europe|Eastern Europe|10708981\nDK|Denmark|Europe|Northern Europe|5792202\nDJ|Djibouti|Africa|Eastern Africa|988000\nDM|Dominica|Americas|Caribbean|71986\nDO|Dominican Republic|Americas|Caribbean|10847910\nEC|Ecuador|Americas|South America|17643054\nEG|Egypt|Africa|Northern Africa|102334404\nSV|El Salvador|Americas|Central America|6486201\nGQ|Equatorial Guinea|Africa|Middle Africa|1402985\nER|Eritrea|Africa|Eastern Africa|3546421\nEE|Estonia|Europe|Northern Europe|1326535\nSZ|Eswatini|Africa|Southern Africa|1160164\nET|Ethiopia|Africa|Eastern Africa|114963588\nFJ|Fiji|Oceania|Melanesia|896445\nFI|Finland|Europe|Northern Europe|5540720\nFR|France|Europe|Western Europe|65273511\nGA|Gabon|Africa|Middle Africa|2225734\nGM|Gambia|Africa|Western Africa|2416668\nGE|Georgia|Asia|Western Asia|3989167\nDE|Germany|Europe|Western Europe|83783942\nGH|Ghana|Africa|Western Africa|31072940\nGR|Greece|Europe|Southern Europe|10423054\nGD|Grenada|Americas|Caribbean|112523\nGT|Guatemala|Americas|Central America|17915568\nGN|Guinea|Africa|Western Africa|13132792\nGW|Guinea-Bissau|Africa|Western Africa|1968001\nGY|Guyana|Americas|South America|786552\nHT|Haiti|Americas|Caribbean|11402528\nHN|Honduras|Americas|Central America|9904608\nHU|Hungary|Europe|Eastern Europe|9660351\nIS|Iceland|Europe|Northern Europe|341243\nIN|India|Asia|Southern Asia|1380004385\nID|Indonesia|Asia|South-Eastern Asia|273523615\nIR|Iran (Islamic Republic of)|Asia|Southern Asia|83992949\nIQ|Iraq|Asia|Western Asia|40222493\nIE|Ireland|Europe|Northern Europe|4937786\nIL|Israel|Asia|Western Asia|8655535\nIT|Italy|Europe|Southern Europe|60461826\nJM|Jamaica|Americas|Caribbean|2961167\nJP|Japan|Asia|Eastern Asia|126476461\nJO|Jordan|Asia|Western Asia|10203140\nKZ|Kazakhstan|Asia|Central Asia|18776707\nKE|Kenya|Africa|Eastern Africa|53771296\nKI|Kiribati|Oceania|Micronesia|119449\nKP|Korea (Democratic People's Republic of)|Asia|Eastern Asia|25778816\nKR|Korea (Republic of)|Asia|Eastern Asia|51269185\nKW|Kuwait|Asia|Western Asia|4270571\nKG|Kyrgyzstan|Asia|Central Asia|6524195\nLA|Lao People's Democratic Republic|Asia|South-Eastern Asia|7275560\nLV|Latvia|Europe|Northern Europe|1886198\nLB|Lebanon|Asia|Western Asia|6825445\nLS|Lesotho|Africa|Southern Africa|2142249\nLR|Liberia|Africa|Western Africa|5057681\nLY|Libya|Africa|Northern Africa|6871292\nLI|Liechtenstein|Europe|Western Europe|38128\nLT|Lithuania|Europe|Northern Europe|2722289\nLU|Luxembourg|Europe|Western Europe|625978\nMG|Madagascar|Africa|Eastern Africa|27691018\nMW|Malawi|Africa|Eastern Africa|19129952\nMY|Malaysia|Asia|South-Eastern Asia|32365999\nMV|Maldives|Asia|Southern Asia|540544\nML|Mali|Africa|Western Africa|20250833\nMT|Malta|Europe|Southern Europe|441543\nMH|Marshall Islands|Oceania|Micronesia|59190\nMR|Mauritania|Africa|Western Africa|4649658\nMU|Mauritius|Africa|Eastern Africa|1271768\nMX|Mexico|Americas|North America|128932753\nFM|Micronesia (Federated States of)|Oceania|Micronesia|115023\nMD|Moldova|Europe|Eastern Europe|4033963\nMC|Monaco|Europe|Western Europe|39242\nMN|Mongolia|Asia|Eastern Asia|3278290\nME|Montenegro|Europe|Southern Europe|628066\nMA|Morocco|Africa|Northern Africa|36910560\nMZ|Mozambique|Africa|Eastern Africa|31255435\nMM|Myanmar|Asia|South-Eastern Asia|54409800\nNA|Namibia|Africa|Southern Africa|2540905\nNR|Nauru|Oceania|Micronesia|10824\nNP|Nepal|Asia|Southern Asia|29136808\nNL|Netherlands|Europe|Western Europe|17134872\nNZ|New Zealand|Oceania|Australia and New Zealand|4822233\nNI|Nicaragua|Americas|Central America|6624554\nNE|Niger|Africa|Western Africa|24206644\nNG|Nigeria|Africa|Western Africa|206139589\nMK|North Macedonia|Europe|Southern Europe|2083374\nNO|Norway|Europe|Northern Europe|5421241\nOM|Oman|Asia|Western Asia|5106626\nPK|Pakistan|Asia|Southern Asia|220892340\nPW|Palau|Oceania|Micronesia|18094\nPA|Panama|Americas|Central America|4314767\nPG|Papua New Guinea|Oceania|Melanesia|8947027\nPY|Paraguay|Americas|South America|7132538\nPE|Peru|Americas|South America|32971854\nPH|Philippines|Asia|South-Eastern Asia|109581078\nPL|Poland|Europe|Eastern Europe|37846611\nPT|Portugal|Europe|Southern Europe|10196709\nQA|Qatar|Asia|Western Asia|2881053\nRO|Romania|Europe|Eastern Europe|19237691\nRU|Russian Federation|Europe|Eastern Europe|145934462\nRW|Rwanda|Africa|Eastern Africa|12952218\nKN|Saint Kitts and Nevis|Americas|Caribbean|53199\nLC|Saint Lucia|Americas|Caribbean|183627\nVC|Saint Vincent and the Grenadines|Americas|Caribbean|110940\nWS|Samoa|Oceania|Polynesia|198414\nSM|San Marino|Europe|Southern Europe|33931\nST|Sao Tome and Principe|Africa|Middle Africa|219159\nSA|Saudi Arabia|Asia|Western Asia|34813871\nSN|Senegal|Africa|Western Africa|16743927\nRS|Serbia|Europe|Southern Europe|8737370\nSC|Seychelles|Africa|Eastern Africa|98347\nSL|Sierra Leone|Africa|Western Africa|7976983\nSG|Singapore|Asia|South-Eastern Asia|5850342\nSK|Slovakia|Europe|Eastern Europe|5459642\nSI|Slovenia|Europe|Southern Europe|2078938\nSB|Solomon Islands|Oceania|Melanesia|686884\nSO|Somalia|Africa|Eastern Africa|15893222\nZA|South Africa|Africa|Southern Africa|59308690\nSS|South Sudan|Africa|Eastern Africa|11193725\nES|Spain|Europe|Southern Europe|46754778\nLK|Sri Lanka|Asia|Southern Asia|21413249\nSD|Sudan|Africa|Northern Africa|43849260\nSR|Suriname|Americas|South America|586632\nSE|Sweden|Europe|Northern Europe|10099265\nCH|Switzerland|Europe|Western Europe|8654622\nSY|Syrian Arab Republic|Asia|Western Asia|17500658\nTJ|Tajikistan|Asia|Central Asia|9537645\nTZ|Tanzania, United Republic of|Africa|Eastern Africa|59734218\nTH|Thailand|Asia|South-Eastern Asia|69799978\nTL|Timor-Leste|Asia|South-Eastern Asia|1318445\nTG|Togo|Africa|Western Africa|8278724\nTO|Tonga|Oceania|Polynesia|105695\nTT|Trinidad and Tobago|Americas|Caribbean|1399488\nTN|Tunisia|Africa|Northern Africa|11818619\nTR|T√ºrkiye|Asia|Western Asia|84339067\nTM|Turkmenistan|Asia|Central Asia|6031200\nTV|Tuvalu|Oceania|Polynesia|11792\nUG|Uganda|Africa|Eastern Africa|45741007\nUA|Ukraine|Europe|Eastern Europe|44134693\nAE|United Arab Emirates|Asia|Western Asia|9890402\nGB|United Kingdom of Great Britain and Northern Ireland|Europe|Northern Europe|67886011\nUS|United States of America|Americas|North America|331002651\nUY|Uruguay|Americas|South America|3473730\nUZ|Uzbekistan|Asia|Central Asia|33469203\nVU|Vanuatu|Oceania|Melanesia|307145\nVE|Venezuela (Bolivarian Republic of)|Americas|South America|28435940\nVN|Viet Nam|Asia|South-Eastern Asia|97338579\nYE|Yemen|Asia|Western Asia|29825964\nZM|Zambia|Africa|Eastern Africa|18383955\nZW|Zimbabwe|Africa|Eastern Africa|14862924`;

  const TERR_LIST = [['AI','Anguilla','Americas','Caribbean'],['AW','Aruba','Americas','Caribbean'],['BM','Bermuda','Americas','North America'],['BQ','Caribbean Netherlands','Americas','Caribbean'],['CW','Cura√ßao','Americas','Caribbean'],['FK','Falkland Islands (Malvinas)','Americas','South America'],['GF','French Guiana','Americas','South America'],['GL','Greenland','Americas','North America'],['GP','Guadeloupe','Americas','Caribbean'],['KY','Cayman Islands','Americas','Caribbean'],['MF','Saint Martin (French part)','Americas','Caribbean'],['MQ','Martinique','Americas','Caribbean'],['MS','Montserrat','Americas','Caribbean'],['PM','Saint Pierre and Miquelon','Americas','North America'],['PR','Puerto Rico','Americas','Caribbean'],['SX','Sint Maarten (Dutch part)','Americas','Caribbean'],['TC','Turks and Caicos Islands','Americas','Caribbean'],['VG','British Virgin Islands','Americas','Caribbean'],['VI','United States Virgin Islands','Americas','Caribbean'],['AX','√Öland Islands','Europe','Northern Europe'],['FO','Faroe Islands','Europe','Northern Europe'],['GG','Guernsey','Europe','Northern Europe'],['GI','Gibraltar','Europe','Southern Europe'],['IM','Isle of Man','Europe','Northern Europe'],['JE','Jersey','Europe','Northern Europe'],['SJ','Svalbard and Jan Mayen','Europe','Northern Europe'],['VA','Holy See','Europe','Southern Europe'],['EH','Western Sahara','Africa','Northern Africa'],['IO','British Indian Ocean Territory','Africa','Eastern Africa'],['RE','R√©union','Africa','Eastern Africa'],['SH','Saint Helena, Ascension and Tristan da Cunha','Africa','Western Africa'],['YT','Mayotte','Africa','Eastern Africa'],['CC','Cocos (Keeling) Islands','Asia','South-Eastern Asia'],['CX','Christmas Island','Asia','South-Eastern Asia'],['HK','Hong Kong','Asia','Eastern Asia'],['MO','Macao','Asia','Eastern Asia'],['PS','Palestine, State of','Asia','Western Asia'],['TW','Taiwan','Asia','Eastern Asia'],['AS','American Samoa','Oceania','Polynesia'],['CK','Cook Islands','Oceania','Polynesia'],['GU','Guam','Oceania','Micronesia'],['HM','Heard Island and McDonald Islands','Oceania','Subantarctic'],['NC','New Caledonia','Oceania','Melanesia'],['NF','Norfolk Island','Oceania','Australia and New Zealand'],['NU','Niue','Oceania','Polynesia'],['PN','Pitcairn','Oceania','Polynesia'],['TK','Tokelau','Oceania','Polynesia'],['UM','United States Minor Outlying Islands','Oceania','Micronesia'],['WF','Wallis and Futuna','Oceania','Polynesia'],['AQ','Antarctica','Antarctica','Antarctica'],['BV','Bouvet Island','Antarctica','Subantarctic'],['GS','South Georgia and the South Sandwich Islands','Antarctica','Subantarctic'],['TF','French Southern Territories','Antarctica','Subantarctic']];

  function norm(s){return (s||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}+/gu,'').replace(/[^a-z0-9 ]+/g,' ').replace(/\s+/g,' ').trim();}
  function acroVariants(name){const words=name.split(/\s+/).filter(w=>/^[a-z]/i.test(w));const acro=words.map(w=>w[0]).join('').toUpperCase();if(acro.length<2) return [];return [acro, acro.split('').join('. ')+'.', acro.split('').join('.')];}
  function addNicknames(obj){const common=COMMON[obj.name];if(common) obj.name=common; obj.alt=obj.alt||[]; const mapped=NICK[obj.name]; if(mapped) obj.alt.push(...mapped); acroVariants(obj.name).forEach(v=>obj.alt.push(v)); if(obj.name==='Netherlands') obj.alt.push('The Netherlands','Holland'); if(obj.name==='United Arab Emirates') obj.alt.push('UAE'); if(obj.name==='United Kingdom') obj.alt.push('UK','Britain','Great Britain'); obj.alt=[...new Set(obj.alt.filter(Boolean))]; return obj;}
  function parseUN(csv){
    return csv.trim().split(/\n+/).map(line=>{
      const [cca2,rawName,continent,subregion,pop] = line.split('|');
      const entry = {cca2,name:COMMON[rawName]||rawName,continent,subregion,pop:Number(pop)||0,flag:`https://flagcdn.com/w320/${cca2.toLowerCase()}.png`,alt:[]};
      return addNicknames(entry);
    });
  }
  function buildTerritories(){return TERR_LIST.map(([cca2,name,continent,subregion])=>addNicknames({cca2,name:COMMON[name]||name,continent,subregion,flag:`https://flagcdn.com/w320/${cca2.toLowerCase()}.png`,alt:[]}));}

  const dataUN = parseUN(UN_CSV);
  const dataTerr = buildTerritories();
  const seen = new Set();
  const dataAll = [...dataUN, ...dataTerr].filter(x=>{if(seen.has(x.cca2)) return false; seen.add(x.cca2); return true;}).sort((a,b)=>a.name.localeCompare(b.name));

  const state = { activeTab:'UN', quizPool:[], current:null, ok:0, streak:0, timerMs:Infinity, hideTimeout:null, memory:{sequence:[], index:0}, lastImage:null, piecesRevealed:1,
    // The current game mode (classic, memory, draw, endless, connections)
    mode:'classic',
    effectsCurrent:{ blurOn:false, blurPx:0, pixelOn:false, pixel:1, zoomOn:false, zoom:2, six:false, randColor:false, gs:0, inv:0, hue:0, sat:1, con:1 },
    effectsPending:{ blurOn:false, blurPx:0, pixelOn:false, pixel:1, zoomOn:false, zoom:2, six:false, randColor:false, gs:0, inv:0, hue:0, sat:1, con:1 },
    userPresets: [],
    // Maximum mistakes allowed in connections mode (when unlimited mistakes is disabled)
    maxMistakes: 4,
    // Number of mistakes made so far in the current connections round
    connectionsMistakesUsed: 0,
    // Whether unlimited mistakes are enabled in Flag Connections
    unlimitedMistakes: false
  };
  state.customMode='UN_EASY';

  // Immediately populate the mode display with the default mode name (before any games are started).
  // We do this here because `state` is now defined and DOM elements have been queried. This ensures
  // the header shows the currently selected mode upon page load.
  if (modeDisplay && modeNames[state.mode]) {
    modeDisplay.innerHTML = modeNames[state.mode];
  }

  // Initialize unlimited mistakes setting now that `state` is defined.  If the user
  // has toggled unlimited mistakes in the settings panel prior to loading a
  // connections game, this ensures `state.unlimitedMistakes` reflects the toggle
  // state.  updateUnlimited() is defined earlier in this script.
  try {
    if (typeof updateUnlimited === 'function') updateUnlimited();
  } catch(err) {
    // ignore if updateUnlimited is not defined or throws
  }

  // ---- User presets (localStorage) ----
  const PRESET_KEY = 'uf_user_presets_v1';
  function loadPresets(){
    try{ const raw=localStorage.getItem(PRESET_KEY); state.userPresets = raw? JSON.parse(raw): []; }
    catch{ state.userPresets = []; }
  }
  function savePresets(){ try{ localStorage.setItem(PRESET_KEY, JSON.stringify(state.userPresets)); }catch{} }
  loadPresets();

  function getCustomPool(){
    if(String(state.customMode||'').startsWith('USER:')){
      const p = state.userPresets.find(x=>x.id===state.customMode);
      if(p){ const chosen=new Set(p.items||[]); return dataAll.filter(x=>chosen.has(x.cca2)); }
    }
    switch(state.customMode){
      case 'UN_EASY':{ const sorted=[...dataUN].sort((a,b)=>b.pop-a.pop); const cut=Math.ceil(sorted.length*0.20); return sorted.slice(0,cut); }
      case 'UN_MED':{ const sorted=[...dataUN].sort((a,b)=>b.pop-a.pop); const s=Math.ceil(sorted.length*0.20); const e=Math.ceil(sorted.length*0.60); return sorted.slice(s,e); }
      case 'UN_HARD':{ const sorted=[...dataUN].sort((a,b)=>b.pop-a.pop); const e=Math.ceil(sorted.length*0.60); return sorted.slice(e); }
      case 'NA': return dataAll.filter(x=>x.continent==='Americas' && (x.subregion.includes('North')||x.subregion.includes('Central')));
      case 'SA': return dataAll.filter(x=>x.subregion==='South America');
      case 'EU': return dataAll.filter(x=>x.continent==='Europe');
      case 'AS': return dataAll.filter(x=>x.continent==='Asia');
      case 'AF': return dataAll.filter(x=>x.continent==='Africa');
      case 'OC': return dataAll.filter(x=>x.continent==='Oceania');
      case 'WORLD': return dataAll;
      default: return dataAll;
    }
  }
  function getSource(){ if(state.activeTab==='UN') return dataUN; if(state.activeTab==='Territories') return dataTerr; if(state.activeTab==='ALL') return dataAll; if(state.activeTab==='Custom') return getCustomPool(); return dataAll; }
  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

  function buildFilterString(){
    const e = state.effectsCurrent;
    const parts = [];
    if(e.gs>0) parts.push(`grayscale(${e.gs})`);
    if(e.inv>0) parts.push(`invert(${e.inv})`);
    const randHue = (state.current && e.randColor && typeof state.current._randHue==='number') ? state.current._randHue : 0;
    const hueTotal = ((e.hue||0) + randHue) % 360;
    if(hueTotal!==0) parts.push(`hue-rotate(${hueTotal}deg)`);
    if(e.sat!==1) parts.push(`saturate(${e.sat})`);
    if(e.con!==1) parts.push(`contrast(${e.con})`);
    if(e.blurOn && e.blurPx>0) parts.push(`blur(${e.blurPx}px)`);
    return parts.join(' ');
  }

  function drawPieces(img, sx, sy, sw, sh, dx, dy, dw, dh){
    const cols=3, rows=2; // 6 pieces
    const pieceW = Math.floor(dw/cols), pieceH = Math.floor(dh/rows);
    const srcPW = sw/cols, srcPH = sh/rows;
    let n=0;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        n++;
        const sxi = sx + c*srcPW;
        const syi = sy + r*srcPH;
        const dxi = dx + c*pieceW;
        const dyi = dy + r*pieceH;
        if(n<=state.piecesRevealed){
          ctx.drawImage(img, sxi, syi, srcPW, srcPH, dxi, dyi, pieceW, pieceH);
        } else {
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel')||'#111';
          ctx.fillRect(dxi, dyi, pieceW, pieceH);
        }
      }
    }
  }

  function renderCurrent(){
    if(!state.lastImage) return;
    const img = state.lastImage;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const s=Math.min(canvas.width/img.width, canvas.height/img.height);
    const w=Math.floor(img.width*s), h=Math.floor(img.height*s);
    const x=Math.floor((canvas.width-w)/2), y=Math.floor((canvas.height-h)/2);

    let sx=0, sy=0, sw=img.width, sh=img.height;
    const e=state.effectsCurrent;
    if(e.zoomOn && e.zoom>1 && state.current && state.current._crop){ ({sx,sy,sw,sh}=state.current._crop); }

    let off=null; let octx=null;
    const pxOn = e.pixelOn && e.pixel>1;
    if(pxOn){
      const scale = Math.max(1, e.pixel);
      const sw2 = Math.max(1, Math.floor(w/scale));
      const sh2 = Math.max(1, Math.floor(h/scale));
      off=document.createElement('canvas'); off.width=sw2; off.height=sh2; octx=off.getContext('2d');
      octx.imageSmoothingEnabled=true;
      octx.drawImage(img, sx, sy, sw, sh, 0,0, sw2, sh2);
      ctx.imageSmoothingEnabled=false;
    } else {
      ctx.imageSmoothingEnabled=true;
    }

    if(e.six){
      if(pxOn){ drawPieces(off, 0,0, off.width, off.height, x, y, w, h); }
      else { drawPieces(img, sx, sy, sw, sh, x, y, w, h); }
    } else {
      if(pxOn){ ctx.drawImage(off, x, y, w, h); }
      else { ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h); }
    }

    canvas.style.filter = buildFilterString();
  }

  function pickCrop(img, zoom){
    const cropW = Math.floor(img.width / zoom);
    const cropH = Math.floor(img.height / zoom);
    const sx = Math.floor(Math.random()*(img.width - cropW));
    const sy = Math.floor(Math.random()*(img.height - cropH));
    return {sx,sy,sw:cropW,sh:cropH};
  }

  function drawFlag(entry){
    const img=new Image(); img.crossOrigin='anonymous';
    img.onload=()=>{
      state.lastImage = img;
      state.piecesRevealed = state.effectsCurrent.six ? 1 : 6;
      if(state.effectsCurrent.zoomOn && state.effectsCurrent.zoom>1){ entry._crop = pickCrop(img, state.effectsCurrent.zoom); }
      else { entry._crop = {sx:0,sy:0,sw:img.width,sh:img.height}; }
      entry._randHue = state.effectsCurrent.randColor ? Math.floor(Math.random()*360) : 0;
      renderCurrent();
    };
    img.onerror=()=>{ resultEl.innerHTML='<span class="bad">Failed to load image.</span>'; };
    img.src=entry.flag;
  }

  function updateDatalist(){ const list=getSource(); const opts=[]; list.forEach(e=>{opts.push(`<option value="${e.name}">`); (e.alt||[]).forEach(a=>opts.push(`<option value="${a}">`));}); $('#allnames').innerHTML=opts.join(''); }
  function buildLearn(){ const src=getSource(); learnList.innerHTML = src.map(x=>`<div class="item"><img loading="lazy" src="${x.flag}" alt="${x.name}"><small>${x.name}</small></div>`).join(''); }

  function startGame(){
    // Start classic mode and reset counters
    state.mode = 'classic';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = 0;
    streakEl.textContent = 0;
    resultEl.textContent = '';
    state.quizPool = shuffle(getSource().slice());
    // Hide draw header when leaving draw mode
    drawHeader.classList.add('hidden');
    // Hide connections panel when entering classic mode
    connectionsPanel.classList.add('hidden');
    // Show result area and canvas for standard play
    resultEl.classList.remove('hidden');
    canvas.classList.remove('hidden');
    // Show the generic submit button used in most modes
    submitBtn.classList.remove('hidden');
    // Ensure the answer input is visible and drawing controls are hidden
    answer.classList.remove('hidden');
    drawControls.classList.add('hidden');
    // Enable inputs and show controls
    answer.disabled = false;
    submitBtn.disabled = false;
    revealBtn.disabled = false;
    nextBtn.disabled = false;
    // Ensure the reveal and next buttons and learn panel are visible when not in endless mode
    revealBtn.classList.remove('hidden');
    nextBtn.classList.remove('hidden');
    learnPanel.classList.remove('hidden');
    // Reset effects to user-selected pending settings
    state.effectsCurrent = JSON.parse(JSON.stringify(state.effectsPending));
    // Update the mode display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    nextFlag();
  }

  function nextFlag(){
    // Draw the next flag in the quiz. In endless hardcore mode, randomize effects per flag.
    if (state.quizPool.length === 0) {
      resultEl.innerHTML = '<span class="warn">No flags left.</span>';
      return;
    }
    state.current = state.quizPool.pop();
    if (state.mode === 'endless') {
      randomizeEffects();
    } else {
      // copy user-selected pending effects for standard and memory modes
      state.effectsCurrent = JSON.parse(JSON.stringify(state.effectsPending));
    }
    drawFlag(state.current);
    scheduleTimer();
  }

  // Randomize flag effects for endless hardcore mode
  function randomizeEffects(){
    // Select up to two distinct effect categories to randomize; others remain at defaults.
    const categories = ['blur','pixel','zoom','six','randColor','gs','inv','hue','sat','con'];
    // Randomly choose 1 or 2 categories
    const num = 1 + Math.floor(Math.random() * 2);
    const chosen = [];
    while(chosen.length < num){
      const idx = Math.floor(Math.random() * categories.length);
      const cat = categories[idx];
      if(!chosen.includes(cat)) chosen.push(cat);
    }
    // Defaults for all effects
    const p = {
      blurOn: false, blurPx: 0,
      pixelOn: false, pixel: 1,
      zoomOn: false, zoom: 1,
      six: false,
      randColor: false,
      gs: 0,
      inv: 0,
      hue: 0,
      sat: 1,
      con: 1
    };
    // Randomize selected categories
    chosen.forEach(cat => {
      switch(cat){
        case 'blur':
          p.blurOn = true;
          p.blurPx = Math.random() * 20;
          break;
        case 'pixel':
          p.pixelOn = true;
          p.pixel = Math.floor(1 + Math.random() * 60);
          break;
        case 'zoom':
          p.zoomOn = true;
          p.zoom = 1 + Math.random() * 5;
          break;
        case 'six':
          p.six = true;
          break;
        case 'randColor':
          p.randColor = true;
          break;
        case 'gs':
          p.gs = Math.random();
          break;
        case 'inv':
          p.inv = Math.random();
          break;
        case 'hue':
          p.hue = Math.random() * 360;
          break;
        case 'sat':
          p.sat = Math.random() * 3;
          break;
        case 'con':
          p.con = Math.random() * 3;
          break;
      }
    });
    state.effectsCurrent = p;
  }

  // Start Endless Hardcore mode: similar to standard mode but with random effects on each flag
  function startEndless(){
    state.mode = 'endless';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = 0;
    streakEl.textContent = 0;
    resultEl.textContent = '';
    // build quiz pool from current source
    state.quizPool = shuffle(getSource().slice());
    // Enable answer and buttons
    answer.disabled = false;
    submitBtn.disabled = false;
    // Hide the draw header in endless mode
    drawHeader.classList.add('hidden');
    // Hide connections panel when entering endless mode
    connectionsPanel.classList.add('hidden');
    // Ensure the canvas and result elements are visible
    canvas.classList.remove('hidden');
    resultEl.classList.remove('hidden');
    // Show the generic submit button for endless mode
    submitBtn.classList.remove('hidden');
    // Ensure the answer input is visible and drawing controls are hidden
    answer.classList.remove('hidden');
    drawControls.classList.add('hidden');
    // Hide controls that could be used to cheat in endless mode
    revealBtn.classList.add('hidden');
    nextBtn.classList.add('hidden');
    learnPanel.classList.add('hidden');
    // Ensure reveal and next are also disabled
    revealBtn.disabled = true;
    nextBtn.disabled = true;
    // Start by drawing the first flag via nextFlag (randomization happens there)
    // Update mode display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    nextFlag();
  }

  // Start Draw-from-Memory mode
  function startDraw(){
    state.mode = 'draw';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = 0;
    streakEl.textContent = 0;
    // Build quiz pool from current source
    state.quizPool = shuffle(getSource().slice());
    // Clear the result area; the country name and instructions will be set when the first flag is chosen
    resultEl.innerHTML = '';
    // Hide the answer input field but keep the submit button visible, and show drawing controls
    answer.classList.add('hidden');
    drawControls.classList.remove('hidden');
    // Hide connections panel when entering draw mode
    connectionsPanel.classList.add('hidden');
    // Ensure canvas and result area are visible
    canvas.classList.remove('hidden');
    resultEl.classList.remove('hidden');
    // Show the generic submit button for draw mode
    submitBtn.classList.remove('hidden');
    // Hide reveal and next buttons initially in draw mode
    revealBtn.classList.add('hidden');
    revealBtn.disabled = true;
    nextBtn.classList.add('hidden');
    nextBtn.disabled = true;
    // Enable the submit button for drawing evaluation
    submitBtn.disabled = false;
    // Hide learn panel in draw mode
    learnPanel.classList.add('hidden');
    // Clear canvas and fill white background for drawing
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // Grid overlay removed; nothing to update here
    // Show the draw header
    drawHeader.classList.remove('hidden');
    // Update mode display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    // Start with a new flag to draw
    nextDraw();

    // Update colour swatch in case the palette takes time to load
    updateSwatch();
  }

  // Advance to the next flag in draw-from-memory mode
  function nextDraw(){
    if(!state.quizPool || state.quizPool.length === 0){
      state.quizPool = shuffle(getSource().slice());
    }
    state.current = state.quizPool.pop();
    // Reset result message and prepare for a new drawing
    // Show the country name at the top and instructions below
    // Display the country name next to the streak in bold.  Use
    // capitalised "Flag" for a polished look.
    drawHeader.innerHTML = `<b>Draw: ${state.current.name}'s Flag</b>`;
    resultEl.innerHTML = `<span class="muted">Draw the flag from memory, then click <b>Submit</b> to see how close you are.</span>`;
    // Populate the colour picker suggestions with colours from this flag
    generatePaletteForFlag(state.current.flag);
    // Clear the drawing canvas
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // Grid overlay removed; nothing to update here
    // Hide reveal and next buttons until the user submits their drawing
    revealBtn.classList.add('hidden');
    revealBtn.disabled = true;
    nextBtn.classList.add('hidden');
    nextBtn.disabled = true;
    // Ensure the submit button is enabled for the new drawing
    submitBtn.disabled = false;
  }

  function scheduleTimer(){ if(state.hideTimeout){clearTimeout(state.hideTimeout); state.hideTimeout=null;} if(state.timerMs!==Infinity){ state.hideTimeout=setTimeout(()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); resultEl.innerHTML='<span class="warn">‚è±Ô∏è Time\'s up!</span>'; }, state.timerMs); } }
  function allNames(e){ return [e.name, ...(e.alt||[])]; }

  function matches(input, entry){
    const g = norm(input);
    const currentNames = allNames(entry).map(norm);
    if (currentNames.includes(g)) return true;
    if (g.length >= 3 && currentNames.some(n => n.startsWith(g))) {
      const src = getSource();
      for (const e of src) {
        if (e === entry) continue;
        const names = allNames(e).map(norm);
        if (names.some(n => n.startsWith(g))) return false;
      }
      return true;
    }
    return false;
  }

  // Convert an RGB pixel to a coarse colour category (white, black, red, yellow, green, blue).
  // Uses HSV thresholds to classify colours. White and black are matched by brightness
  // and saturation; hue ranges segment the remaining colours. Colours that fall
  // outside these ranges default to 'red' (covering magenta and purple hues).
  function classifyColor(r, g, b) {
    const rf = r / 255, gf = g / 255, bf = b / 255;
    const max = Math.max(rf, gf, bf);
    const min = Math.min(rf, gf, bf);
    const v = max;
    const d = max - min;
    let s = 0;
    if (max !== 0) s = d / max;
    // compute hue
    let h = 0;
    if (d !== 0) {
      if (max === rf) {
        h = ((gf - bf) / d) * 60;
      } else if (max === gf) {
        h = ((bf - rf) / d) * 60 + 120;
      } else {
        h = ((rf - gf) / d) * 60 + 240;
      }
      if (h < 0) h += 360;
    }
    // classification by brightness and saturation
    if (v < 0.1) return 'black';
    if (v > 0.9 && s < 0.1) return 'white';
    // hue based categories
    if (h < 20 || h >= 340) return 'red';
    if (h < 65) return 'yellow';
    if (h < 170) return 'green';
    if (h < 275) return 'blue';
    return 'red';
  }

  // ----------------- Flag Connections Theme Generation -----------------
  // Data structure to hold themes for the flag connections mode.
  // Each theme has a name and an array of entries (flags) belonging to that theme.
  let connectionsThemes = [];
  // Flags to ensure themes are built only once
  let connectionsBuiltSimple = false;
  let connectionsBuiltColors = false;

  /**
   * Build a variety of simple categories for the Connections game.  Themes
   * include continents, subregions, name patterns (starting/ending with
   * specific letters, containing letters) and name length.  Only
   * categories containing at least 4 flags are kept.  This function
   * populates the global `connectionsThemes` array and will not run more
   * than once.
   */
  function buildSimpleConnectionsThemes() {
    if (connectionsBuiltSimple) return;
    connectionsBuiltSimple = true;
    connectionsThemes = [];
    // Restrict the pool to UN member countries only for connections themes
    const pool = dataUN;
    // Build continent themes
    const continents = {};
    for (const e of pool) {
      if (!continents[e.continent]) continents[e.continent] = [];
      continents[e.continent].push(e);
    }
    for (const cont in continents) {
      const list = continents[cont];
      if (list.length >= 4) connectionsThemes.push({ name: `Flags from ${cont}`, flags: list, type: 'continent' });
    }
    // Build subregion themes (e.g., Western Europe, Southern Asia)
    const subregions = {};
    for (const e of pool) {
      const sub = e.subregion || '';
      if (!subregions[sub]) subregions[sub] = [];
      subregions[sub].push(e);
    }
    for (const sub in subregions) {
      const list = subregions[sub];
      if (sub && list.length >= 4) connectionsThemes.push({ name: `${sub}`, flags: list, type: 'subregion' });
    }
    // Create categories for names starting with each letter
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (const ch of alphabet) {
      const arr = pool.filter(e => e.name.toUpperCase().startsWith(ch));
      if (arr.length >= 4) connectionsThemes.push({ name: `Countries starting with ${ch}`, flags: arr, type: 'first_letter' });
    }
    // Do NOT create categories for names containing each letter, as this category is too vague
    // Create categories for names ending with each letter
    for (const ch of alphabet) {
      const arr = pool.filter(e => e.name.toUpperCase().endsWith(ch));
      if (arr.length >= 4) connectionsThemes.push({ name: `Countries ending with ${ch}`, flags: arr, type: 'last_letter' });
    }
    // Create categories based on the length of the country name (letters only)
    for (let len = 4; len <= 12; len++) {
      const arr = pool.filter(e => e.name.replace(/\s+/g, '').length === len);
      if (arr.length >= 4) connectionsThemes.push({ name: `${len}-letter names`, flags: arr, type: 'length' });
    }
    // Additional pattern-based categories for more variety.  Each pattern is an object with
    // a substring and a display name.  Categories are built from countries whose names
    // include or end with the substring, depending on the pattern type.  Only kept if
    // at least 4 matching countries are found.
    const patterns = [
      { substr: 'ISLAND', name: 'Countries containing Island', type: 'keyword' },
      { substr: 'ISLANDS', name: 'Countries containing Islands', type: 'keyword' },
      { substr: 'LAND', name: 'Countries containing Land', type: 'keyword' },
      { substr: 'STAN', name: 'Countries ending with -stan', type: 'keyword' },
      { substr: 'UNI', name: 'Countries containing United', type: 'keyword' },
      { substr: 'REPUB', name: 'Countries containing Republic', type: 'keyword' },
      { substr: 'SAINT', name: 'Countries containing Saint', type: 'keyword' },
      { substr: 'GUINEA', name: 'Countries containing Guinea', type: 'keyword' },
      { substr: 'NEW ', name: 'Countries starting with New', type: 'keyword' },
      { substr: 'KOREA', name: 'Countries containing Korea', type: 'keyword' },
      { substr: 'EMIRATES', name: 'Countries containing Emirates', type: 'keyword' },
      { substr: 'ARAB', name: 'Countries containing Arab', type: 'keyword' },
      { substr: 'SOUTH ', name: 'Countries starting with South', type: 'keyword' },
      { substr: 'NORTH ', name: 'Countries starting with North', type: 'keyword' },
      { substr: 'EAST ', name: 'Countries starting with East', type: 'keyword' },
      { substr: 'WEST ', name: 'Countries starting with West', type: 'keyword' }
    ];
    for (const p of patterns) {
      let arr;
      const sub = p.substr.toUpperCase();
      // If the pattern specifies a space at the end (e.g., "NEW ") treat it as prefix
      if (sub.endsWith(' ')) {
        const prefix = sub.trimEnd();
        arr = pool.filter(e => e.name.toUpperCase().startsWith(prefix));
      } else if (sub.startsWith('-')) {
        // Patterns starting with '-' would indicate suffix, but none are defined here
        arr = [];
      } else if (sub === 'STAN') {
        arr = pool.filter(e => e.name.toUpperCase().endsWith(sub));
      } else {
        arr = pool.filter(e => e.name.toUpperCase().includes(sub));
      }
      if (arr.length >= 4) connectionsThemes.push({ name: p.name, flags: arr, type: p.type });
    }
  }

  /**
   * Build colour-based themes by analysing flag images.  Each flag
   * is sampled at low resolution and pixels are classified into
   * coarse colours (red, yellow, green, blue, black, white).  If a
   * particular colour is present in significant quantities in a flag,
   * that flag is added to the corresponding theme.  The analysis is
   * asynchronous; themes are only added once the images have been
   * processed.  Only categories containing at least 4 flags are kept.
   */
  async function buildColorConnectionsThemes() {
    if (connectionsBuiltColors) return;
    connectionsBuiltColors = true;
    // Temporary buckets for each coarse colour
    const colorBuckets = { red: [], yellow: [], green: [], blue: [], black: [], white: [] };
    // Only use UN member flags for colour themes to exclude territories
    const promises = dataUN.map(entry => new Promise((resolve) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function() {
        try {
          const off = document.createElement('canvas');
          off.width = 100;
          off.height = 60;
          const ctx2 = off.getContext('2d');
          ctx2.drawImage(img, 0, 0, off.width, off.height);
          const pixels = ctx2.getImageData(0, 0, off.width, off.height).data;
          const counts = { red: 0, yellow: 0, green: 0, blue: 0, black: 0, white: 0 };
          for (let i = 0; i < pixels.length; i += 4) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const cat = classifyColor(r, g, b);
            if (counts[cat] !== undefined) counts[cat]++;
          }
          // Determine presence thresholds; at least 100 pixels indicates the colour is
          // strongly present
          for (const c in counts) {
            if (counts[c] > 100) {
              colorBuckets[c].push(entry);
            }
          }
        } catch(err) {
          // ignore errors
        }
        resolve();
      };
      img.onerror = function() { resolve(); };
      // Use a smaller resolution version if available; flagcdn supports w160
      let url = entry.flag;
      url = url.replace('/w320/', '/w160/');
      img.src = url;
    }));
    await Promise.all(promises);
    // Convert colour buckets into themes
    for (const c in colorBuckets) {
      const list = colorBuckets[c];
      if (list.length >= 4) {
        const cap = c.charAt(0).toUpperCase() + c.slice(1);
        connectionsThemes.push({ name: `Flags with ${cap}`, flags: list, type: 'color' });
      }
    }
  }

  /**
   * Ensure that all themes required for the connections game have been built.
   * Builds simple themes synchronously and colour themes asynchronously if
   * they haven't been processed yet.
   */
  async function ensureConnectionsThemes() {
    buildSimpleConnectionsThemes();
    await buildColorConnectionsThemes();
  }

  // ----- Flag Connections Game Implementation -----
  // Data structures for the current connections round. These variables are
  // reset whenever a new round of the connections game starts.
  let connectionsCurrentThemes = [];
  let connectionsGridData = [];
  let connectionsSelected = [];
  let connectionsSolved = [];

  /**
   * Start the Flag Connections mode. This function resets relevant game
   * state, ensures that the theme categories have been built, hides other
   * game UI, and displays the connections panel. Once themes are ready it
   * generates a fresh round of 4 hidden themes and 16 flags.
   */
  async function startConnections() {
    // Set mode and reset score counters
    state.mode = 'connections';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = state.ok;
    streakEl.textContent = state.streak;

    // Reset mistakes used for this round. This counter increases on each wrong guess.
    state.connectionsMistakesUsed = 0;
    // Update the mistakes display and scoreboard pill accordingly
    updateMistakesDisplay();
    // Hide other panels that are not used in connections mode
    // Hide drawing header and controls
    drawHeader.classList.add('hidden');
    drawControls.classList.add('hidden');
    // Hide the canvas used for other modes
    canvas.classList.add('hidden');
    // Hide the answer input and disable it
    answer.classList.add('hidden');
    answer.disabled = true;
    // Disable reveal and next buttons
    revealBtn.disabled = true;
    nextBtn.disabled = true;
    // Clear and hide the result element
    resultEl.innerHTML = '';
    resultEl.classList.add('hidden');
    // Hide the learn/browse panel (so users cannot cheat by browsing the pool)
    learnPanel.classList.add('hidden');
    // Show the connections panel
    connectionsPanel.classList.remove('hidden');
    // Clear any previous solved groups and grid
    connectionsTop.innerHTML = '';
    connectionsGrid.innerHTML = '';
    // Clear any prior status messages (including HTML)
    connectionsStatus.innerHTML = '';
    // Disable submit button until exactly 4 selections are made
    connectionsSubmit.disabled = true;
    // Disable deselect button until there is at least one selection
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    // Hide the generic submit button used in other modes
    submitBtn.classList.add('hidden');
    submitBtn.disabled = true;
    // Build themes (if not already built)
    await ensureConnectionsThemes();
    // Generate a new round
    buildConnectionsRound();
  }

  /**
   * Generate a new round of the Flag Connections game. Chooses four distinct
   * themes at random from the available themes and selects four unique
   * flags for each theme. The resulting 16 flags are shuffled and rendered
   * into the connections grid. Each flag card stores its theme name via a
   * data attribute so that selections can be evaluated later.
   */
  function buildConnectionsRound() {
    // Reset per‚Äëround state
    connectionsCurrentThemes = [];
    connectionsGridData = [];
    connectionsSelected = [];
    connectionsSolved = [];
    // Clear UI
    connectionsTop.innerHTML = '';
    connectionsGrid.innerHTML = '';
    // Clear any status message from previous round
    connectionsStatus.innerHTML = '';
    connectionsSubmit.disabled = true;
    // Disable deselect button at the start of a round
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    // Randomly pick four unique themes that have not yet been solved.
    const themesPool = connectionsThemes.slice();
    shuffle(themesPool);
    const chosenThemes = [];
    while (themesPool.length > 0 && chosenThemes.length < 4) {
      const theme = themesPool.shift();
      // Ensure each chosen theme has at least 4 flags and avoid selecting more than one theme of the same type
      if (theme && Array.isArray(theme.flags) && theme.flags.length >= 4) {
        if (!chosenThemes.some(t => t.type === theme.type)) {
          chosenThemes.push(theme);
        }
      }
    }
    // If fewer than 4 themes were available, abort
    if (chosenThemes.length < 4) {
      connectionsStatus.innerHTML = '<span class="bad">Not enough themes to play.</span>';
      return;
    }
    connectionsCurrentThemes = chosenThemes;
    // Collect flags: pick up to 4 unique flags per theme. Avoid duplicates
    const usedNames = new Set();
    for (const t of chosenThemes) {
      // Shuffle the flags list before picking
      const list = shuffle(t.flags.slice());
      let added = 0;
      for (const e of list) {
        // Ensure we don't reuse the same country across multiple themes
        if (!usedNames.has(e.name)) {
          connectionsGridData.push({ theme: t.name, entry: e });
          usedNames.add(e.name);
          added++;
        }
        if (added >= 4) break;
      }
    }
    // If we ended up with more or less than 16 flags (due to duplicates),
    // adjust by trimming or adding additional flags from the same themes.
    // Trim extras
    if (connectionsGridData.length > 16) {
      connectionsGridData = connectionsGridData.slice(0, 16);
    }
    // Add missing flags by cycling through chosen themes
    let themeIndex = 0;
    while (connectionsGridData.length < 16) {
      const t = chosenThemes[themeIndex % chosenThemes.length];
      // Pick another flag not yet used
      for (const e of t.flags) {
        if (!usedNames.has(e.name)) {
          connectionsGridData.push({ theme: t.name, entry: e });
          usedNames.add(e.name);
          break;
        }
      }
      themeIndex++;
    }
    // Shuffle the final list to randomise placement
    shuffle(connectionsGridData);
    // Render each flag into the grid
    connectionsGridData.forEach((item, idx) => {
      const card = document.createElement('div');
      card.className = 'flag-card';
      card.dataset.idx = idx;
      card.dataset.theme = item.theme;
      card.dataset.solved = 'false';
      const img = document.createElement('img');
      img.src = item.entry.flag;
      img.alt = item.entry.name;
      img.loading = 'lazy';
      card.appendChild(img);
      connectionsGrid.appendChild(card);
    });
  }

  /**
   * Handler for clicking a flag card in the connections grid. Toggles the
   * selected state of the card (up to four selections at a time) and
   * updates the submit button accordingly.
   */
  function onConnectionsCardClick(e) {
    const card = e.target.closest('.flag-card');
    if (!card) return;
    // Ignore clicks on solved cards
    if (card.dataset.solved === 'true') return;
    // Toggle selection
    if (card.classList.contains('selected')) {
      card.classList.remove('selected');
      connectionsSelected = connectionsSelected.filter(x => x !== card);
    } else {
      if (connectionsSelected.length >= 4) {
        // Only allow up to 4 selections
        return;
      }
      card.classList.add('selected');
      connectionsSelected.push(card);
    }
    // Enable submit button only when exactly four cards are selected
    connectionsSubmit.disabled = connectionsSelected.length !== 4;
    // Enable or disable deselect button based on whether any selections are present
    if (connectionsDeselect) connectionsDeselect.disabled = connectionsSelected.length === 0;
  }

  /**
   * Shuffle the unsolved flag cards within the connections grid. Applies a
   * brief fade‚Äëout effect before reordering the DOM to create a pleasing
   * visual shuffle. The selected state is cleared on shuffle.
   */
  function shuffleConnections() {
    // Collect unsolved cards
    const cards = Array.from(connectionsGrid.children).filter(card => card.dataset.solved !== 'true');
    // Clear any selections
    connectionsSelected.forEach(card => card.classList.remove('selected'));
    connectionsSelected = [];
    connectionsSubmit.disabled = true;
    // Disable deselect button since no cards are selected after shuffle
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    // Apply fade‚Äëout
    cards.forEach(card => card.classList.add('fade-out'));
    // After the fade, reorder the cards randomly and fade back in
    setTimeout(() => {
      shuffle(cards);
      cards.forEach(card => connectionsGrid.appendChild(card));
      cards.forEach(card => card.classList.remove('fade-out'));
    }, 200);
  }

  /**
   * Remove all current selections in the connections grid. Used when the user
   * clicks the "Deselect All" button. Clears the selected state of each
   * card, empties the list of currently selected cards, disables the
   * submit and deselect buttons, and clears any status message.
   */
  function deselectConnections() {
    connectionsSelected.forEach(card => card.classList.remove('selected'));
    connectionsSelected = [];
    connectionsSubmit.disabled = true;
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    connectionsStatus.textContent = '';
  }

  /**
   * Evaluate the current selection of four cards. If all four belong to
   * the same theme, they are moved to the solved area with an overlay
   * showing the theme name. If three belong to the same theme and one
   * does not, a ‚ÄúOne Away‚Äù hint is shown. Otherwise, the guess is marked
   * incorrect. After evaluation, selections are cleared.
   */
  function submitConnections() {
    if (connectionsSelected.length !== 4) {
      // Should not happen since the button is disabled otherwise
      return;
    }
    // Tally the themes of selected cards
    const counts = {};
    connectionsSelected.forEach(card => {
      const t = card.dataset.theme;
      counts[t] = (counts[t] || 0) + 1;
    });
    let bestTheme = null;
    let bestCount = 0;
    for (const [theme, count] of Object.entries(counts)) {
      if (count > bestCount) {
        bestTheme = theme;
        bestCount = count;
      }
    }
    // Clear any existing status
    connectionsStatus.textContent = '';
    // Evaluate guess
    if (bestCount === 4 && bestTheme) {
      // Correct connection found. Animate the cards into the solved area.
      connectionsStatus.innerHTML = `<span style="color:var(--ok)">‚úîÔ∏è ${bestTheme}</span>`;
      // Copy selected cards
      const origCards = connectionsSelected.slice();
      // Create group and overlay
      const group = document.createElement('div');
      group.className = 'connection-group new';
      origCards.forEach(card => {
        const imgSrc = card.querySelector('img').src;
        const imgAlt = card.querySelector('img').alt;
        const imgEl = document.createElement('img');
        imgEl.src = imgSrc;
        imgEl.alt = imgAlt;
        group.appendChild(imgEl);
      });
      const overlay = document.createElement('div');
      overlay.className = 'theme-overlay';
      overlay.textContent = bestTheme;
      group.appendChild(overlay);
      // Hide until animation finishes
      group.style.visibility = 'hidden';
      connectionsTop.appendChild(group);
      // Create clones for animation
      const clones = [];
      origCards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const img = card.querySelector('img');
        const clone = img.cloneNode(true);
        clone.style.position = 'fixed';
        clone.style.top = `${rect.top}px`;
        clone.style.left = `${rect.left}px`;
        clone.style.width = `${rect.width}px`;
        clone.style.height = `${rect.height}px`;
        clone.style.margin = '0';
        clone.style.zIndex = '100';
        clone.style.borderRadius = getComputedStyle(card).borderRadius;
        clone.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
        document.body.appendChild(clone);
        clones.push(clone);
        card.dataset.solved = 'true';
        card.classList.remove('selected');
      });
      // Animate clones to new positions
      requestAnimationFrame(() => {
        const finalImgs = group.querySelectorAll('img');
        finalImgs.forEach((finalImg, i) => {
          const finalRect = finalImg.getBoundingClientRect();
          const clone = clones[i];
          const origRect = origCards[i].getBoundingClientRect();
          const dx = finalRect.left - origRect.left;
          const dy = finalRect.top - origRect.top;
          const scaleX = finalRect.width / origRect.width;
          const scaleY = finalRect.height / origRect.height;
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
        });
        setTimeout(() => {
          group.style.visibility = '';
          clones.forEach(cl => cl.remove());
          origCards.forEach(card => card.remove());
        }, 650);
      });
      connectionsSolved.push(bestTheme);
      connectionsSelected = [];
      connectionsSubmit.disabled = true;
      // Disable deselect button since no cards are selected
      if (connectionsDeselect) connectionsDeselect.disabled = true;
      if (connectionsSolved.length === 4) {
        connectionsStatus.innerHTML = `<span style="color:var(--ok)">üéâ You solved all connections!</span>`;
      }
    } else {
      // Wrong or one-away guess. Decrement or increment mistakes count accordingly.
      // Determine if this guess is one away or completely wrong
      const oneAway = bestCount === 3;
      if (oneAway) {
        connectionsStatus.innerHTML = `<span style="color:var(--warn)">One Away!</span>`;
      } else {
        connectionsStatus.innerHTML = `<span style="color:var(--bad)">Not a connection.</span>`;
      }
      // Increase mistakes used count
      state.connectionsMistakesUsed++;
      // Update mistakes UI
      updateMistakesDisplay();
      // If unlimited mistakes disabled and mistakes exceed maxMistakes, end the game
      if (!state.unlimitedMistakes) {
        const remaining = (state.maxMistakes || 4) - state.connectionsMistakesUsed;
        if (remaining <= 0) {
          // No more mistakes allowed: reveal all remaining connections and end the round.
          connectionsStatus.innerHTML = `<span style="color:var(--bad)">No mistakes remaining.</span>`;
          // Animate and reveal all unsolved connections, then disable further interaction.
          revealAllConnections();
          return;
        }
      }
      // Clear selections for next guess
      connectionsSelected.forEach(card => card.classList.remove('selected'));
      connectionsSelected = [];
      connectionsSubmit.disabled = true;
      // Disable deselect button as no cards are selected
      if (connectionsDeselect) connectionsDeselect.disabled = true;
    }
  }

  /**
   * Update the colour swatch to reflect the currently selected brush colour.
   * Sets both the swatch background and border to the brush colour for
   * easy visual reference.
   */
  function updateSwatch() {
    if (!colorSwatch) return;
    const col = drawColor.value;
    colorSwatch.style.backgroundColor = col;
    colorSwatch.style.borderColor = col;
  }

  /**
   * Reveal all remaining connections when the player runs out of mistakes.
   * This function groups the unsolved flags by their theme and moves them
   * into the solved area with the same animation used for correct guesses.
   * After revealing all connections, the grid is disabled so the user
   * cannot make further selections in the current round.
   */
  function revealAllConnections() {
    // Gather all unsolved cards (those not already marked as solved)
    const unsolved = Array.from(connectionsGrid.children).filter(card => card.dataset.solved !== 'true');
    if (unsolved.length === 0) {
      return;
    }
    // Group cards by their theme name
    const groups = {};
    unsolved.forEach(card => {
      const theme = card.dataset.theme;
      if (!groups[theme]) groups[theme] = [];
      groups[theme].push(card);
    });
    // For each theme group, animate the cards into the solved area
    Object.keys(groups).forEach(theme => {
      const cards = groups[theme];
      if (!cards || cards.length === 0) return;
      // Create solved group container and overlay
      const group = document.createElement('div');
      group.className = 'connection-group new';
      // Add flag images to the group
      cards.forEach(card => {
        const img = card.querySelector('img');
        const imgEl = document.createElement('img');
        imgEl.src = img.src;
        imgEl.alt = img.alt;
        group.appendChild(imgEl);
      });
      const overlay = document.createElement('div');
      overlay.className = 'theme-overlay';
      overlay.textContent = theme;
      group.appendChild(overlay);
      group.style.visibility = 'hidden';
      connectionsTop.appendChild(group);
      // Create clones for animation
      const clones = [];
      cards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const img = card.querySelector('img');
        const clone = img.cloneNode(true);
        clone.style.position = 'fixed';
        clone.style.top = `${rect.top}px`;
        clone.style.left = `${rect.left}px`;
        clone.style.width = `${rect.width}px`;
        clone.style.height = `${rect.height}px`;
        clone.style.margin = '0';
        clone.style.zIndex = '100';
        clone.style.borderRadius = getComputedStyle(card).borderRadius;
        clone.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
        document.body.appendChild(clone);
        clones.push(clone);
        // Mark original card as solved and remove selected state
        card.dataset.solved = 'true';
        card.classList.remove('selected');
      });
      // Start animation on next frame
      requestAnimationFrame(() => {
        const finalImgs = group.querySelectorAll('img');
        finalImgs.forEach((finalImg, i) => {
          const finalRect = finalImg.getBoundingClientRect();
          const origRect = cards[i].getBoundingClientRect();
          const dx = finalRect.left - origRect.left;
          const dy = finalRect.top - origRect.top;
          const scaleX = finalRect.width / origRect.width;
          const scaleY = finalRect.height / origRect.height;
          const clone = clones[i];
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
        });
        setTimeout(() => {
          group.style.visibility = '';
          clones.forEach(cl => cl.remove());
          cards.forEach(card => card.remove());
        }, 650);
      });
    });
    // Clear any selections and disable further interaction with the grid
    connectionsSelected.forEach(card => card.classList.remove('selected'));
    connectionsSelected = [];
    connectionsSubmit.disabled = true;
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    if (connectionsShuffle) connectionsShuffle.disabled = true;
    // Remove click handlers from all cards
    connectionsGrid.querySelectorAll('.flag-card').forEach(card => {
      card.removeEventListener('click', onConnectionsCardClick);
    });
  }

  /**
   * Generate a palette of colours extracted directly from a flag image.
   *
   * Unlike the coarse classification approach, this function performs a
   * simple quantisation of all pixels to identify the actual colours
   * present in the flag. The flag image is drawn into an offscreen
   * canvas, and each pixel is quantised into a lower resolution
   * colour space by rounding the R, G and B channels to the nearest
   * multiple of 32 (i.e. 5 bits per channel). This allows similar
   * shades to be grouped together while still preserving the variety
   * of distinct colours. For each quantised colour cluster the
   * average of the original RGB values is computed. The resulting
   * palette is sorted by frequency (most common colours first) and
   * used to populate the <datalist> for the brush colour picker. The
   * first colour in the list is also set as the current brush colour.
   *
   * @param {string} url URL of the flag image to sample
   */
  function generatePaletteForFlag(url) {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = function() {
      // Create an offscreen canvas to sample colours.  A modest
      // resolution balances detail with performance.
      const off = document.createElement('canvas');
      off.width = 200;
      off.height = 120;
      const octx = off.getContext('2d');
      // Draw the flag onto the offscreen canvas. Aspect ratio
      // preservation is not critical for colour sampling.
      octx.drawImage(img, 0, 0, off.width, off.height);
      const pixels = octx.getImageData(0, 0, off.width, off.height).data;
      // Map of quantised colour keys to aggregated stats
      const clusters = {};
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2];
        // Quantise each channel to 5 bits (0-255 -> 0-255 in steps of 32)
        const qR = Math.round(r / 32) * 32;
        const qG = Math.round(g / 32) * 32;
        const qB = Math.round(b / 32) * 32;
        const key = `${qR},${qG},${qB}`;
        if (!clusters[key]) {
          clusters[key] = { sumR: 0, sumG: 0, sumB: 0, count: 0 };
        }
        clusters[key].sumR += r;
        clusters[key].sumG += g;
        clusters[key].sumB += b;
        clusters[key].count++;
      }
      // Convert clusters into an array of {hex, count} objects
      const palette = Object.keys(clusters).map(key => {
        const { sumR, sumG, sumB, count } = clusters[key];
        const avgR = Math.round(sumR / count);
        const avgG = Math.round(sumG / count);
        const avgB = Math.round(sumB / count);
        const hex = '#' + [avgR, avgG, avgB]
          .map(c => c.toString(16).padStart(2, '0'))
          .join('');
        return { hex, count };
      });
      // Sort by descending frequency (largest clusters first) then
      // lexicographically for deterministic ordering
      palette.sort((a, b) => b.count - a.count || a.hex.localeCompare(b.hex));
      // Limit the palette to a reasonable number of colours (e.g. 8)
      const colors = palette.slice(0, 8).map(p => p.hex);
      const list = document.getElementById('flagColors');
      if (list) {
        list.innerHTML = colors.map(col => `<option value="${col}"></option>`).join('');
      }
      // Update the brush colour to the first colour in the palette
      if (colors.length > 0) {
        drawColor.value = colors[0];
        ctx.strokeStyle = drawColor.value;
        updateSwatch();
      }

  /**
   * Reveal all remaining connections when the player runs out of mistakes.
   * This function groups the unsolved flags by their theme and moves them
   * into the solved area with the same animation used for correct guesses.
   * After revealing all connections, the grid is disabled so the user
   * cannot make further selections in the current round.
   */
  function revealAllConnections() {
    // Gather all unsolved cards (those not already marked as solved)
    const unsolved = Array.from(connectionsGrid.children).filter(card => card.dataset.solved !== 'true');
    if (unsolved.length === 0) {
      return;
    }
    // Group cards by their theme name
    const groups = {};
    unsolved.forEach(card => {
      const theme = card.dataset.theme;
      if (!groups[theme]) groups[theme] = [];
      groups[theme].push(card);
    });
    // For each theme group, animate the cards into the solved area
    Object.keys(groups).forEach(theme => {
      const cards = groups[theme];
      if (!cards || cards.length === 0) return;
      // Create solved group container and overlay
      const group = document.createElement('div');
      group.className = 'connection-group new';
      // Add flag images to the group
      cards.forEach(card => {
        const img = card.querySelector('img');
        const imgEl = document.createElement('img');
        imgEl.src = img.src;
        imgEl.alt = img.alt;
        group.appendChild(imgEl);
      });
      const overlay = document.createElement('div');
      overlay.className = 'theme-overlay';
      overlay.textContent = theme;
      group.appendChild(overlay);
      group.style.visibility = 'hidden';
      connectionsTop.appendChild(group);
      // Create clones for animation
      const clones = [];
      cards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const img = card.querySelector('img');
        const clone = img.cloneNode(true);
        clone.style.position = 'fixed';
        clone.style.top = `${rect.top}px`;
        clone.style.left = `${rect.left}px`;
        clone.style.width = `${rect.width}px`;
        clone.style.height = `${rect.height}px`;
        clone.style.margin = '0';
        clone.style.zIndex = '100';
        clone.style.borderRadius = getComputedStyle(card).borderRadius;
        clone.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
        document.body.appendChild(clone);
        clones.push(clone);
        // Mark original card as solved and remove selected state
        card.dataset.solved = 'true';
        card.classList.remove('selected');
      });
      // Start animation on next frame
      requestAnimationFrame(() => {
        const finalImgs = group.querySelectorAll('img');
        finalImgs.forEach((finalImg, i) => {
          const finalRect = finalImg.getBoundingClientRect();
          const origRect = cards[i].getBoundingClientRect();
          const dx = finalRect.left - origRect.left;
          const dy = finalRect.top - origRect.top;
          const scaleX = finalRect.width / origRect.width;
          const scaleY = finalRect.height / origRect.height;
          const clone = clones[i];
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
        });
        setTimeout(() => {
          group.style.visibility = '';
          clones.forEach(cl => cl.remove());
          cards.forEach(card => card.remove());
        }, 650);
      });
    });
    // Clear any selections and disable further interaction with the grid
    connectionsSelected.forEach(card => card.classList.remove('selected'));
    connectionsSelected = [];
    connectionsSubmit.disabled = true;
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    if (connectionsShuffle) connectionsShuffle.disabled = true;
    // Remove click handlers from all cards
    connectionsGrid.querySelectorAll('.flag-card').forEach(card => {
      card.removeEventListener('click', onConnectionsCardClick);
    });
  }
    };
    img.onerror = function() {
      // On error, clear the datalist to avoid stale entries
      const list = document.getElementById('flagColors');
      if (list) list.innerHTML = '';
    };
    img.src = url;
  }

  function submit(){
    if(state.mode==='draw'){
      // In draw-from-memory mode, evaluate similarity between the drawn flag and the real flag
      if(!state.current) return;
      // Disable submit button to prevent multiple submissions
      submitBtn.disabled = true;
      try {
        const drawnData = ctx.getImageData(0,0,canvas.width,canvas.height).data;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function() {
          const off = document.createElement('canvas');
          off.width = canvas.width;
          off.height = canvas.height;
          const octx = off.getContext('2d');
          octx.drawImage(img, 0, 0, off.width, off.height);
          const flagData = octx.getImageData(0,0,off.width,off.height).data;
          // Compute colour-category similarity instead of raw RGB differences.  For each pixel
          // classify both the drawn and the real flag colours into coarse categories
          // (white, black, red, yellow, green, blue) and count matches.  The final
          // percentage is the fraction of pixels whose categories match.
          let matchesCount = 0;
          const totalPixels = drawnData.length / 4;
          for(let i=0; i<drawnData.length; i+=4){
            const dc = classifyColor(drawnData[i], drawnData[i+1], drawnData[i+2]);
            const fc = classifyColor(flagData[i], flagData[i+1], flagData[i+2]);
            if(dc === fc) matchesCount++;
          }
          const closeness = totalPixels > 0 ? matchesCount / totalPixels : 0;
          const percent = closeness * 100;
          // Show similarity and also display the actual flag image below.
          const score = percent.toFixed(2);
          resultEl.innerHTML =
            'Your drawing matches the real flag by ' + score + '%'
            + '<br><span class="warn">Actual Flag:</span><br>'
            + '<img src="' + state.current.flag + '" style="max-width:100%;border-radius:8px;margin-top:4px;">';
          // Show the Next button to allow proceeding to another flag
          nextBtn.classList.remove('hidden');
          nextBtn.disabled = false;
          // Keep reveal button hidden in draw mode
          revealBtn.classList.add('hidden');
          revealBtn.disabled = true;
        };
        img.onerror = function() {
          // On error computing similarity, inform the user and show the real flag anyway
          resultEl.innerHTML = 'Could not compute similarity.'
            + '<br><span class="warn">Actual Flag:</span><br>'
            + '<img src="' + state.current.flag + '" style="max-width:100%;border-radius:8px;margin-top:4px;">';
          nextBtn.classList.remove('hidden');
          nextBtn.disabled = false;
        };
        img.src = state.current.flag;
      } catch(err) {
        // Generic error computing similarity: show message and real flag
        resultEl.innerHTML = 'Could not compute similarity.'
          + '<br><span class="warn">Actual Flag:</span><br>'
          + '<img src="' + state.current.flag + '" style="max-width:100%;border-radius:8px;margin-top:4px;">';
        nextBtn.classList.remove('hidden');
        nextBtn.disabled = false;
      }
      return;
    } else if(state.mode==='classic' || state.mode==='endless'){
      if(!state.current) return;
      const val=answer.value.trim(); if(!val) return; answer.value='';
      if(matches(val,state.current)){
        // correct answer: increment counters and move to next flag
        state.ok++; state.streak++;
        okEl.textContent = state.ok;
        streakEl.textContent = state.streak;
        if(state.mode === 'endless'){
          resultEl.innerHTML = `<span class="ok">Correct!</span>`;
        } else {
          resultEl.innerHTML = `<span class="ok">Correct!</span> ${state.current.name}`;
        }
        nextFlag();
      } else {
        // incorrect guess
        state.streak = 0;
        streakEl.textContent = 0;
        if(state.mode === 'endless'){
          // In endless mode, end the game and display Game Over on the canvas
          resultEl.innerHTML = `<span class="bad">Game Over</span>`;
          answer.disabled = true;
          submitBtn.disabled = true;
          revealBtn.disabled = true;
          nextBtn.disabled = true;
          // Clear canvas and draw Game Over text
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bad') || '#fb7185';
          ctx.font = 'bold 48px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Game Over', canvas.width/2, canvas.height/2);
        } else {
          resultEl.innerHTML = `<span class="bad">Nope.</span> (${state.current.name})`;
          if(state.effectsCurrent.six && state.piecesRevealed<6){ state.piecesRevealed++; renderCurrent(); }
        }
      }
      answer.focus();
    } else if(state.mode==='memory'){
      const seq=state.memory.sequence; const idx=state.memory.index; if(idx>=seq.length) return;
      const val=answer.value.trim(); if(!val) return; answer.value='';
      if(matches(val,seq[idx])){
        state.memory.index++;
        if(state.memory.index===seq.length){ resultEl.innerHTML='<span class="ok">You nailed all 5!</span>'; }
        else { resultEl.innerHTML=`<span class="ok">Correct</span> ‚Äî ${idx+1}/5`; }
      } else {
        resultEl.innerHTML = `<span class="bad">Wrong at #${idx+1}.</span> Correct order: ${seq.map(e=>e.name).join(' ‚Ä¢ ')}`;
        state.mode='classic';
      }
      answer.focus();
    }
  }

  async function startMemory(){
    state.mode='memory'; resultEl.textContent='';
    // Hide draw header in memory mode
    drawHeader.classList.add('hidden');
    // Hide connections panel when entering memory mode
    connectionsPanel.classList.add('hidden');
    // Ensure canvas and result area are visible
    canvas.classList.remove('hidden');
    resultEl.classList.remove('hidden');
    // Show the generic submit button for memory mode (disabled until ready)
    submitBtn.classList.remove('hidden');
    // Ensure the answer input is visible and drawing controls are hidden when entering memory mode
    answer.classList.remove('hidden');
    drawControls.classList.add('hidden');
    // Ensure controls and learn panel are visible when entering memory mode
    revealBtn.classList.remove('hidden');
    nextBtn.classList.remove('hidden');
    learnPanel.classList.remove('hidden');
    // Update mode display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    const src=shuffle(getSource().slice()); state.memory.sequence=src.slice(0,5); state.memory.index=0;
    answer.disabled=true; submitBtn.disabled=true; revealBtn.disabled=true; nextBtn.disabled=true;
    const delay=ms=>new Promise(r=>setTimeout(r,ms));
    for(const e of state.memory.sequence){
      state.effectsCurrent = JSON.parse(JSON.stringify(state.effectsPending));
      drawFlag(e);
      await delay(state.timerMs===Infinity?700:Math.max(10,state.timerMs));
      ctx.clearRect(0,0,canvas.width,canvas.height);
      await delay(250);
    }
    resultEl.innerHTML='Type the 5 flags <b>in order</b> and press Enter after each.';
    answer.disabled=false; submitBtn.disabled=false; answer.value=''; answer.focus();
    revealBtn.disabled=false; nextBtn.disabled=false;
  }

  function updateTimer(){ if(timerInfinite.checked){ state.timerMs=Infinity; timerVal.textContent='‚àû'; } else { const v=parseFloat(timerRange.value||'5'); state.timerMs=Math.round(Math.max(0.01,Math.min(5,v))*1000); timerVal.textContent=(state.timerMs/1000).toFixed(2)+'s'; } }

  function syncPendingFromUI(){
    const p = state.effectsPending;
    p.blurOn = blurToggle.checked; p.blurPx = +blurRange.value; blurVal.textContent = p.blurPx+"px";
    p.pixelOn = pixelToggle.checked; p.pixel = +pixelRange.value; pixelVal.textContent = String(p.pixel);
    p.zoomOn = zoomToggle.checked; p.zoom = +zoomRange.value; zoomVal.textContent = p.zoom.toFixed(1)+"√ó";
    p.six = sixToggle.checked;
    p.randColor = randColorToggle.checked;
    p.gs = +gsRange.value; gsVal.textContent = p.gs.toFixed(2);
    p.inv = +invRange.value; invVal.textContent = p.inv.toFixed(2);
    p.hue = +hueRange.value; hueVal.textContent = p.hue+"¬∞";
    p.sat = +satRange.value; satVal.textContent = p.sat.toFixed(2)+"√ó";
    p.con = +conRange.value; conVal.textContent = p.con.toFixed(2)+"√ó";
  }

  function onEffectUIChange(){
    syncPendingFromUI();
    document.getElementById('applyNote').classList.remove('hidden');
    // Update the preview canvas so users can see the new effects immediately
    updatePreview();
  }

  settingsBtn.addEventListener('click',()=>settingsPanel.classList.toggle('hidden'));
  closeSettings.addEventListener('click',()=>settingsPanel.classList.add('hidden'));
  ['change','input'].forEach(ev=>{
    [blurToggle,blurRange,pixelToggle,pixelRange,zoomToggle,zoomRange,sixToggle,randColorToggle,gsRange,invRange,hueRange,satRange,conRange].forEach(el=>el.addEventListener(ev,onEffectUIChange));
  });

  timerInfinite.addEventListener('change', updateTimer);
  timerRange.addEventListener('input', ()=>{timerInfinite.checked=false; updateTimer();});
  updateTimer();
  syncPendingFromUI();

  uiBtn.addEventListener('click',()=>uiPanel.classList.toggle('hidden'));
  closeUi.addEventListener('click',()=>uiPanel.classList.add('hidden'));
  themeSelect.addEventListener('change',()=>{ document.documentElement.setAttribute('data-theme', themeSelect.value); });
  accentPicker.addEventListener('input',()=>{ document.documentElement.style.setProperty('--accent', accentPicker.value); });

  document.getElementById('flagCats').addEventListener('click',(e)=>{
    const b=e.target.closest('button[data-tab]');
    if(!b) return;
    const tab=b.dataset.tab;
    [...document.querySelectorAll('#flagCats button')].forEach(x=>x.classList.toggle('active', x===b));
    state.activeTab=tab;
    if(tab==='Custom'){ customSelect.classList.remove('hidden'); createCustomBtn.classList.remove('hidden'); buildCustomOptions(); }
    else { customSelect.classList.add('hidden'); createCustomBtn.classList.add('hidden'); }
    updateDatalist(); buildLearn(); resultEl.textContent='';
  });

  // Start button chooses a mode based on the game mode selector
  startBtn.addEventListener('click', () => {
    // Determine which mode has been chosen from the mode selector. Default to
    // classic if none is selected.
    const mode = modeSelect.value || 'classic';
    if (mode === 'memory') {
      startMemory();
    } else if (mode === 'endless') {
      startEndless();
    } else if (mode === 'draw') {
      startDraw();
    } else if (mode === 'connections') {
      startConnections();
    } else {
      // 'classic' and any unknown value fallback to the classic game mode
      startGame();
    }
  });
  nextBtn.addEventListener('click', () => {
    if(state.mode === 'draw'){
      nextDraw();
    } else {
      nextFlag();
    }
  });
  revealBtn.addEventListener('click', () => {
    if(!state.current) return;
    if(state.mode === 'draw'){
      // Show the actual flag for comparison in draw mode
      resultEl.innerHTML = `<span class="warn">Actual Flag:</span><br><img src="${state.current.flag}" style="max-width:100%;border-radius:8px;margin-top:4px;"><br>${state.current.name}`;
    } else {
      state.piecesRevealed = 6;
      renderCurrent();
      resultEl.innerHTML = `<span class="warn">Answer:</span> ${state.current.name}`;
    }
  });
  submitBtn.addEventListener('click', submit);
  answer.addEventListener('keydown', e=>{ if(e.key==='Enter') submit(); });
  // removed memoryBtn click listener (replaced by mode selector)

  // Update the stroke colour whenever the user picks a new colour
  drawColor.addEventListener('input', () => {
    ctx.strokeStyle = drawColor.value;
    updateSwatch();
  });

  // Drawing logic for draw-from-memory mode
  let drawing = false;
  let lastX = 0;
  let lastY = 0;
  // Pointer-based drawing: capture pointer to avoid accidental
  // termination when the pointer leaves the canvas. We call
  // setPointerCapture on pointerdown and releasePointerCapture on
  // pointerup. The end of a drawing stroke is handled only on
  // pointerup.
  canvas.addEventListener('pointerdown', (e) => {
    if (state.mode !== 'draw') return;
    // Determine canvas coordinates
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * canvas.width / rect.width;
    const y = (e.clientY - rect.top) * canvas.height / rect.height;
    // Save state for undo before any drawing operation
    saveState();
    // Handle colour picker tool: sample the clicked pixel's colour and set brush
    if (currentTool === 'picker') {
      try {
        const pixel = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
        const hex = '#' + [pixel[0], pixel[1], pixel[2]].map(v => v.toString(16).padStart(2, '0')).join('');
        drawColor.value = hex;
        ctx.strokeStyle = hex;
        // Update swatch to reflect the picked colour
        updateSwatch();
        // Automatically revert to the previously selected tool for convenience
        selectTool(prevTool || 'pen');
      } catch(err) {
        console.warn('Eyedropper failed', err);
      }
      return;
    }
    // Handle fill bucket tool
    if (currentTool === 'fill') {
      // Fill the region starting at the clicked pixel
      floodFill(x, y);
      // No further drawing for fill tool
      return;
    }
    // If the current tool is a shape, prepare to draw a shape.  Use the
    // shapeTools array to identify all supported shape types.
    if (shapeTools.includes(currentTool)) {
      drawingShape = true;
      startX = x;
      startY = y;
      // Capture a snapshot of the canvas for previewing the shape
      try {
        shapePreviewImgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      } catch(err) {
        shapePreviewImgData = null;
      }
      // Use pointer capture so we continue receiving events
      try { canvas.setPointerCapture(e.pointerId); } catch(err) {}
      return;
    }
    // Freehand drawing or erasing tools
    drawing = true;
    try {
      canvas.setPointerCapture(e.pointerId);
    } catch(err) {}
    // Configure stroke styles
    if (currentTool === 'eraser') {
      // Use destination-out blending for the eraser. This will punch holes in
      // existing drawings regardless of brush colour. A solid stroke colour
      // must still be provided (black here) but is ignored when compositing.
      ctx.globalCompositeOperation = 'destination-out';
      ctx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      // Normal drawing uses the selected colour and source-over composition.
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = drawColor.value;
    }
    ctx.lineWidth = parseFloat(drawSize.value);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(x, y);
    lastX = x;
    lastY = y;
  });
  canvas.addEventListener('pointermove', (e) => {
    if (state.mode !== 'draw') return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * canvas.width / rect.width;
    const y = (e.clientY - rect.top) * canvas.height / rect.height;
    // Preview shapes while the pointer is down
    if (drawingShape) {
      // Restore the canvas to its state at the beginning of the shape
      if (shapePreviewImgData) {
        ctx.putImageData(shapePreviewImgData, 0, 0);
      }
      // Use a dashed stroke for previews
      ctx.save();
      ctx.setLineDash([6, 4]);
      ctx.lineWidth = parseFloat(drawSize.value);
      ctx.strokeStyle = drawColor.value;
      switch (currentTool) {
        case 'line':
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.stroke();
          break;
        case 'rect': {
          const w = x - startX;
          const h = y - startY;
          ctx.strokeRect(startX, startY, w, h);
          break;
        }
        case 'circle': {
          const dx = x - startX;
          const dy = y - startY;
          const radius = Math.sqrt(dx * dx + dy * dy);
          ctx.beginPath();
          ctx.arc(startX, startY, radius, 0, Math.PI * 2);
          ctx.stroke();
          break;
        }
        case 'ellipse': {
          const rx = (x - startX) / 2;
          const ry = (y - startY) / 2;
          const cx = startX + rx;
          const cy = startY + ry;
          ctx.beginPath();
          ctx.ellipse(cx, cy, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI * 2);
          ctx.stroke();
          break;
        }
        case 'triangle':
          // Draw a right‚Äëangled triangle preview
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.lineTo(startX, y);
          ctx.closePath();
          ctx.stroke();
          break;
        case 'pentagon': {
          // Draw a pentagon preview based on bounding box percentages
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + 0.5 * w, startY); // top
          ctx.lineTo(startX + 1.0 * w, startY + 0.38 * h);
          ctx.lineTo(startX + 0.81 * w, startY + 1.0 * h);
          ctx.lineTo(startX + 0.19 * w, startY + 1.0 * h);
          ctx.lineTo(startX, startY + 0.38 * h);
          ctx.closePath();
          ctx.stroke();
          break;
        }
        case 'hexagon': {
          // Draw a hexagon preview based on bounding box percentages
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + 0.25 * w, startY); // top‚Äëleft slanted
          ctx.lineTo(startX + 0.75 * w, startY);
          ctx.lineTo(startX + 1.0 * w, startY + 0.5 * h);
          ctx.lineTo(startX + 0.75 * w, startY + 1.0 * h);
          ctx.lineTo(startX + 0.25 * w, startY + 1.0 * h);
          ctx.lineTo(startX, startY + 0.5 * h);
          ctx.closePath();
          ctx.stroke();
          break;
        }
        case 'star': {
          // Draw a five‚Äëpointed star preview centred in the bounding box.
          const w = x - startX;
          const h = y - startY;
          const sx = startX;
          const sy = startY;
          const wAbs = Math.abs(w);
          const hAbs = Math.abs(h);
          const cx = sx + w / 2;
          const cy = sy + h / 2;
          // Outer radius based on the smaller dimension; inner radius at half the outer
          const outer = 0.5 * Math.min(wAbs, hAbs);
          const inner = outer * 0.5;
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const angle = -Math.PI / 2 + i * (2 * Math.PI / 5);
            const ox = cx + outer * Math.cos(angle);
            const oy = cy + outer * Math.sin(angle);
            if (i === 0) ctx.moveTo(ox, oy); else ctx.lineTo(ox, oy);
            const innerAngle = angle + Math.PI / 5;
            const ix = cx + inner * Math.cos(innerAngle);
            const iy = cy + inner * Math.sin(innerAngle);
            ctx.lineTo(ix, iy);
          }
          ctx.closePath();
          ctx.stroke();
          break;
        }
        case 'heart': {
          // Draw a heart preview inside the bounding box using B√©zier curves.
          const w = x - startX;
          const h = y - startY;
          const sx = Math.min(startX, x);
          const sy = Math.min(startY, y);
          const wAbs = Math.abs(w);
          const hAbs = Math.abs(h);
          ctx.beginPath();
          ctx.moveTo(sx + 0.5 * wAbs, sy + 0.35 * hAbs);
          ctx.bezierCurveTo(sx + wAbs, sy, sx + wAbs, sy + 0.7 * hAbs, sx + 0.5 * wAbs, sy + hAbs);
          ctx.bezierCurveTo(sx, sy + 0.7 * hAbs, sx, sy, sx + 0.5 * wAbs, sy + 0.35 * hAbs);
          ctx.closePath();
          ctx.stroke();
          break;
        }
        case 'diamond': {
          // Draw a diamond (rhombus) preview based on bounding box.  The
          // diamond is essentially a rotated square defined by its
          // bounding box.  It uses four points: top, right, bottom and
          // left midpoints of the bounding box.
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + w / 2, startY);
          ctx.lineTo(startX + w, startY + h / 2);
          ctx.lineTo(startX + w / 2, startY + h);
          ctx.lineTo(startX, startY + h / 2);
          ctx.closePath();
          ctx.stroke();
          break;
        }
      }
      ctx.restore();
      return;
    }
    // Handle freehand drawing and erasing
    if (drawing && (currentTool === 'pen' || currentTool === 'eraser')) {
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x;
      lastY = y;
    }
  });
  function endDrawingEvent(e) {
    if (state.mode !== 'draw') return;
    // Finalize drawing shapes or freehand on pointer up
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * canvas.width / rect.width;
    const y = (e.clientY - rect.top) * canvas.height / rect.height;
    if (drawingShape) {
      drawingShape = false;
      // Restore the canvas to its snapshot before drawing the shape
      if (shapePreviewImgData) {
        ctx.putImageData(shapePreviewImgData, 0, 0);
      }
      ctx.globalCompositeOperation = 'source-over';
      ctx.lineWidth = parseFloat(drawSize.value);
      ctx.strokeStyle = drawColor.value;
      ctx.fillStyle = drawColor.value;
      switch (currentTool) {
        case 'line':
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.stroke();
          break;
        case 'rect': {
          const w = x - startX;
          const h = y - startY;
          if (document.getElementById('shapeFill').checked) {
            ctx.fillRect(startX, startY, w, h);
          }
          ctx.strokeRect(startX, startY, w, h);
          break;
        }
        case 'circle': {
          const dx = x - startX;
          const dy = y - startY;
          const radius = Math.sqrt(dx * dx + dy * dy);
          ctx.beginPath();
          ctx.arc(startX, startY, radius, 0, Math.PI * 2);
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'ellipse': {
          const rx = (x - startX) / 2;
          const ry = (y - startY) / 2;
          const cx = startX + rx;
          const cy = startY + ry;
          ctx.beginPath();
          ctx.ellipse(cx, cy, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI * 2);
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'triangle':
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.lineTo(startX, y);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        case 'pentagon': {
          // Finalize pentagon shape
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + 0.5 * w, startY);
          ctx.lineTo(startX + 1.0 * w, startY + 0.38 * h);
          ctx.lineTo(startX + 0.81 * w, startY + 1.0 * h);
          ctx.lineTo(startX + 0.19 * w, startY + 1.0 * h);
          ctx.lineTo(startX, startY + 0.38 * h);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'hexagon': {
          // Finalize hexagon shape
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + 0.25 * w, startY);
          ctx.lineTo(startX + 0.75 * w, startY);
          ctx.lineTo(startX + 1.0 * w, startY + 0.5 * h);
          ctx.lineTo(startX + 0.75 * w, startY + 1.0 * h);
          ctx.lineTo(startX + 0.25 * w, startY + 1.0 * h);
          ctx.lineTo(startX, startY + 0.5 * h);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'star': {
          // Finalize star shape
          const w = x - startX;
          const h = y - startY;
          const wAbs = Math.abs(w);
          const hAbs = Math.abs(h);
          // Determine centre of bounding box
          const cx = startX + w / 2;
          const cy = startY + h / 2;
          const outer = 0.5 * Math.min(wAbs, hAbs);
          const inner = outer * 0.5;
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const angle = -Math.PI / 2 + i * (2 * Math.PI / 5);
            const ox = cx + outer * Math.cos(angle);
            const oy = cy + outer * Math.sin(angle);
            if (i === 0) ctx.moveTo(ox, oy); else ctx.lineTo(ox, oy);
            const innerAngle = angle + Math.PI / 5;
            const ix = cx + inner * Math.cos(innerAngle);
            const iy = cy + inner * Math.sin(innerAngle);
            ctx.lineTo(ix, iy);
          }
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'heart': {
          // Finalize heart shape
          const w = x - startX;
          const h = y - startY;
          const sx2 = Math.min(startX, x);
          const sy2 = Math.min(startY, y);
          const wAbs = Math.abs(w);
          const hAbs = Math.abs(h);
          ctx.beginPath();
          ctx.moveTo(sx2 + 0.5 * wAbs, sy2 + 0.35 * hAbs);
          ctx.bezierCurveTo(sx2 + wAbs, sy2, sx2 + wAbs, sy2 + 0.7 * hAbs, sx2 + 0.5 * wAbs, sy2 + hAbs);
          ctx.bezierCurveTo(sx2, sy2 + 0.7 * hAbs, sx2, sy2, sx2 + 0.5 * wAbs, sy2 + 0.35 * hAbs);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'diamond': {
          // Finalize diamond shape using four vertices at the midpoints of each side
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + w / 2, startY);
          ctx.lineTo(startX + w, startY + h / 2);
          ctx.lineTo(startX + w / 2, startY + h);
          ctx.lineTo(startX, startY + h / 2);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
      }
      // Clear the preview snapshot after finalizing
      shapePreviewImgData = null;
    }
    // Finish freehand drawing or eraser tool
    drawing = false;
    ctx.globalCompositeOperation = 'source-over';
    if (e && typeof e.pointerId === 'number') {
      try {
        canvas.releasePointerCapture(e.pointerId);
      } catch(err) { /* ignore if unsupported */ }
    }
  }
  canvas.addEventListener('pointerup', endDrawingEvent);
  // We intentionally do not end drawing on pointerleave to prevent
  // accidental cut‚Äëoffs; pointerup will properly end the stroke.

  /**
   * Set the current drawing tool and update the active button styling.
   * @param {string} tool Name of the tool ('pen','eraser','fill','picker','line','rect','circle','ellipse','triangle')
   */
  function selectTool(tool) {
    currentTool = tool;
    // Remove active classes from all tools and shape dropdown
    [toolPen, toolEraser, toolFill, toolPicker].forEach(btn => btn.classList.remove('active'));
    shapeSelect.classList.remove('active');
    // Highlight whichever tool was selected. If it's a shape, highlight the
    // shape dropdown and set its value accordingly.
    if (tool === 'pen') {
      toolPen.classList.add('active');
    } else if (tool === 'eraser') {
      toolEraser.classList.add('active');
    } else if (tool === 'fill') {
      toolFill.classList.add('active');
    } else if (tool === 'picker') {
      toolPicker.classList.add('active');
    } else if (shapeTools.includes(tool)) {
      shapeSelect.classList.add('active');
      // Update the shape dropdown to match the selected shape
      shapeSelect.value = tool;
    }
  }
  // Initialise default tool
  selectTool('pen');
  // Initialise the colour swatch with the default brush colour
  updateSwatch();
  // Tool button event listeners
  toolPen.addEventListener('click', () => selectTool('pen'));
  toolEraser.addEventListener('click', () => selectTool('eraser'));
  toolFill.addEventListener('click', () => selectTool('fill'));
  toolPicker.addEventListener('click', () => {
    // Remember the current tool so we can revert after picking
    prevTool = currentTool;
    selectTool('picker');
  });
  // Undo is a one-off action, does not change current tool
  toolUndo.addEventListener('click', () => undo());
  // Clear canvas is a one-off action, does not change current tool
  toolClear.addEventListener('click', () => clearCanvas());
  // Shape selection: update currentTool and highlight dropdown
  shapeSelect.addEventListener('change', () => {
    selectTool(shapeSelect.value);
  });

  // When the user presses down on the shape dropdown, automatically switch to
  // the currently selected shape if not already using a shape tool. This way
  // the dropdown is highlighted and active as soon as you open it. The
  // subsequent 'change' event (triggered when selecting a new shape) will
  // update the tool again.
  shapeSelect.addEventListener('mousedown', () => {
    if (!shapeTools.includes(currentTool)) {
      selectTool(shapeSelect.value);
    }
  });

  // ----- Flag Connections event listeners -----
  // Handle selection of flags in the connections grid
  connectionsGrid.addEventListener('click', onConnectionsCardClick);
  // Shuffle remaining unsolved flags
  connectionsShuffle.addEventListener('click', shuffleConnections);
  // Evaluate the selected flags and submit as a guess
  connectionsSubmit.addEventListener('click', submitConnections);

  // Deselect all currently selected cards
  connectionsDeselect.addEventListener('click', () => {
    deselectConnections();
  });

  // ----- Mode Display Updates -----
  // On initial load, show the display name of the default mode (state.mode).
  // The state object is defined later, but we can wait until DOMContentLoaded to ensure it exists.
  document.addEventListener('DOMContentLoaded', () => {
    if (modeDisplay && typeof state !== 'undefined' && modeNames[state.mode]) {
      modeDisplay.innerHTML = modeNames[state.mode];
    }
  });
  // Whenever the user selects a different mode in the drop‚Äëdown, update the mode display to show
  // the name and icon, even before the game starts. This makes the UI reflect the user's selection.
  modeSelect.addEventListener('change', () => {
    const selected = modeSelect.value;
    if (modeNames[selected] && modeDisplay) {
      modeDisplay.innerHTML = modeNames[selected];
    }
  });

  // Grid toggle removed; no event listener necessary

  function buildCustomOptions(){
    const base=[
      ['UN_EASY','UN - Easy (Top 20% by population)'],
      ['UN_MED','UN - Medium (Next 40%)'],
      ['UN_HARD','UN - Hard (Bottom 40%)'],
      ['NA','North/Central America'],
      ['SA','South America'],
      ['EU','Europe'],
      ['AS','Asia'],
      ['AF','Africa'],
      ['OC','Oceania'],
      ['WORLD','World (All)']
    ];
    const user = state.userPresets.map(p=>[p.id, `‚≠ê ${p.label} (${p.items.length})`]);
    const opts = [...base, ...user];
    customSelect.innerHTML = opts.map(([v,l])=>`<option value="${v}" ${v===state.customMode?'selected':''}>${l}</option>`).join('');
  }
  customSelect.addEventListener('change',()=>{ state.customMode=customSelect.value; updateDatalist(); buildLearn(); });

  // ---- Custom builder ----
  function renderCustomList(filter=''){
    const q = norm(filter);
    const pool = dataAll.filter(e=>{
      if(!q) return true;
      const names=[e.name, ...(e.alt||[])].map(norm);
      return names.some(n=>n.includes(q));
    });
    customList.innerHTML = pool.map(e=>{
      const sel = state._customSel && state._customSel.has(e.cca2);
      return `<div class="item" data-cca2="${e.cca2}" style="cursor:pointer;outline:${sel?'2px solid var(--accent)':'none'}"><img src="${e.flag}" alt="${e.name}"><small>${e.name}</small></div>`;
    }).join('');
  }
  function openCustomBuilder(){
    state._customSel = new Set();
    customName.value='';
    customSearch.value='';
    customCount.textContent='0';
    renderCustomList('');
    customPanel.classList.remove('hidden');
  }
  function closeCustomBuilder(){ customPanel.classList.add('hidden'); }

  createCustomBtn.addEventListener('click', openCustomBuilder);
  closeCustom.addEventListener('click', closeCustomBuilder);
  customSearch.addEventListener('input', ()=>renderCustomList(customSearch.value));
  customList.addEventListener('click', (e)=>{
    const card = e.target.closest('.item'); if(!card) return;
    const id = card.getAttribute('data-cca2');
    if(state._customSel.has(id)) state._customSel.delete(id); else state._customSel.add(id);
    customCount.textContent = String(state._customSel.size);
    if(state._customSel.has(id)) card.style.outline='2px solid var(--accent)'; else card.style.outline='none';
  });
  saveCustomBtn.addEventListener('click', ()=>{
    const name = customName.value.trim();
    if(!name || !state._customSel || state._customSel.size===0){ alert('Name and at least one flag required.'); return; }
    const slug = 'USER:'+name.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
    const existing = state.userPresets.find(x=>x.id===slug);
    const items = [...state._customSel];
    if(existing){ existing.label=name; existing.items=items; }
    else { state.userPresets.push({id:slug,label:name,items}); }
    savePresets();
    state.customMode = slug;
    buildCustomOptions();
    customSelect.value = slug;
    updateDatalist();
    buildLearn();
    closeCustomBuilder();
  });

  // Build initial UI
  buildCustomOptions();
  updateDatalist();
  buildLearn();

  // Enable draggable pop-up panels. Panels with a `.panel-header` inside
  // their `.pop` container can be dragged around the viewport. When the
  // user presses down on a panel header, we record the offset and then
  // update the panel's position as the pointer moves. The default
  // centering transform is removed on drag start so that left/top take
  // precedence.
  (() => {
    let dragPanel = null;
    let offsetX = 0;
    let offsetY = 0;
    document.addEventListener('pointerdown', (e) => {
      const header = e.target.closest('.panel-header');
      if (!header) return;
      const panel = header.closest('.pop');
      if (!panel) return;
      dragPanel = panel;
      const rect = dragPanel.getBoundingClientRect();
      // Set explicit left/top based on current position before removing transform
      dragPanel.style.left = rect.left + 'px';
      dragPanel.style.top = rect.top + 'px';
      // Remove horizontal centering so the panel moves according to left/top
      dragPanel.style.transform = 'none';
      // Bring to front
      dragPanel.style.zIndex = '999';
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      e.preventDefault();
    });
    document.addEventListener('pointermove', (e) => {
      if (!dragPanel) return;
      const x = e.clientX - offsetX;
      const y = e.clientY - offsetY;
      dragPanel.style.left = x + 'px';
      dragPanel.style.top = y + 'px';
    });
    document.addEventListener('pointerup', () => {
      dragPanel = null;
    });
    document.addEventListener('pointercancel', () => {
      dragPanel = null;
    });
  })();

  // Smoke tests
  try {
    const pool = dataUN;
    const fr = pool.find(x=>x.name==='France');
    const de = pool.find(x=>x.name==='Germany');
    if (fr && de) {
      console.assert(matches('France', de) === false, 'France should NOT match Germany');
      console.assert(matches('Fra', fr) === true, 'Fra should match France');
    }
    const us = dataAll.find(x=>x.name==='United States');
    if (us) console.assert(matches('Uni', us) === false, 'Uni is ambiguous among United...');
    const sk = dataAll.find(x=>x.name==='South Korea');
    if (sk) console.assert(matches('Republic of Korea', sk) === true, 'Alias should match South Korea');
    console.log('Self-tests passed.');
  } catch(err){ console.warn('Self-tests skipped', err); }
})();
</script>
</body>
</html>
