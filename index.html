<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultimate Flagle</title>
  <!-- External libraries for the Region Snapshot game mode. These scripts provide
       geographic projection and TopoJSON conversion capabilities via D3 and
       TopoJSON Client. Without these the map cannot be rendered. -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
  <style>
    :root{
      --accent:#93c5fd;
      --ok:#34d399;
      --bad:#fb7185;
      --warn:#fbbf24;
      /* Connections grid gap and card radius for consistent spacing. Default values emulate the
         comfortable spacing of our inspiration design. Users can adjust these via the UI panel. */
      --conn-gap:8px;
      --card-radius:6px;
      /* Control the speed of solved connections animations (seconds) */
      --conn-anim-speed:0.4;
    }
    [data-theme="dark"]{--bg:#000000;--panel:#111111;--text:#e5e7eb;--muted:#9ca3af}
    [data-theme="light"]{--bg:#f3f4f6;--panel:#ffffff;--text:#111827;--muted:#6b7280}

    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
    .wrap{max-width:1200px;margin:0 auto;padding:16px}
    /* Structure the header as a vertical column: first row is the title/mode/buttons, second row is the category tabs */
    header{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    h1{margin:0;font-size:20px}

    .seg{display:flex;gap:4px;background:rgba(255,255,255,.06);padding:4px;border-radius:10px}
    .seg button{border:0;background:transparent;color:#c9d1ff;padding:6px 10px;border-radius:8px;font-weight:700;cursor:pointer}
    .seg button.active{background:var(--accent);color:#111827}

    .panel{
      background:var(--panel);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:12px;
      margin-top:10px;
      /* Slightly deeper shadow for modern look */
      box-shadow:0 2px 8px rgba(0,0,0,0.1);
    }
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .pill{padding:6px 12px;border-radius:999px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.12)}
    .btn{
      border:0;
      border-radius:10px;
      padding:8px 12px;
      font-weight:700;
      background:var(--accent);
      color:#0b1020;
      cursor:pointer;
      /* Smooth hover and active animations */
      transition:background 0.15s ease, box-shadow 0.15s ease, transform 0.05s ease;
    }
    /* Visually indicate when buttons are disabled */
    .btn:disabled{
      opacity:0.5;
      cursor:not-allowed;
    }
    /* Provide hover and active states for buttons */
    .btn:not(:disabled):hover{
      box-shadow:0 2px 6px rgba(0,0,0,0.3);
      filter:brightness(1.1);
    }
    .btn:not(:disabled):active{
      transform:scale(0.97);
    }
    /* Size and spacing for SVG icons inside buttons */
    .btn svg{
      width:1em;
      height:1em;
      margin-right:4px;
      vertical-align:middle;
    }

    /* Active drawing tool styles */
    #drawTools .btn.active{
      background: var(--accent);
      color: var(--panel);
    }
    /* Active state for select-based tools (shapes) */
    select.btn.active{
      background: var(--accent);
      color: var(--panel);
    }

    /* Swatch showing the currently selected brush colour */
    .color-swatch {
      display:inline-block;
      width:20px;
      height:20px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,0.2);
      margin-left:4px;
    }

    /* Style for the mode select dropdown to improve visibility */
    #modeSelect.btn{
      /* Slightly lighter card background for contrast within dark theme */
      background: rgba(255,255,255,0.05);
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.2);
      padding-right: 1.5rem; /* leave space for default arrow */
    }
    /* Provide a consistent appearance for select elements in both themes */
    #modeSelect.btn option{
      color: var(--text);
      background: var(--bg);
    }

    /* Connections game layout */
    .connections-grid{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:var(--conn-gap);
    }
    .connections-grid .flag-card{
      position:relative;
      cursor:pointer;
      border:2px solid transparent;
      border-radius:var(--card-radius);
      overflow:hidden;
      aspect-ratio:3/2;
      background: var(--panel);
    }
    .connections-grid .flag-card img{
      width:100%;
      height:100%;
      display:block;
      /* Use contain so that flags with unusual shapes like Nepal are fully visible */
      object-fit:contain;
      object-position:center;
    }
    .connections-grid .flag-card.selected{
      /* Highlight selected cards with a visible accent outline and slight scale */
      border-color: var(--accent);
      transform: scale(1.03);
      /* Use an outer box shadow so the highlight is visible on dark backgrounds */
      box-shadow: 0 0 0 3px var(--accent), 0 2px 6px rgba(0,0,0,0.4);
    }
    .connections-grid .flag-card.fade-out{
      opacity:0;
      transition: opacity 0.3s ease;
    }

    /* Layout for the Odd One Out game: a simple 2x2 grid of flags */
    .odd-grid{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:var(--conn-gap);
    }
    .odd-grid .flag-card{
      position:relative;
      cursor:pointer;
      border:2px solid transparent;
      border-radius:var(--card-radius);
      overflow:hidden;
      aspect-ratio:3/2;
      background: var(--panel);
    }
    .odd-grid .flag-card img{
      width:100%;
      height:100%;
      display:block;
      object-fit:contain;
      object-position:center;
    }

    /* ------- Region Snapshot styles ------- */
    /* The SVG within the region map container fills its parent.  A background
       colour is provided via the parent (#regionMap) so countries with holes
       still display dark ocean. */
    #regionMap {
      /* Provide a light background so that country shapes stand out clearly
         against the surrounding ocean. Using a light neutral colour improves
         contrast compared to the dark panels used elsewhere. */
      /* Use an off‑white background behind the map.  This soft colour
         provides clear contrast with the country shapes and blends
         nicely with both dark and light themes. */
      /* Use an off‑white background to improve contrast between
         countries and the map background.  This ensures that even
         smaller countries remain visible against the pale ocean. */
      background: #f8fafc;
      position: relative;
      border-radius: 10px;
      overflow: hidden;
    }
    #regionMap svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    /* Base styling for country paths.  Neutral fill and faint stroke to
       distinguish borders.  Classes are added dynamically to indicate
       hover, correct or incorrect states. */
    #regionMap .country {
      /* Use a pastel blue‑grey fill colour for country shapes so
         they stand out clearly against the very light map background.
         This improves visibility of smaller islands and regions. */
      fill: #cbd5e1;
      stroke: rgba(0,0,0,0.25);
      stroke-width: 0.6;
      cursor: pointer;
      transition: fill 0.2s ease;
    }
    #regionMap .country.hover {
      /* When hovering a country, tint it with a semi‑transparent colour.
         The highlight should contrast against the base fill colour so
         players can easily see which country is under the cursor. */
      fill: rgba(147,197,253,0.6);
    }
    #regionMap .country.correct {
      fill: var(--ok);
    }
    #regionMap .country.incorrect {
      fill: var(--bad);
    }
    /* Styling for draggable flag cards in the region mode.  Flags
       resemble those in other modes but support dragging and have a
       grab cursor. */
    .flag-draggable {
      width: 96px;
      height: 72px;
      border: 2px solid transparent;
      border-radius: var(--card-radius);
      overflow: hidden;
      background: var(--panel);
      margin: 4px;
      cursor: grab;
      /* Make the flag container relative so that the name label can be
         absolutely positioned inside it. */
      position: relative;
      transition: transform 0.1s ease;
    }
    .flag-draggable img {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      object-position: center;
      pointer-events: none;
    }
    .flag-draggable.dragging {
      opacity: 0.6;
      cursor: grabbing;
    }

    /* Label displaying the country name below each flag.  Hidden by default;
       toggled by the region names setting.  Positioned at the bottom of
       the flag card with a white background and dark text. */
    .flag-name {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      color: #111;
      font-weight: bold;
      font-size: 12px;
      text-align: center;
      padding: 2px 1px;
      border-top: 1px solid rgba(0,0,0,0.1);
      /* Hide by default; will be shown when regionShowNames is true */
      display: none;
      pointer-events: none;
    }
    .odd-grid .flag-card.selected{
      border-color: var(--accent);
      transform: scale(1.03);
      box-shadow: 0 0 0 3px var(--accent), 0 2px 6px rgba(0,0,0,0.4);
    }
    #connectionsTop{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .connection-group{
      position:relative;
      display:flex;
      gap:4px;
      padding:2px;
      border-radius:4px;
      background: var(--panel);
    }
    .connection-group img{
      /* Keep solved flag images the same size as cards in the grid. The width calculation
         matches the width of a single grid cell (four cards across with gaps) and
         preserves the aspect ratio for unusual flags like Nepal. */
      width: calc((100% - 3*var(--conn-gap)) / 4);
      height: auto;
      aspect-ratio: 3/2;
      object-fit: contain;
      border-radius: var(--card-radius);
    }

    /* Animation for a solved card moving up and fading out */
    .connections-grid .flag-card.anim-solve{
      /* Use CSS variable for animation duration to allow user adjustments */
      transition: transform var(--conn-anim-speed) ease, opacity var(--conn-anim-speed) ease;
      transform: translateY(-60px);
      opacity:0;
    }

    /* Animation for the solved group sliding in from below */
    @keyframes slideIn {
      from { transform: translateY(20px); opacity:0; }
      to   { transform: translateY(0); opacity:1; }
    }
    .connection-group.new{
      /* Use CSS variable for the animation speed */
      animation: slideIn var(--conn-anim-speed) ease forwards;
    }
    .connection-group .theme-overlay{
      position:absolute;
      /* Center overlay horizontally and vertically */
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:#ffffff;
      color:#000000;
      font-size:14px;
      font-weight:bold;
      text-align:center;
      padding:4px 8px;
      border-radius:6px;
      box-shadow:0 1px 4px rgba(0,0,0,0.15);
      pointer-events:none;
    }
    .btn.ghost{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,.2)}
    /* Style select elements that use the .btn classes similarly to buttons */
    select.btn{appearance:none; border:1px solid rgba(255,255,255,.2); border-radius:10px; padding:8px 12px; font-weight:700; cursor:pointer; background:var(--panel); color:var(--text); min-width:90px;}
    select.btn.ghost{background:transparent;}
    .hidden{display:none!important}

    canvas{max-width:100%;height:auto;border-radius:10px;background:#0a0f1f}
    /*
      Prevent the browser from interpreting touch gestures (like scroll,
      pan or pinch‑zoom) on the drawing canvas as default actions. On
      mobile devices, without this rule the browser will intercept
      touchmove events to scroll the page, which means our pointer
      events never fire and the user cannot draw. By explicitly
      disabling all touch actions on the drawing canvas we ensure
      pointer events are delivered to our handlers regardless of the
      gesture. See: https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action
    */
    #flagCanvas {
      touch-action: none;
    }

    input[type=text], select, input[type=color]{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.15);color:var(--text);padding:10px 12px;border-radius:10px}

    .range{display:flex;gap:8px;align-items:center;width:100%}
    .range input[type=range]{flex:1;min-width:160px;appearance:none;background:transparent;height:24px}
    .range input[type=range]::-webkit-slider-runnable-track{height:4px;background:rgba(255,255,255,.25);border-radius:999px}
    .range input[type=range]::-webkit-slider-thumb{appearance:none;margin-top:-6px;width:16px;height:16px;border-radius:50%;background:var(--accent);border:2px solid #000}
    .range input[type=range]::-moz-range-track{height:4px;background:rgba(255,255,255,.25);border-radius:999px}
    .range input[type=range]::-moz-range-thumb{width:16px;height:16px;border:0;border-radius:50%;background:var(--accent)}

    .list{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:10px;margin-top:8px}
    .item{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:10px;padding:8px;display:grid;gap:6px;place-items:center}
    .item img{width:100%;aspect-ratio:4/3;object-fit:cover;border-radius:8px}
    .item small{opacity:.9;text-align:center}

    .topright{display:flex;gap:8px;align-items:center}

    /* Header bar for title, current mode, and right-side buttons */
    .header-bar {
      /* Use a three‑column grid to center the mode display between the title and control buttons. */
      display:grid;
      grid-template-columns:auto 1fr auto;
      align-items:center;
      gap:8px;
    }
    /* Display of current game mode (centered text with icon) */
    #modeDisplay {
      /* Center the mode name within its grid column */
      justify-self:center;
      display:flex;
      align-items:center;
      font-weight:700;
      font-size:16px;
      white-space:nowrap;
      color:var(--text);
    }

    /* Mistake indicator dots */
    .mistake-dot {
      display:inline-block;
      width:12px;
      height:12px;
      border-radius:50%;
      background:var(--accent);
      margin-left:4px;
      margin-right:4px;
    }
    .mistake-dot.used {
      opacity:0.25;
    }

    /* Header inside pop-up panels used as drag handle */
    .panel-header{
      user-select:none;
      cursor:move;
    }

    .pop{
      position:fixed;
      /* Centered by default; draggable panels will override left/top */
      top:80px;
      left:50%;
      transform:translateX(-50%);
      z-index:60;
      width:clamp(280px,92vw,760px);
      max-height:min(78vh,640px);
      overflow:auto;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:12px;
    }
    .muted{color:var(--muted);font-size:12px}

    /* Override styles for region flags in Region Snapshot mode. We use
       more specific selectors (#regionFlags) so these rules take
       precedence over the generic .flag-draggable definitions defined
       earlier. Flags are stacked vertically with the country name
       label below the image. The container height expands to fit
       both elements, preventing overlap. */
    #regionFlags .flag-draggable {
      display: flex;
      flex-direction: column;
      align-items: center;
      /* Provide a small gap between the flag image and the label */
      gap: 2px;
      width: 96px;
      height: auto;
      cursor: grab;
      /* Allow the country name label to extend beyond the image; this
         overrides the default overflow:hidden from the generic
         .flag-draggable rule. */
      overflow: visible;
    }

    #regionFlags .flag-draggable img {
      height: 64px;
    }

    #regionFlags .flag-draggable.dragging {
      opacity: 0.6;
      cursor: grabbing;
    }

    #regionFlags .flag-name {
      width: 100%;
      background: rgba(255,255,255,0.9);
      color: #111;
      font-weight: bold;
      font-size: 12px;
      text-align: center;
      padding: 2px 1px;
      border-top: 1px solid rgba(0,0,0,0.1);
      /* Hide by default; toggled via updateRegionNameDisplay() */
      display: none;
      /* Position static so the label flows below the flag in the flex layout */
      position: static;
    }

    /* When the show-names class is applied to the container, display
       the flag names.  We use !important to override the default
       display:none defined above. */
    #regionFlags.show-names .flag-name {
      display: block !important;
    }
  
    /* Name plates for Connections & Odd One Out (use Region Snapshot plate style) */
    .connections-grid.show-names .flag-name,
    .odd-grid.show-names .flag-name{
      display:block !important;
    }

</style>
</head>
<body>
  <div class="wrap">
    <header>
      <!-- Header bar: title on left, current game mode in the middle, UI/Settings on the right -->
      <div class="header-bar" style="justify-content:space-between; align-items:center; flex-wrap:wrap; gap:8px;">
        <h1>Ultimate Flagle</h1>
        <!-- Display the current game mode with its icon. Default to Classic Mode to ensure visibility before script runs -->
        <span id="modeDisplay" class="header-mode">🎮 Classic Mode</span>
        <div class="topright">
          <button class="btn ghost" id="uiBtn">🎨 UI</button>
          <button class="btn ghost" id="settingsBtn">⚙️ Settings</button>
        </div>
      </div>
      <!-- Category selector remains below the header bar -->
      <div class="seg" id="flagCats">
        <button class="active" data-tab="UN">UN Members</button>
        <button data-tab="Territories">Territories</button>
        <button data-tab="ALL">ALL</button>
        <button data-tab="Custom">Custom</button>
      </div>
    </header>

    <section class="panel">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <span class="pill">Correct: <b id="ok">0</b></span>
          <span class="pill">Streak: <b id="streak">0</b></span>
          <!-- Mistakes pill: shown only in Flag Connections unlimited mistakes mode -->
          <span class="pill hidden" id="mistakesPill">Mistakes: <b id="mistakesCount">0</b></span>

          <!-- Header for draw mode showing which flag to draw -->
          <span id="drawHeader" class="hidden" style="margin-left:8px; font-weight:bold;"></span>
          <select id="customSelect" class="hidden"></select>
          <button class="btn ghost hidden" id="createCustomBtn">Create Custom</button>
        </div>
        <div class="row">
          <button class="btn" id="startBtn">Start</button>
          <!-- Game mode selector with clearer labels and icons for each mode -->
          <select id="modeSelect" class="btn">
            <option value="classic">🎮 Classic Mode</option>
            <option value="memory">🧠 Memory Quiz</option>
            <option value="draw">🖌️ Draw The Flag</option>
            <option value="endless">∞ Endless Hardcore</option>
            <option value="connections">🔗 Flag Connections</option>
        <!-- New Odd One Out game mode option -->
        <option value="odd">🧩 Odd One Out</option>
        <!-- Region Snapshot game mode option -->
        <option value="region">🌍 Region Snapshot</option>
          </select>
          <button class="btn ghost" id="revealBtn" disabled>Reveal</button>
          <button class="btn" id="nextBtn" disabled>Next</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <input id="answer" type="text" placeholder="Your guess…" list="allnames" disabled>
        <datalist id="allnames"></datalist>
        <button class="btn" id="submitBtn" disabled>Submit</button>
      </div>
      <!-- Draw mode controls: hidden by default -->
      <div class="row hidden" id="drawControls" style="margin-top:8px; gap:8px;">
        <label class="row" style="gap:4px; align-items:center;">
          Brush Color
          <input type="color" id="drawColor" value="#ff0000" list="flagColors">
          <!-- Show a swatch of the current brush colour for easy reference -->
          <span id="colorSwatch" class="color-swatch"></span>
        </label>
        <!-- Data list providing suggested colours from the current flag -->
        <datalist id="flagColors"></datalist>
        <label class="row" style="gap:4px; align-items:center;">
          Brush Size
          <input type="range" id="drawSize" min="1" max="30" value="5">
        </label>
        <!-- Primary drawing tools with icons -->
        <div class="row" id="drawTools" style="gap:4px; align-items:center;">
          <button class="btn ghost" id="toolPen" title="Freehand (Pen)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325"/></svg>Pen</button>
          <button class="btn ghost" id="toolEraser" title="Eraser"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M8.086 2.207a2 2 0 0 1 2.828 0l3.879 3.879a2 2 0 0 1 0 2.828l-5.5 5.5A2 2 0 0 1 7.879 15H5.12a2 2 0 0 1-1.414-.586l-2.5-2.5a2 2 0 0 1 0-2.828zm2.121.707a1 1 0 0 0-1.414 0L4.16 7.547l5.293 5.293 4.633-4.633a1 1 0 0 0 0-1.414zM8.746 13.547 3.453 8.254 1.914 9.793a1 1 0 0 0 0 1.414l2.5 2.5a1 1 0 0 0 .707.293H7.88a1 1 0 0 0 .707-.293z"/></svg>Erase</button>
          <button class="btn ghost" id="toolFill" title="Fill (Bucket)"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M6.192 2.78c-.458-.677-.927-1.248-1.35-1.643a3 3 0 0 0-.71-.515c-.217-.104-.56-.205-.882-.02-.367.213-.427.63-.43.896-.003.304.064.664.173 1.044.196.687.556 1.528 1.035 2.402L.752 8.22c-.277.277-.269.656-.218.918.055.283.187.593.36.903.348.627.92 1.361 1.626 2.068.707.707 1.441 1.278 2.068 1.626.31.173.62.305.903.36.262.05.64.059.918-.218l5.615-5.615c.118.257.092.512.05.939-.03.292-.068.665-.073 1.176v.123h.003a1 1 0 0 0 1.993 0H14v-.057a1 1 0 0 0-.004-.117c-.055-1.25-.7-2.738-1.86-3.494a4 4 0 0 0-.211-.434c-.349-.626-.92-1.36-1.627-2.067S8.857 3.052 8.23 2.704c-.31-.172-.62-.304-.903-.36-.262-.05-.64-.058-.918.219zM4.16 1.867c.381.356.844.922 1.311 1.632l-.704.705c-.382-.727-.66-1.402-.813-1.938a3.3 3.3 0 0 1-.131-.673q.137.09.337.274m.394 3.965c.54.852 1.107 1.567 1.607 2.033a.5.5 0 1 0 .682-.732c-.453-.422-1.017-1.136-1.564-2.027l1.088-1.088q.081.181.183.365c.349.627.92 1.361 1.627 2.068.706.707 1.44 1.278 2.068 1.626q.183.103.365.183l-4.861 4.862-.068-.01c-.137-.027-.342-.104-.608-.252-.524-.292-1.186-.8-1.846-1.46s-1.168-1.32-1.46-1.846c-.147-.265-.225-.47-.251-.607l-.01-.068zm2.87-1.935a2.4 2.4 0 0 1-.241-.561c.135.033.324.11.562.241.524.292 1.186.8 1.846 1.46.45.45.83.901 1.118 1.31a3.5 3.5 0 0 0-1.066.091 11 11 0 0 1-.76-.694c-.66-.66-1.167-1.322-1.458-1.847z"/></svg>Fill</button>
          <button class="btn ghost" id="toolPicker" title="Pick Colour"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M13.354.646a1.207 1.207 0 0 0-1.708 0L8.5 3.793l-.646-.647a.5.5 0 1 0-.708.708L8.293 5l-7.147 7.146A.5.5 0 0 0 1 12.5v1.793l-.854.853a.5.5 0 1 0 .708.707L1.707 15H3.5a.5.5 0 0 0 .354-.146L11 7.707l1.146 1.147a.5.5 0 0 0 .708-.708l-.647-.646 3.147-3.146a1.207 1.207 0 0 0 0-1.708zM2 12.707l7-7L10.293 7l-7 7H2z"/></svg>Pick</button>
          <button class="btn ghost" id="toolUndo" title="Undo"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M14.5 1.5a.5.5 0 0 1 .5.5v4.8a2.5 2.5 0 0 1-2.5 2.5H2.707l3.347 3.346a.5.5 0 0 1-.708.708l-4.2-4.2a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 8.3H12.5A1.5 1.5 0 0 0 14 6.8V2a.5.5 0 0 1 .5-.5"/></svg>Undo</button>
          <button class="btn ghost" id="toolClear" title="Clear Canvas"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/><path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/></svg>Clear</button>
        </div>
        <select id="shapeSelect" class="btn ghost" title="Shape">
          <!-- Additional shapes have been added to allow more variety when drawing -->
          <option value="line">Line</option>
          <option value="rect">Rectangle</option>
          <option value="circle">Circle</option>
          <option value="ellipse">Ellipse</option>
          <option value="triangle">Triangle</option>
          <option value="pentagon">Pentagon</option>
          <option value="hexagon">Hexagon</option>
          <option value="star">Star</option>
          <option value="heart">Heart</option>
          <option value="diamond">Diamond</option>
        </select>
        <label class="row" style="gap:4px; align-items:center;"><input type="checkbox" id="shapeFill"> Fill shape</label>
        <!-- Removed grid overlay toggle as it proved distracting and unnecessary -->
      </div>
    </section>

    <section class="panel">
      <canvas id="flagCanvas" width="900" height="560"></canvas>
      <div id="result" style="margin-top:8px"></div>
    </section>

    <!-- Flag Connections game panel (hidden by default) -->
    <section class="panel hidden" id="connectionsPanel">
      <!-- Solved groups will appear here -->
      <div id="connectionsTop" class="row" style="flex-wrap:wrap; gap:8px; margin-bottom:8px;"></div>
      <!-- Grid of flags for connections -->
      <div id="connectionsGrid" class="connections-grid" style="margin-bottom:8px;"></div>
      <!-- Row showing remaining mistakes for connections mode; built dynamically -->
      <div class="row hidden" id="mistakesRow" style="gap:6px; align-items:center; margin-bottom:8px;"></div>
      <!-- Controls for shuffle, submit and status -->
      <div class="row" id="connectionsControls" style="gap:8px; align-items:center;">
        <button class="btn" id="connectionsShuffle">Shuffle</button>
        <!-- New button to clear the current selection in the connections grid -->
        <button class="btn ghost" id="connectionsDeselect" disabled>Deselect All</button>
        <button class="btn" id="connectionsSubmit" disabled>Submit</button>
        <span id="connectionsStatus" class="muted" style="margin-left:auto;"></span>
      </div>
    </section>

  <!-- Odd One Out game panel (hidden by default) -->
  <section class="panel hidden" id="oddPanel">
    <!-- Grid of 4 flags for odd one out -->
    <div id="oddGrid" class="odd-grid" style="margin-bottom:8px;"></div>
    <!-- Mistakes indicator for odd one out: will display remaining mistakes as dots (or hide if unlimited) -->
    <div class="row hidden" id="oddMistakesRow" style="gap:6px; align-items:center; margin-bottom:8px;"></div>
    <!-- Controls for odd one out: submit guess, next button, and status display -->
    <div class="row" id="oddControls" style="gap:8px; align-items:center;">
      <button class="btn" id="oddSubmit" disabled>Submit</button>
      <button class="btn hidden" id="oddNext">Next</button>
      <span id="oddStatus" class="muted" style="margin-left:auto;"></span>
    </div>
    <!-- Instructions for odd one out will be injected here -->
    <div id="oddInstructions" class="muted" style="margin-top:8px;"></div>
  </section>

      <!-- Region Snapshot game panel (hidden by default).  This panel displays
           a zoomed in map of a random region along with a row of draggable
           flags for that region.  Players drag each flag onto its correct
           country. -->
      <section class="panel hidden" id="regionPanel">
        <!-- SVG container for the map.  The map is dynamically generated
             using D3 based on a randomly chosen region.  The SVG will be
             sized to fit this container. -->
        <div id="regionMap" style="width:100%; height:420px; position:relative; border-radius:10px; overflow:hidden;"></div>
        <!-- Container for the draggable flags.  Each flag is represented
             by a small card that can be dragged onto the map. -->
        <div id="regionFlags" class="row" style="margin-top:8px; flex-wrap:wrap; justify-content:center;"></div>
        <!-- Controls and status area for the region game.  The reset button
             allows players to play another random region once the current
             one is complete. -->
        <div class="row" style="margin-top:8px; align-items:center; gap:8px;">
          <button class="btn hidden" id="regionResetBtn">New Region</button>
          <span id="regionStatus" class="muted"></span>
        </div>
      </section>

    <section class="panel" id="learnPanel">
      <details open>
        <summary><b>Browse / Learn</b> — click to see what’s in the current pool</summary>
        <div class="list" id="learnList"></div>
      </details>
    </section>

    <!-- Unified instructions panel shown below the active game. This will display
         how to play information for the current mode. It is updated each
         time a mode starts. -->
    <div id="gameInstructions" class="muted" style="margin-top:12px;"></div>
  </div>

  <!-- UI panel -->
  <div class="panel pop hidden" id="uiPanel">
    <!-- Draggable header for the UI panel -->
    <div class="row panel-header" style="justify-content:space-between; cursor:move;">
      <b>UI Settings</b>
      <button class="btn ghost" id="closeUi" title="Close">✖</button>
    </div>
    <div class="row" style="margin-top:8px; gap:12px; align-items:center; flex-wrap:wrap;">
      <label>Theme</label>
      <select id="themeSelect">
        <option value="dark">Dark (black)</option>
        <option value="light">Light (grey/white)</option>
      </select>
      <label>Accent</label>
      <input type="color" id="accentPicker" value="#93c5fd">
    </div>
    <!-- Additional UI options: grid gap and card corner radius for connections game -->
    <div class="range" style="margin-top:8px">
      <label>Grid Gap</label>
      <input id="gapRange" type="range" min="2" max="12" step="1" value="4"><span id="gapVal">4px</span>
    </div>
    <div class="range">
      <label>Card Radius</label>
      <input id="radiusRange" type="range" min="0" max="20" step="1" value="4"><span id="radiusVal">4px</span>
    </div>
    <!-- Animation speed for solved connections -->
    <div class="range">
      <label>Anim Speed</label>
      <input id="speedRange" type="range" min="0.1" max="2" step="0.1" value="0.4"><span id="speedVal">0.4s</span>
    </div>
      <!-- Toggle for showing country names under flags in Region Snapshot -->
      <div style="margin-top:8px; display:flex; align-items:center; gap:6px;">
        <span title="Show country names under flags">🏷️</span>
        <input type="checkbox" id="regionNameToggle">
      <!-- Show names under flags in Connections & Odd -->
      <div style="margin-top:8px; display:flex; align-items:center; gap:6px;">
        <span title="Show country names under flags">🏷️</span>
        <input type="checkbox" id="connOddNameToggle"> Show country names (Connections &amp; Odd One Out)
      </div>
 Show country names (Region Snapshot)
      </div>
  </div>

  <!-- Custom preset builder -->
  <div class="panel pop hidden" id="customPanel">
    <div class="row" style="justify-content:space-between"><b>Create Custom Preset</b><button class="btn ghost" id="closeCustom">Close</button></div>
    <div class="row" style="margin-top:8px;gap:12px">
      <input id="customSearch" type="text" placeholder="Search countries/territories…" style="flex:1;min-width:200px">
      <span class="pill">Selected: <b id="customCount">0</b></span>
    </div>
    <div class="list" id="customList" style="margin-top:10px"></div>
    <div class="row" style="margin-top:12px;justify-content:space-between">
      <input id="customName" type="text" placeholder="Preset name (e.g., My Speedrun)">
      <button class="btn" id="saveCustomBtn">Save Preset</button>
    </div>
    <div class="muted" style="margin-top:6px">Tip: click tiles to select/deselect. Your presets are saved to this browser.</div>
  </div>

  <!-- Settings panel (effects + timer) -->
  <div class="panel pop hidden" id="settingsPanel">
    <!-- Draggable header for the settings panel -->
    <div class="row panel-header" style="justify-content:space-between; cursor:move;">
      <b>Flag Effects</b>
      <button class="btn ghost" id="closeSettings" title="Close">✖</button>
    </div>

    <div class="range" style="margin-top:8px">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Blur">💧</span>
        <input type="checkbox" id="blurToggle"> Blur
      </label>
      <input id="blurRange" type="range" min="0" max="20" step="0.5" value="0"><span id="blurVal">0px</span>
    </div>

    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Pixelate">🔲</span>
        <input type="checkbox" id="pixelToggle"> Pixelate
      </label>
      <input id="pixelRange" type="range" min="1" max="60" step="1" value="1"><span id="pixelVal">1</span>
    </div>

    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Random Zoom-in">🔍</span>
        <input type="checkbox" id="zoomToggle"> Random Zoom-in
      </label>
      <input id="zoomRange" type="range" min="1" max="6" step="0.1" value="2"><span id="zoomVal">2.0×</span>
    </div>

    <div class="row" style="align-items:center; gap:4px;">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="6‑Piece Reveal">🧩</span>
        <input type="checkbox" id="sixToggle"> 6‑Piece Reveal (on wrong guesses)
      </label>
    </div>
    <div class="row" style="align-items:center; gap:4px;">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Random Colours">🎨</span>
        <input type="checkbox" id="randColorToggle"> Random Colours (per flag)
      </label>
    </div>

    <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,.15)">

    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Grayscale">⚫</span> Grayscale
      </label>
      <input id="gsRange" type="range" min="0" max="1" step="0.05" value="0"><span id="gsVal">0</span>
    </div>
    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Invert">🔁</span> Invert
      </label>
      <input id="invRange" type="range" min="0" max="1" step="0.05" value="0"><span id="invVal">0</span>
    </div>
    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Hue">🌈</span> Hue
      </label>
      <input id="hueRange" type="range" min="0" max="360" step="1" value="0"><span id="hueVal">0°</span>
    </div>
    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Saturation">🔆</span> Saturation
      </label>
      <input id="satRange" type="range" min="0" max="3" step="0.05" value="1"><span id="satVal">1.00×</span>
    </div>
    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Contrast">🌓</span> Contrast
      </label>
      <input id="conRange" type="range" min="0" max="3" step="0.05" value="1"><span id="conVal">1.00×</span>
    </div>

    <hr style="width:100%;border:none;border-top:1px solid rgba(255,255,255,.15)">

    <div class="range">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Timer">⏲️</span> Timer (show flag): <span id="timerVal">∞</span>
      </label>
      <input id="timerRange" type="range" min="0.01" max="5" step="0.01" value="5">
      <label class="row" style="align-items:center; gap:4px;"><input type="checkbox" id="timerInfinite" checked> ∞</label>
    </div>

    <!-- Option to disable mistake limit specifically for Flag Connections -->
    <div class="row" style="align-items:center; gap:4px; margin-top:8px;">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Unlimited mistakes">♾️</span>
        <input type="checkbox" id="unlimitedMistakesToggle"> Unlimited mistakes (Flag Connections)
      </label>
    </div>

    <!-- Option to disable mistake limit specifically for Odd One Out -->
    <div class="row" style="align-items:center; gap:4px; margin-top:8px;">
      <label class="row" style="align-items:center; gap:4px;">
        <span title="Unlimited mistakes">♾️</span>
        <input type="checkbox" id="unlimitedOddMistakesToggle"> Unlimited mistakes (Odd One Out)
      </label>
    </div>

    <div class="muted" id="applyNote">Changes apply to the <b>next</b> flag.</div>
    <!-- Preview canvas showing USA flag with current effect settings -->
    <div id="previewContainer" style="text-align:center;margin-top:12px;">
      <canvas id="effectsPreview" width="200" height="120" style="border:1px solid rgba(255,255,255,0.2); border-radius:8px;"></canvas>
      <div class="muted" style="margin-top:4px;">Preview (USA)</div>
    </div>
  </div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const $$ = s => [...document.querySelectorAll(s)];
  const startBtn = $('#startBtn');
  // Game mode selector
  const modeSelect = $('#modeSelect');
  // Current mode display in header
  const modeDisplay = $('#modeDisplay');
  // Mapping of internal mode names to display names with icons
  const modeNames = {
    classic: '🎮 Classic Mode',
    memory: '🧠 Memory Quiz',
    draw: '🖌️ Draw The Flag',
    endless: '∞ Endless Hardcore',
    connections: '🔗 Flag Connections'
    , odd: '🧩 Odd One Out'
    , region: '🌍 Region Snapshot'
  };
  const revealBtn = $('#revealBtn');
  const nextBtn = $('#nextBtn');
  const submitBtn = $('#submitBtn');
  const answer = $('#answer');
  const resultEl = $('#result');
  const canvas = $('#flagCanvas');
  const ctx = canvas.getContext('2d');
  const okEl = $('#ok');
  const streakEl = $('#streak');
  const mistakesPill = $('#mistakesPill');
  const mistakesCount = $('#mistakesCount');
  const mistakesRow = $('#mistakesRow');
  const connectionsDeselect = $('#connectionsDeselect');
  const learnList = $('#learnList');
  // Panel showing the browse/learn list (hidden in endless mode)
  const learnPanel = $('#learnPanel');
  const customSelect = $('#customSelect');
  const createCustomBtn = $('#createCustomBtn');
  const customPanel = $('#customPanel');
  const closeCustom = $('#closeCustom');
  const customSearch = $('#customSearch');
  const customList = $('#customList');
  const customCount = $('#customCount');
  const customName = $('#customName');
  const saveCustomBtn = $('#saveCustomBtn');

  // Additional elements for draw-from-memory mode
  const answerRow = answer.closest('.row');
  const drawControls = $('#drawControls');
  const drawColor = $('#drawColor');
  const drawSize = $('#drawSize');
  const drawHeader = $('#drawHeader');
  // Display swatch showing current colour
  const colorSwatch = $('#colorSwatch');
  // Drawing tool buttons and controls
  const toolPen = $('#toolPen');
  const toolEraser = $('#toolEraser');
  const toolFill = $('#toolFill');
  const toolPicker = $('#toolPicker');
  const toolUndo = $('#toolUndo');
  const toolClear = $('#toolClear');
  // Shape selection and fill toggle
  const shapeSelect = $('#shapeSelect');
  const shapeFill = $('#shapeFill');
  // Grid toggle removed; no longer used
  const gridToggle = null;

  // Elements for Flag Connections mode
  const connectionsPanel = $('#connectionsPanel');
  const connectionsTop = $('#connectionsTop');
  const connectionsGrid = $('#connectionsGrid');
  const connectionsShuffle = $('#connectionsShuffle');
  const connectionsSubmit = $('#connectionsSubmit');
  const connectionsStatus = $('#connectionsStatus');

  // Elements for Odd One Out mode
  const oddPanel = $('#oddPanel');
  const oddGrid = $('#oddGrid');
  const oddSubmit = $('#oddSubmit');
  const oddStatus = $('#oddStatus');
  const oddMistakesRow = $('#oddMistakesRow');
  const oddNext = $('#oddNext');
  const oddInstructionsEl = $('#oddInstructions');
  const unlimitedOddMistakesToggle = $('#unlimitedOddMistakesToggle');
  const gameInstructions = $('#gameInstructions');

  // Elements for the Region Snapshot mode
  const regionPanel = $('#regionPanel');
  const regionMapEl = $('#regionMap');
  const regionFlags = $('#regionFlags');
  const regionResetBtn = $('#regionResetBtn');
const regionNameToggle = $('#regionNameToggle');
  const regionStatus = $('#regionStatus');

  // Data for Region Snapshot mode
  let worldData = null;            // GeoJSON features for all countries
  let regionFeatures = [];         // Features in the current region
  let regionFlagsData = [];        // List of flags for the current region
  let regionProjection = null;     // Current map projection used for converting centroids
  let regionPath = null;           // Current geoPath generator with projection
  let regionDragging = null;       // Currently dragged flag element
  // Track the current zoom transform applied to the region map.  The zoom
  // transform is updated on each zoom event and used when snapping flags
  // so that they align with the transformed map view.  Initialized to
  // the identity transform.  See handleRegionDrop for usage.
  let regionZoomTransform = d3.zoomIdentity;

  // Keep track of flags that have been snapped onto the map in the
  // Region Snapshot mode.  Each entry stores the element and the
  // corresponding GeoJSON feature.  When the map is zoomed or
  // panned, all snapped flags must be repositioned and resized to
  // remain anchored to their respective countries.  The baseWidth
  // and baseHeight define the default flag size at zoom k=1.
  let snappedFlags = [];

  /**
   * Update the positions and sizes of all snapped flags according to the
   * current zoom transform.  Each flag's centroid is computed via
   * regionPath.centroid(feature) in map coordinates.  These are then
   * converted to screen coordinates using regionZoomTransform.applyX/Y.
   * The flag size is scaled inversely by the zoom scale so that
   * flags appear smaller when zooming in and larger when zooming out.
   */
  function updateSnappedFlags() {
    if (!regionPath || !regionZoomTransform) return;
    const k = regionZoomTransform.k || 1;
    const baseW = 40;
    const baseH = 28;
    snappedFlags.forEach(item => {
      const feature = item.feature;
      const el = item.el;
      // Compute centroid in map coordinates
      let [cx, cy] = regionPath.centroid(feature);
      // Transform to screen coordinates using the current zoom transform
      if (regionZoomTransform && typeof regionZoomTransform.applyX === 'function') {
        cx = regionZoomTransform.applyX(cx);
        cy = regionZoomTransform.applyY(cy);
      }
      // Compute size inversely proportional to zoom scale
      const w = baseW / k;
      const h = baseH / k;
      el.style.position = 'absolute';
      el.style.zIndex = 50;
      el.style.width = w + 'px';
      el.style.height = h + 'px';
      el.style.left = `${cx - w / 2}px`;
      el.style.top = `${cy - h / 2}px`;
    });
  }

  // Current drawing tool ('pen','eraser','fill','picker','line','rect','circle','ellipse','triangle')
  let currentTool = 'pen';
  // Keep track of previously selected tool (used to revert after using the colour picker)
  let prevTool = 'pen';

  // List of all shape tools. When one of these is active, the shape dropdown
  // should be highlighted instead of the individual tool buttons.
  // Include all supported shape tools.  When any of these shapes is
  // selected the shape dropdown will be highlighted instead of the
  // freehand tool buttons.  The order here should match the
  // <option> entries in the shapeSelect dropdown.
  const shapeTools = ['line','rect','circle','ellipse','triangle','pentagon','hexagon','star','heart','diamond'];
  // History stack for undo functionality. Each entry stores ImageData.
  const history = [];
  // Image data snapshot for shape preview drawing
  let shapePreviewImgData = null;
  // Track shape drawing start coordinates
  let startX = 0;
  let startY = 0;
  let drawingShape = false;

  /**
   * Update the canvas background grid based on the grid toggle. Uses a
   * repeating linear gradient to draw gridlines every 20 pixels. If the grid
   * is disabled, clears any custom background image.
   */
  function updateGrid() {
    if (gridToggle && gridToggle.checked) {
      canvas.style.backgroundImage =
        'linear-gradient(to right, rgba(0,0,0,0.15) 1px, transparent 1px), ' +
        'linear-gradient(to bottom, rgba(0,0,0,0.15) 1px, transparent 1px)';
      canvas.style.backgroundSize = '20px 20px';
    } else {
      canvas.style.backgroundImage = '';
    }
  }

  /**
   * Save the current canvas state into the history stack for undo.
   */
  function saveState() {
    try {
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      history.push(imgData);
      // Limit history length to avoid memory bloat
      if (history.length > 50) history.shift();
    } catch(err) {
      console.warn('Could not save state for undo', err);
    }
  }

  /**
   * Undo the last drawing operation by restoring the previous canvas state.
   */
  function undo() {
    if (history.length === 0) return;
    const prev = history.pop();
    ctx.putImageData(prev, 0, 0);
  }

  /**
   * Clear the drawing canvas and reset it to a white background. Saves the state
   * to the history stack so the action can be undone.
   */
  function clearCanvas() {
    // Save current state before clearing
    saveState();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  /**
   * Convert a hex colour string (e.g. '#ff0000') to an array [r,g,b].
   * @param {string} hex
   * @returns {number[]} RGB array
   */
  function hexToRgb(hex) {
    hex = hex.replace('#', '');
    if (hex.length === 3) {
      hex = hex.split('').map(c => c + c).join('');
    }
    const intVal = parseInt(hex, 16);
    return [(intVal >> 16) & 255, (intVal >> 8) & 255, intVal & 255];
  }

  /**
   * Flood fill starting at (x, y) with the current brush colour.
   * This fills contiguous regions of the same starting colour.
   * @param {number} x
   * @param {number} y
   */
  function floodFill(x, y) {
    // Clamp coordinates
    x = Math.floor(x);
    y = Math.floor(y);
    // Acquire image data once
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const idx = (y * width + x) * 4;
    const targetR = data[idx];
    const targetG = data[idx + 1];
    const targetB = data[idx + 2];
    const targetA = data[idx + 3];
    // Determine replacement colour
    const [repR, repG, repB] = hexToRgb(drawColor.value);
    // If target and replacement colours are the same, nothing to fill
    if (targetR === repR && targetG === repG && targetB === repB && targetA === 255) {
      return;
    }
    const queue = [];
    queue.push([x, y]);
    // Track visited pixels to avoid infinite loops
    const visited = new Uint8Array(width * height);
    while (queue.length > 0) {
      const [cx, cy] = queue.pop();
      if (cx < 0 || cy < 0 || cx >= width || cy >= height) continue;
      const index = (cy * width + cx);
      if (visited[index]) continue;
      const di = index * 4;
      const cr = data[di];
      const cg = data[di + 1];
      const cb = data[di + 2];
      const ca = data[di + 3];
      if (cr === targetR && cg === targetG && cb === targetB && ca === targetA) {
        // Replace pixel colour
        data[di] = repR;
        data[di + 1] = repG;
        data[di + 2] = repB;
        data[di + 3] = 255;
        visited[index] = 1;
        // Enqueue neighbouring pixels
        queue.push([cx + 1, cy]);
        queue.push([cx - 1, cy]);
        queue.push([cx, cy + 1]);
        queue.push([cx, cy - 1]);
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }

  // UI panels
  const uiBtn=$('#uiBtn'), uiPanel=$('#uiPanel'), closeUi=$('#closeUi');
  const settingsBtn=$('#settingsBtn'), settingsPanel=$('#settingsPanel'), closeSettings=$('#closeSettings');
  const themeSelect=$('#themeSelect');
  const accentPicker=$('#accentPicker');

  // Effect controls
  const blurToggle=$('#blurToggle');
  const blurRange=$('#blurRange');
  const blurVal=$('#blurVal');
  const pixelToggle=$('#pixelToggle');
  const pixelRange=$('#pixelRange');
  const pixelVal=$('#pixelVal');
  const zoomToggle=$('#zoomToggle');
  const zoomRange=$('#zoomRange');
  const zoomVal=$('#zoomVal');
  const sixToggle=$('#sixToggle');
  const randColorToggle=$('#randColorToggle');
  const gsRange=$('#gsRange');
  const gsVal=$('#gsVal');
  const invRange=$('#invRange');
  const invVal=$('#invVal');
  const hueRange=$('#hueRange');
  const hueVal=$('#hueVal');
  const satRange=$('#satRange');
  const satVal=$('#satVal');
  const conRange=$('#conRange');
  const conVal=$('#conVal');

  // Timer controls
  const timerRange=$('#timerRange');
  const timerInfinite=$('#timerInfinite');
  const timerVal=$('#timerVal');

  // Unlimited mistakes toggle for flag connections
  const unlimitedMistakesToggle = $('#unlimitedMistakesToggle');

  // Range controls for adjusting the spacing and corner radius of the
  // connections grid. When these inputs change, update the corresponding
  // CSS variables and update their labels.
  const gapRange = $('#gapRange');
  const gapVal = $('#gapVal');
  const radiusRange = $('#radiusRange');
  const radiusVal = $('#radiusVal');
  const speedRange = $('#speedRange');
  const speedVal = $('#speedVal');
  if (gapRange && gapVal) {
    const updateGap = () => {
      const val = gapRange.value;
      document.documentElement.style.setProperty('--conn-gap', val + 'px');
      gapVal.textContent = val + 'px';
    };
    gapRange.addEventListener('input', updateGap);
    updateGap();
  }
  if (radiusRange && radiusVal) {
    const updateRadius = () => {
      const val = radiusRange.value;
      document.documentElement.style.setProperty('--card-radius', val + 'px');
      radiusVal.textContent = val + 'px';
    };
    radiusRange.addEventListener('input', updateRadius);
    updateRadius();
  }

  // Update animation speed for solved connections
  if (speedRange && speedVal) {
    const updateSpeed = () => {
      const val = parseFloat(speedRange.value);
      document.documentElement.style.setProperty('--conn-anim-speed', val + 's');
      speedVal.textContent = val.toFixed(1) + 's';
    };
    speedRange.addEventListener('input', updateSpeed);
    updateSpeed();
  }

  // Update state.unlimitedMistakes when the toggle changes. Also update the mistakes display if currently in connections mode.
  if (unlimitedMistakesToggle) {
    const updateUnlimited = () => {
      state.unlimitedMistakes = unlimitedMistakesToggle.checked;
      // If already in connections mode, update the mistakes remaining display accordingly
      updateMistakesDisplay();
    };
    unlimitedMistakesToggle.addEventListener('change', updateUnlimited);
    // Do not call updateUnlimited() here because `state` may not yet be defined.  We'll
    // initialize the unlimited mistakes state after `state` is declared later in the file.
    // updateUnlimited();
  }

  // --- Preview of flag effects ---
  const previewCanvas = $('#effectsPreview');
  const previewCtx = previewCanvas ? previewCanvas.getContext('2d') : null;
  // Load the USA flag for the preview. Cross-origin is allowed for this domain.
  let previewImg = null;
  if (previewCanvas) {
    previewImg = new Image();
    previewImg.crossOrigin = 'anonymous';
    previewImg.src = 'https://flagcdn.com/w320/us.png';
    previewImg.onload = () => {
      updatePreview();
    };
  }

  /**
   * Draw the USA flag into the preview canvas with the currently pending effects.
   * Pixelation is approximated by downscaling and upscaling. Other filter
   * effects are applied using the canvas context filter property.
   */
  function updatePreview() {
    if (!previewCanvas || !previewImg || !previewCtx) return;
    const w = previewCanvas.width;
    const h = previewCanvas.height;
    previewCtx.save();
    // Clear the canvas
    previewCtx.clearRect(0, 0, w, h);
    const p = state.effectsPending;
    // Build filter string
    const parts = [];
    if (p.gs > 0) parts.push(`grayscale(${p.gs})`);
    if (p.inv > 0) parts.push(`invert(${p.inv})`);
    const hueTotal = ((p.hue || 0)) % 360;
    if (hueTotal !== 0) parts.push(`hue-rotate(${hueTotal}deg)`);
    if (p.sat !== 1) parts.push(`saturate(${p.sat})`);
    if (p.con !== 1) parts.push(`contrast(${p.con})`);
    if (p.blurOn && p.blurPx > 0) parts.push(`blur(${p.blurPx}px)`);
    previewCtx.filter = parts.join(' ');
    if (p.pixelOn && p.pixel > 1) {
      const scale = 1 / p.pixel;
      const offW = Math.max(1, Math.round(w * scale));
      const offH = Math.max(1, Math.round(h * scale));
      const off = document.createElement('canvas');
      off.width = offW;
      off.height = offH;
      const offCtx = off.getContext('2d');
      offCtx.imageSmoothingEnabled = false;
      offCtx.drawImage(previewImg, 0, 0, offW, offH);
      previewCtx.imageSmoothingEnabled = false;
      previewCtx.drawImage(off, 0, 0, offW, offH, 0, 0, w, h);
    } else {
      previewCtx.imageSmoothingEnabled = true;
      previewCtx.drawImage(previewImg, 0, 0, w, h);
    }
    previewCtx.restore();
  }

  /**
   * Update the mistakes display for Flag Connections mode.
   * If unlimited mistakes are enabled, hide the mistakes row and show the mistakes pill next to the streak counter.
   * Otherwise, show up to four mistake dots indicating remaining mistakes. Used mistakes are faded.
   */
  function updateMistakesDisplay() {
    // Only meaningful in connections mode
    if (state.mode !== 'connections') {
      // Hide mistakes UI outside of connections mode
      if (mistakesRow) mistakesRow.classList.add('hidden');
      if (mistakesPill) mistakesPill.classList.add('hidden');
      return;
    }
    // Unlimited mistakes case
    if (state.unlimitedMistakes) {
      // Hide the row of circles and show the pill
      if (mistakesRow) mistakesRow.classList.add('hidden');
      if (mistakesPill) {
        mistakesPill.classList.remove('hidden');
        if (mistakesCount) mistakesCount.textContent = state.connectionsMistakesUsed;
      }
    } else {
      // Limited mistakes: show row with up to maxMistakes dots; hide pill
      if (mistakesPill) mistakesPill.classList.add('hidden');
      if (mistakesRow) {
        mistakesRow.classList.remove('hidden');
        const maxMistakes = state.maxMistakes || 4;
        const remaining = Math.max(0, maxMistakes - state.connectionsMistakesUsed);
        let html = '';
        html += '<span class="muted">Mistakes Remaining:</span>';
        for (let i = 0; i < maxMistakes; i++) {
          const used = i >= remaining;
          html += `<span class="mistake-dot${used ? ' used' : ''}"></span>`;
        }
        mistakesRow.innerHTML = html;
      }
    }
  }

  /**
   * Update the mistakes display for Odd One Out mode. When unlimited
   * mistakes are enabled, the row of circles is hidden and the
   * scoreboard pill shows how many mistakes have been used. When
   * limited mistakes are in effect, show a row of dots indicating
   * remaining mistakes. Outside of odd mode, hide both displays.
   */
  function updateOddMistakesDisplay() {
    // Show mistakes only during odd mode
    if (state.mode !== 'odd') {
      if (oddMistakesRow) oddMistakesRow.classList.add('hidden');
      if (mistakesPill) mistakesPill.classList.add('hidden');
      return;
    }
    if (state.oddUnlimitedMistakes) {
      // Hide row and show pill with count
      if (oddMistakesRow) oddMistakesRow.classList.add('hidden');
      if (mistakesPill) {
        mistakesPill.classList.remove('hidden');
        if (mistakesCount) mistakesCount.textContent = state.oddMistakesUsed;
      }
    } else {
      // Limited mistakes: show row with dots; hide pill
      if (mistakesPill) mistakesPill.classList.add('hidden');
      if (oddMistakesRow) {
        oddMistakesRow.classList.remove('hidden');
        const maxM = state.oddMaxMistakes || 2;
        let html = '';
        html += '<span class="muted">Mistakes Remaining:</span>';
        for (let i = 0; i < maxM; i++) {
          const used = i < state.oddMistakesUsed;
          html += `<span class="mistake-dot${used ? ' used' : ''}"></span>`;
        }
        oddMistakesRow.innerHTML = html;
      }
    }
  }

  /**
   * Update the display of country names under region flags.  This reads
   * the regionNameToggle checkbox and shows or hides the .flag-name
   * element for each draggable flag in the region panel.  Names on
   * snapped flags inside the map are also updated.
   */
  function updateRegionNameDisplay() {
    if (!regionNameToggle) return;
    state.regionShowNames = regionNameToggle.checked;
    const show = state.regionShowNames;
    // Toggle a class on the flags container to control name visibility via CSS.
    // We deliberately avoid applying the class to the map container, because
    // country names should only appear under the draggable flags in the
    // bottom bar, not on the flags that have been snapped onto the map.
    if (show) {
      regionFlags.classList.add('show-names');
    } else {
      regionFlags.classList.remove('show-names');
    }
  }

  // ----------------- Region Snapshot Mode Functions -----------------
  // Define a set of coarse geographic regions with bounding boxes. Each entry
  // contains a descriptive name and the minLon, minLat, maxLon and maxLat
  // values for the region. These boxes are approximations and need not be
  // perfect; they simply select clusters of neighbouring countries for the
  // map to zoom into. The selection is randomised on each round.
  const regionDefinitions = [
    { name: 'West Africa', bbox: [-20, 0, 15, 20] },
    { name: 'Central America', bbox: [-100, 5, -77, 19] },
    { name: 'Scandinavia', bbox: [5, 55, 30, 72] },
    { name: 'Southeast Asia', bbox: [95, -10, 150, 25] },
    { name: 'Southern Africa', bbox: [10, -35, 35, -10] },
    { name: 'Middle East', bbox: [30, 10, 60, 40] },
    { name: 'Balkans', bbox: [18, 36, 30, 48] },
    { name: 'Andes', bbox: [-85, -60, -60, 5] },
    { name: 'Caribbean', bbox: [-90, 10, -60, 25] },
    { name: 'Central Europe', bbox: [5, 45, 20, 55] },
    { name: 'North Africa', bbox: [-20, 20, 40, 40] },
    { name: 'East Asia', bbox: [100, 20, 150, 50] }
  ];

  /**
   * Ensure the world data (country shapes) is loaded.  Fetches the
   * TopoJSON from the jsDelivr CDN and converts it to GeoJSON using
   * the topojson-client library.  This function is idempotent and
   * caches the result in the worldData variable.
   */
  async function ensureWorldData() {
    if (worldData) return;
    try {
      const resp = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
      const topo = await resp.json();
      // The countries are stored in the "countries" object. Convert them
      // to a GeoJSON feature collection.  The id property corresponds to
      // the ISO3166-1 alpha-3 code.
      worldData = topojson.feature(topo, topo.objects.countries).features;
    } catch(err) {
      console.error('Failed to load world atlas', err);
      worldData = [];
    }
  }

  /**
   * Select a random region definition from the list.  Returns a new
   * object so that modifications to the chosen region do not affect
   * the original definitions.
   */
  /**
   * Select a random region on the globe.  We choose a random centre
   * coordinate and construct a bounding box of fixed width/height in
   * degrees.  We then check which world features intersect that box.
   * If at least two countries intersect, we return that random region.
   * Otherwise we try again up to 10 times.  If no random region
   * contains multiple countries, we fall back to one of the predefined
   * regionDefinitions.
   * @returns {Object} an object containing a name and bbox [lonMin,latMin,lonMax,latMax]
   */
  function randomRegion() {
    // Attempt to find a random bounding box containing at least two countries.
    // To make the game feel fresh we vary the window size on each try and
    // increase the number of attempts.  This increases the likelihood
    // of finding an arbitrary patch of the world with multiple
    // neighbouring countries instead of falling back to the same
    // handful of predefined regions.  Bounding boxes can range from
    // roughly 30–50° in longitude and 20–30° in latitude.
    const maxAttempts = 40;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      // Random centre within reasonable latitudes to avoid the poles
      const lonCenter = -170 + Math.random() * 340; // [-170, +170]
      const latCenter = -50 + Math.random() * 100;  // [-50, +50]
      // Choose a random window size for this attempt.  Allow
      // slightly larger widths and heights to capture more countries.
      // Choose a random window size for this attempt.  Allow wider
      // and taller windows to increase the chance of capturing multiple
      // neighbouring countries.  Width ranges from 40–60° and height
      // from 25–40°.
      // Aim for a larger window to capture multiple countries.  Choose
      // width between 40 and 70 degrees and height between 25 and
      // 50 degrees.  Larger windows increase the chance of including
      // several neighbouring countries.
      const width = 40 + Math.random() * 30;  // 40–70 degrees
      const height = 25 + Math.random() * 25; // 25–50 degrees
      let lonMin = lonCenter - width / 2;
      let lonMax = lonCenter + width / 2;
      let latMin = latCenter - height / 2;
      let latMax = latCenter + height / 2;
      // Clamp latitude to [-90, 90]
      latMin = Math.max(-90, latMin);
      latMax = Math.min(90, latMax);
      // Normalise longitude: handle wrap‑around at ±180.  If the box
      // crosses the international date line, we'll treat it as spanning
      // both ends of the range by adjusting the min/max accordingly.
      if (lonMin < -180) lonMin += 360;
      if (lonMax > 180) lonMax -= 360;
      const bbox = [lonMin, latMin, lonMax, latMax];
      // Determine how many countries intersect this bounding box
      const intersectsCount = worldData.filter(f => featureIntersectsBbox(f, bbox)).length;
      if (intersectsCount >= 2) {
        return { name: 'Random Region', bbox };
      }
    }
    // Fallback: pick a predefined region if no random region is found
    const idx = Math.floor(Math.random() * regionDefinitions.length);
    const reg = regionDefinitions[idx];
    return { name: reg.name, bbox: reg.bbox.slice() };
  }

  /**
   * Determine whether a GeoJSON feature intersects a bounding box.  The
   * feature's bounding box is computed via d3.geoBounds.  The bbox
   * parameter is an array [lonMin, latMin, lonMax, latMax].  This
   * helper correctly handles cases where the bounding box crosses the
   * anti‑meridian (lonMin > lonMax).
   * @param {Object} feature GeoJSON feature with coordinates
   * @param {Array<number>} bbox [lonMin,latMin,lonMax,latMax]
   * @returns {boolean} true if the feature intersects the bbox
   */
  function featureIntersectsBbox(feature, bbox) {
    const bounds = d3.geoBounds(feature);
    const fLonMin = bounds[0][0];
    const fLatMin = bounds[0][1];
    const fLonMax = bounds[1][0];
    const fLatMax = bounds[1][1];
    const regionLonMin = bbox[0];
    const regionLatMin = bbox[1];
    const regionLonMax = bbox[2];
    const regionLatMax = bbox[3];
    // Check latitude overlap first
    const latOverlap = fLatMin <= regionLatMax && fLatMax >= regionLatMin;
    if (!latOverlap) return false;
    // Handle longitude overlap.  If the bbox crosses the dateline,
    // consider wrap‑around: the bbox effectively covers two ranges.
    if (regionLonMin <= regionLonMax) {
      // Normal case: simple range overlap
      return fLonMin <= regionLonMax && fLonMax >= regionLonMin;
    } else {
      // Crossing dateline: region covers [lonMin,180] ∪ [-180,lonMax]
      const overlap1 = fLonMin <= 180 && fLonMax >= regionLonMin;
      const overlap2 = fLonMin <= regionLonMax && fLonMax >= -180;
      return overlap1 || overlap2;
    }
  }

  /**
   * Start the Region Snapshot mode.  Resets the score counters, hides
   * the UI of other modes, shows the region panel, loads the world
   * GeoJSON if needed, selects a random region and prepares the map
   * and flags for the player to drag and drop.
   */
  async function startRegion() {
    // Set state and reset counters
    state.mode = 'region';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = 0;
    streakEl.textContent = 0;
    // Hide panels from other modes
    drawHeader.classList.add('hidden');
    drawControls.classList.add('hidden');
    connectionsPanel.classList.add('hidden');
    oddPanel.classList.add('hidden');
    canvas.classList.add('hidden');
    resultEl.classList.add('hidden');
    resultEl.innerHTML = '';
    answer.classList.add('hidden');
    answer.disabled = true;
    submitBtn.classList.add('hidden');
    submitBtn.disabled = true;
    revealBtn.classList.add('hidden');
    nextBtn.classList.add('hidden');
    revealBtn.disabled = true;
    nextBtn.disabled = true;
    learnPanel.classList.add('hidden');
    // Hide mistakes UI from odd and connections modes
    if (mistakesRow) mistakesRow.classList.add('hidden');
    if (oddMistakesRow) oddMistakesRow.classList.add('hidden');
    if (mistakesPill) mistakesPill.classList.add('hidden');
    // Show the region panel
    regionPanel.classList.remove('hidden');
    // Reset flags and status.  Remove any previously placed flags from
    // the map container by selecting those that are no longer draggable.
    regionStatus.textContent = '';
    regionFlags.innerHTML = '';
    // Remove any flags that were previously placed onto the map.  These
    // flags no longer have the draggable attribute so they can be
    // identified and cleaned up.  We remove all flag elements inside
    // the map container to ensure a clean slate.
    regionMapEl.querySelectorAll('.flag-draggable').forEach(el => el.remove());
    // Clear the list of snapped flags because a new region will be loaded
    snappedFlags = [];
    regionResetBtn.classList.add('hidden');
    // Ensure world data is available
    await ensureWorldData();
    // Choose a random region and precompute the features.  We may need to
    // attempt several times to ensure at least two countries are in view.
    let region = randomRegion();
    let attempts = 10;
    let features = [];
    while (attempts > 0) {
      // Include any country that intersects the region bounding box
      features = worldData.filter(f => featureIntersectsBbox(f, region.bbox));
      if (features.length >= 3) break;
      region = randomRegion();
      attempts--;
    }
    if (features.length < 3) {
      // Fallback to the first few countries if no region has enough countries.
      // Use at least three countries to ensure there is a meaningful region.
      features = worldData.slice(0, 4);
    }
    // Draw the entire world map to provide context
    drawRegionMap(worldData);
    // Save the projection used for the world map so we can compute pixel
    // coordinates of the region bounding box
    const worldProj = regionProjection;
    const width = regionMapEl.clientWidth;
    const height = regionMapEl.clientHeight;
    // Compute the bounding box of the selected region in pixel coordinates
    const [x0, y0] = worldProj([region.bbox[0], region.bbox[3]]); // lon min, lat max
    const [x1, y1] = worldProj([region.bbox[2], region.bbox[1]]); // lon max, lat min
    const regionWidthPx = Math.abs(x1 - x0);
    const regionHeightPx = Math.abs(y1 - y0);
    const k = Math.min(width / regionWidthPx, height / regionHeightPx);
    const cx = (x0 + x1) / 2;
    const cy = (y0 + y1) / 2;
    const transform = `translate(${width / 2},${height / 2}) scale(${k}) translate(${-cx},${-cy})`;
    // Wait briefly before starting the zoom animation so the player can
    // recognise the whole world
    // Show the full world for a brief moment so the player can orient
    await new Promise(res => setTimeout(res, 1000));
    // Animate the zoom into the region using a D3 transition on the <g> group.
    // Use a cubic easing for a smooth in‑out effect.  A longer duration
    // emphasises the cinematic feel.
    const svgSel = d3.select(regionMapEl).select('svg');
    const gSel = svgSel.select('g');
    gSel.transition().duration(1800).ease(d3.easeCubicInOut).attr('transform', transform);
    // After the zoom animation completes, draw the region map and flags
    setTimeout(() => {
      // Store the features globally for later use
      regionFeatures = features;
      drawRegionMap(features);
      buildRegionFlags(features);
    }, 1850);
    // Update the instructions for region snapshot
    if (gameInstructions) {
      gameInstructions.innerHTML = '<b>Region Snapshot:</b> A random part of the world will be zoomed in on. Drag each flag onto the country you think it belongs to. Correct placements turn the country green; incorrect ones blink red and the flag returns to the bottom. Continue until all flags are placed.';
    }
    // Update mode display
    if (modeDisplay && modeNames[state.mode]) {
      modeDisplay.innerHTML = modeNames[state.mode];
    }
  }

  /**
   * Build a new region round.  Chooses a random region, filters the
   * world features to those whose centroids fall within the region
   * bounding box, draws the map and generates draggable flags for the
   * countries in that region.  If fewer than two countries are found,
   * another region is tried (up to 10 attempts).
   */
  function buildRegion() {
    let region = randomRegion();
    let attempts = 10;
    regionFeatures = [];
    while (attempts > 0) {
      // Include countries whose bounding boxes intersect the selected region
      regionFeatures = worldData.filter(f => featureIntersectsBbox(f, region.bbox));
      if (regionFeatures.length >= 3) break;
      region = randomRegion();
      attempts--;
    }
    if (regionFeatures.length < 3) {
      // Fallback: use the first few features if no region matches.  Use
      // four countries to ensure multiple flags are present.
      regionFeatures = worldData.slice(0, 4);
    }
    drawRegionMap(regionFeatures);
    buildRegionFlags(regionFeatures);
  }

  /**
   * Draw the map for the current region.  Computes a projection that fits
   * the selected features into the available SVG area, clears any
   * previous map and then renders the new features.  Each country
   * path is set up to accept drops from draggable flags.
   * @param {Array} features List of GeoJSON features in the region
   */
  function drawRegionMap(features) {
    // Create or select the SVG
    const svg = d3.select(regionMapEl).selectAll('svg').data([null]);
    const svgEnter = svg.enter().append('svg');
    const svgSel = svgEnter.merge(svg);
    const width = regionMapEl.clientWidth;
    const height = regionMapEl.clientHeight;
    svgSel.attr('width', width).attr('height', height);
    // Compute a projection that fits the features
    regionProjection = d3.geoMercator();
    regionPath = d3.geoPath(regionProjection);
    regionProjection.fitSize([width, height], { type: 'FeatureCollection', features });
    // Remove any existing groups and render new ones
    svgSel.selectAll('g').remove();
    const g = svgSel.append('g');
    g.selectAll('path')
      .data(features)
      .enter().append('path')
      .attr('class', 'country')
      .attr('d', regionPath)
      .each(function(d) {
        // Store the feature on the DOM element for later reference
        this.__featureData = d;
      })
      // Allow dropping a flag onto the country.  Prevent the default
      // behaviour to enable drops and call our handler on drop.
      .on('dragover', (event, d) => {
        event.preventDefault();
      })
      .on('drop', function(event, d) {
        event.preventDefault();
        handleRegionDrop(event, d, this);
      })
      // When the pointer enters a country (hovering), apply the hover
      // style to highlight it.  Remove the highlight on exit.
      .on('mouseenter', function() {
        d3.select(this).classed('hover', true);
      })
      .on('mouseleave', function() {
        d3.select(this).classed('hover', false);
      })
      // During dragging we use dragenter/dragleave to highlight the
      // country under the current drag target because mouseenter/mouseleave
      // events do not fire while holding a dragged element.  When a
      // draggable flag enters the path, apply hover; when it leaves,
      // remove the hover class.
      .on('dragenter', function(event) {
        event.preventDefault();
        d3.select(this).classed('hover', true);
      })
      .on('dragleave', function(event) {
        d3.select(this).classed('hover', false);
      });

    // Set up zoom and pan behaviour on the map.  Allow the user to
    // zoom in to inspect small countries and pan within the map
    // container.  Reset any existing zoom handler before applying a
    // new one to avoid multiple bindings.
    svgSel.on('.zoom', null);
    const zoom = d3.zoom()
      // Restrict zoom scale: minimum of 1 (fit size) and maximum of 10x
      .scaleExtent([1, 10])
      // Limit panning to within the SVG's bounding box
      .translateExtent([[0, 0], [width, height]])
      .extent([[0, 0], [width, height]])
      .on('zoom', (event) => {
        // Update the transform on the group and save the zoom transform
        // so it can be used to correctly position flags when snapped
        g.attr('transform', event.transform);
        // Save the current transform and update positions of snapped flags
        regionZoomTransform = event.transform;
        updateSnappedFlags();
      });
    svgSel.call(zoom);
  }

  /**
   * Generate draggable flag elements for each country in the region.  Uses
   * the dataUN list to find the corresponding ISO 2 code and flag image.
   * Flags are appended to the regionFlags container and assigned drag
   * handlers.  If no matching ISO2 code is found, the flag is skipped.
   * @param {Array} features List of GeoJSON features representing countries
   */
  function buildRegionFlags(features) {
    regionFlags.innerHTML = '';
    regionFlagsData = [];
    features.forEach(feature => {
      // Determine the common name for the feature and normalise it
      const rawName = feature.properties && feature.properties.name ? feature.properties.name : '';
      const mappedName = COMMON[rawName] || rawName;
      const normalized = norm(mappedName);
      // Look up the entry in the UN dataset by matching the normalised
      // name or any of its alternate names (including nicknames and
      // acronyms).  This allows us to match cases where the GeoJSON
      // uses shortened names such as "Dominican Rep." or "Congo".
      let entry = null;
      for (const e of dataUN) {
        if (norm(e.name) === normalized) {
          entry = e;
          break;
        }
        if (e.alt && e.alt.some(a => norm(a) === normalized)) {
          entry = e;
          break;
        }
      }
      if (!entry) return;
      const iso2 = entry.cca2;
      const name = entry.name;
      const flagCard = document.createElement('div');
      flagCard.className = 'flag-draggable';
      flagCard.setAttribute('draggable', 'true');
      flagCard.dataset.iso2 = iso2;
      flagCard.dataset.iso3 = feature.id;
      flagCard.dataset.name = name;
      const img = document.createElement('img');
      // Use a smaller size to keep flags compact
      img.src = `https://flagcdn.com/96x72/${iso2.toLowerCase()}.png`;
      img.alt = name + ' flag';
      flagCard.appendChild(img);
      // Add a label showing the country's name.  The label is hidden
      // by default and toggled by the region name setting.
      const label = document.createElement('div');
      label.className = 'flag-name';
      label.textContent = name;
      flagCard.appendChild(label);
      regionFlags.appendChild(flagCard);
      regionFlagsData.push({ iso2: iso2, iso3: feature.id, element: flagCard });
      // Attach drag handlers
      flagCard.addEventListener('dragstart', onRegionDragStart);
      flagCard.addEventListener('dragend', onRegionDragEnd);
    });
    // Update name visibility based on the current setting
    updateRegionNameDisplay();
  }

  /**
   * Handler for starting a drag on a flag in the region mode.  Records the
   * currently dragged element and reduces its opacity for visual feedback.
   */
  function onRegionDragStart(e) {
    regionDragging = this;
    this.classList.add('dragging');
    // Set the drag data to the ISO3 code so we can compare on drop
    e.dataTransfer.setData('text/plain', this.dataset.iso3);
  }

  /**
   * Handler for ending a drag.  Removes the dragging visual state.
   */
  function onRegionDragEnd(e) {
    if (regionDragging) {
      regionDragging.classList.remove('dragging');
      regionDragging = null;
    }
  }

  /**
   * Handle dropping a flag onto a country.  Compares the ISO3 of the
   * dragged flag with the ISO3 of the target feature.  If correct, the
   * flag is snapped to the centroid of the country and removed from
   * the bottom row; the country path is coloured green.  If incorrect,
   * the country blinks red and the flag remains at the bottom.  When
   * all flags are placed, a completion message and reset button are
   * displayed.
   * @param {Event} event The drop event
   * @param {Object} feature The GeoJSON feature for the drop target
   * @param {SVGPathElement} pathEl The SVG path element representing the country
   */
  function handleRegionDrop(event, feature, pathEl) {
    if (!regionDragging) return;
    const draggedIso3 = regionDragging.dataset.iso3;
    const targetIso3 = feature.id;
    if (draggedIso3 === targetIso3) {
      // Correct placement
      d3.select(pathEl).classed('correct', true).classed('incorrect', false);
      // Snap the flag to the country's centroid.  Scale the flag down when
      // placed on the map so that it does not overwhelm the region.  Use
      // fixed dimensions (64×48) instead of the original 96×72.
      // Compute the centroid of the country in map projection
      let [cx, cy] = regionPath.centroid(feature);
      // Apply the current zoom transform so that snapped flags align
      // correctly with the zoomed/panned map.  If no transform has
      // been recorded yet, regionZoomTransform will default to the
      // identity transform.  applyX/applyY convert from map
      // coordinates to screen coordinates under the current zoom.
      if (regionZoomTransform && typeof regionZoomTransform.applyX === 'function') {
        cx = regionZoomTransform.applyX(cx);
        cy = regionZoomTransform.applyY(cy);
      }
      // Use a smaller flag size when placed on the map so it does not
      // overwhelm the country.  Flags maintain a 3:2 aspect ratio.
      const newW = 40;
      const newH = 28;
      regionDragging.style.position = 'absolute';
      regionDragging.style.zIndex = 50;
      regionDragging.style.width = newW + 'px';
      regionDragging.style.height = newH + 'px';
      regionDragging.style.left = `${cx - newW / 2}px`;
      regionDragging.style.top = `${cy - newH / 2}px`;
      // Move the element into the map container so it sits on top of the country
      regionMapEl.appendChild(regionDragging);
      // Hide the name label on snapped flags.  Names are only shown in the
      // bottom flag bar, not on the map itself.  We remove the label or
      // force it to be hidden to avoid cluttering the map.
      const nameEl = regionDragging.querySelector('.flag-name');
      if (nameEl) {
        nameEl.style.display = 'none';
      }
      // Disable further dragging
      regionDragging.removeEventListener('dragstart', onRegionDragStart);
      regionDragging.removeEventListener('dragend', onRegionDragEnd);
      regionDragging.classList.remove('dragging');
      regionDragging.draggable = false;
      regionDragging = null;
      // Add the placed flag to the snapped flags list so it can be
      // repositioned and resized on subsequent zoom events
      snappedFlags.push({ el: regionMapEl.lastChild, feature: feature });
      // Update positions of all snapped flags to account for current zoom
      updateSnappedFlags();
      // Check if all flags have been placed
      const remaining = Array.from(regionFlags.children).filter(el => el.draggable);
      if (remaining.length === 0) {
        regionStatus.innerHTML = '<span style="color:var(--ok); font-weight:bold;">🎉 Region complete!</span>';
        regionResetBtn.classList.remove('hidden');
      }
    } else {
      // Incorrect placement: briefly flash the country red
      const sel = d3.select(pathEl);
      sel.classed('incorrect', true);
      setTimeout(() => {
        sel.classed('incorrect', false);
      }, 800);
      // The flag remains in the bottom row; nothing else to do
    }
  }

  // ----------------- Data (UN + Territories) -----------------
  const COMMON = {"United Kingdom of Great Britain and Northern Ireland":"United Kingdom","United States of America":"United States","Korea (Republic of)":"South Korea","Korea (Democratic People's Republic of)":"North Korea","Côte d’Ivoire":"Cote d'Ivoire","Viet Nam":"Vietnam","Syrian Arab Republic":"Syria","Iran (Islamic Republic of)":"Iran","Russian Federation":"Russia","Lao People's Democratic Republic":"Laos","Venezuela (Bolivarian Republic of)":"Venezuela","Tanzania, United Republic of":"Tanzania","Türkiye":"Turkey","Timor-Leste":"East Timor"};
  const NICK = {"United States":["USA","US","U.S.","U.S.A","America","United States of America"],"United Kingdom":["UK","Britain","Great Britain"],"Russia":["Russian Federation"],"South Korea":["Korea, South","Republic of Korea","ROK"],"North Korea":["Korea, North","Democratic People's Republic of Korea","DPRK"],"Cote d'Ivoire":["Ivory Coast"],"Czech Republic":["Czechia"],"Myanmar":["Burma"],"Turkey":["Türkiye"],"East Timor":["Timor-Leste"],"Laos":["Lao PDR","Lao People's Democratic Republic"],"Syria":["Syrian Arab Republic"],"Vietnam":["Viet Nam"],"Taiwan":["Republic of China","ROC"],"Palestine":["State of Palestine","Palestine, State of"],"Moldova":["Republic of Moldova"],"Micronesia":["Micronesia (Federated States of)","FSM"],"North Macedonia":["Macedonia"],"DR Congo":["Democratic Republic of the Congo","Congo (DRC)","Congo-Kinshasa","Congo, Democratic Republic of the"],"Republic of the Congo":["Congo-Brazzaville","Congo"]};

  const UN_CSV = `AF|Afghanistan|Asia|Southern Asia|38928346\nAL|Albania|Europe|Southern Europe|2877797\nDZ|Algeria|Africa|Northern Africa|43851044\nAD|Andorra|Europe|Southern Europe|77265\nAO|Angola|Africa|Middle Africa|32866272\nAG|Antigua and Barbuda|Americas|Caribbean|97929\nAR|Argentina|Americas|South America|45195774\nAM|Armenia|Asia|Western Asia|2963243\nAU|Australia|Oceania|Australia and New Zealand|25499884\nAT|Austria|Europe|Western Europe|9006398\nAZ|Azerbaijan|Asia|Western Asia|10139177\nBS|Bahamas|Americas|Caribbean|393244\nBH|Bahrain|Asia|Western Asia|1701575\nBD|Bangladesh|Asia|Southern Asia|164689383\nBB|Barbados|Americas|Caribbean|287375\nBY|Belarus|Europe|Eastern Europe|9449323\nBE|Belgium|Europe|Western Europe|11589623\nBZ|Belize|Americas|Central America|397621\nBJ|Benin|Africa|Western Africa|12123200\nBT|Bhutan|Asia|Southern Asia|771608\nBO|Bolivia|Americas|South America|11673029\nBA|Bosnia and Herzegovina|Europe|Southern Europe|3280819\nBW|Botswana|Africa|Southern Africa|2351627\nBR|Brazil|Americas|South America|212559417\nBN|Brunei Darussalam|Asia|South-Eastern Asia|437483\nBG|Bulgaria|Europe|Eastern Europe|6948445\nBF|Burkina Faso|Africa|Western Africa|20903273\nBI|Burundi|Africa|Eastern Africa|11890784\nCV|Cabo Verde|Africa|Western Africa|555987\nKH|Cambodia|Asia|South-Eastern Asia|16718965\nCM|Cameroon|Africa|Middle Africa|26545863\nCA|Canada|Americas|North America|37742154\nCF|Central African Republic|Africa|Middle Africa|4829767\nTD|Chad|Africa|Middle Africa|16425864\nCL|Chile|Americas|South America|19116201\nCN|China|Asia|Eastern Asia|1439323776\nCO|Colombia|Americas|South America|50882891\nKM|Comoros|Africa|Eastern Africa|869601\nCD|Congo (Democratic Republic of the)|Africa|Middle Africa|89561403\nCG|Congo|Africa|Middle Africa|5518087\nCR|Costa Rica|Americas|Central America|5094118\nCI|Côte d’Ivoire|Africa|Western Africa|26378274\nHR|Croatia|Europe|Southern Europe|4105267\nCU|Cuba|Americas|Caribbean|11326616\nCY|Cyprus|Asia|Western Asia|1207359\nCZ|Czechia|Europe|Eastern Europe|10708981\nDK|Denmark|Europe|Northern Europe|5792202\nDJ|Djibouti|Africa|Eastern Africa|988000\nDM|Dominica|Americas|Caribbean|71986\nDO|Dominican Republic|Americas|Caribbean|10847910\nEC|Ecuador|Americas|South America|17643054\nEG|Egypt|Africa|Northern Africa|102334404\nSV|El Salvador|Americas|Central America|6486201\nGQ|Equatorial Guinea|Africa|Middle Africa|1402985\nER|Eritrea|Africa|Eastern Africa|3546421\nEE|Estonia|Europe|Northern Europe|1326535\nSZ|Eswatini|Africa|Southern Africa|1160164\nET|Ethiopia|Africa|Eastern Africa|114963588\nFJ|Fiji|Oceania|Melanesia|896445\nFI|Finland|Europe|Northern Europe|5540720\nFR|France|Europe|Western Europe|65273511\nGA|Gabon|Africa|Middle Africa|2225734\nGM|Gambia|Africa|Western Africa|2416668\nGE|Georgia|Asia|Western Asia|3989167\nDE|Germany|Europe|Western Europe|83783942\nGH|Ghana|Africa|Western Africa|31072940\nGR|Greece|Europe|Southern Europe|10423054\nGD|Grenada|Americas|Caribbean|112523\nGT|Guatemala|Americas|Central America|17915568\nGN|Guinea|Africa|Western Africa|13132792\nGW|Guinea-Bissau|Africa|Western Africa|1968001\nGY|Guyana|Americas|South America|786552\nHT|Haiti|Americas|Caribbean|11402528\nHN|Honduras|Americas|Central America|9904608\nHU|Hungary|Europe|Eastern Europe|9660351\nIS|Iceland|Europe|Northern Europe|341243\nIN|India|Asia|Southern Asia|1380004385\nID|Indonesia|Asia|South-Eastern Asia|273523615\nIR|Iran (Islamic Republic of)|Asia|Southern Asia|83992949\nIQ|Iraq|Asia|Western Asia|40222493\nIE|Ireland|Europe|Northern Europe|4937786\nIL|Israel|Asia|Western Asia|8655535\nIT|Italy|Europe|Southern Europe|60461826\nJM|Jamaica|Americas|Caribbean|2961167\nJP|Japan|Asia|Eastern Asia|126476461\nJO|Jordan|Asia|Western Asia|10203140\nKZ|Kazakhstan|Asia|Central Asia|18776707\nKE|Kenya|Africa|Eastern Africa|53771296\nKI|Kiribati|Oceania|Micronesia|119449\nKP|Korea (Democratic People's Republic of)|Asia|Eastern Asia|25778816\nKR|Korea (Republic of)|Asia|Eastern Asia|51269185\nKW|Kuwait|Asia|Western Asia|4270571\nKG|Kyrgyzstan|Asia|Central Asia|6524195\nLA|Lao People's Democratic Republic|Asia|South-Eastern Asia|7275560\nLV|Latvia|Europe|Northern Europe|1886198\nLB|Lebanon|Asia|Western Asia|6825445\nLS|Lesotho|Africa|Southern Africa|2142249\nLR|Liberia|Africa|Western Africa|5057681\nLY|Libya|Africa|Northern Africa|6871292\nLI|Liechtenstein|Europe|Western Europe|38128\nLT|Lithuania|Europe|Northern Europe|2722289\nLU|Luxembourg|Europe|Western Europe|625978\nMG|Madagascar|Africa|Eastern Africa|27691018\nMW|Malawi|Africa|Eastern Africa|19129952\nMY|Malaysia|Asia|South-Eastern Asia|32365999\nMV|Maldives|Asia|Southern Asia|540544\nML|Mali|Africa|Western Africa|20250833\nMT|Malta|Europe|Southern Europe|441543\nMH|Marshall Islands|Oceania|Micronesia|59190\nMR|Mauritania|Africa|Western Africa|4649658\nMU|Mauritius|Africa|Eastern Africa|1271768\nMX|Mexico|Americas|North America|128932753\nFM|Micronesia (Federated States of)|Oceania|Micronesia|115023\nMD|Moldova|Europe|Eastern Europe|4033963\nMC|Monaco|Europe|Western Europe|39242\nMN|Mongolia|Asia|Eastern Asia|3278290\nME|Montenegro|Europe|Southern Europe|628066\nMA|Morocco|Africa|Northern Africa|36910560\nMZ|Mozambique|Africa|Eastern Africa|31255435\nMM|Myanmar|Asia|South-Eastern Asia|54409800\nNA|Namibia|Africa|Southern Africa|2540905\nNR|Nauru|Oceania|Micronesia|10824\nNP|Nepal|Asia|Southern Asia|29136808\nNL|Netherlands|Europe|Western Europe|17134872\nNZ|New Zealand|Oceania|Australia and New Zealand|4822233\nNI|Nicaragua|Americas|Central America|6624554\nNE|Niger|Africa|Western Africa|24206644\nNG|Nigeria|Africa|Western Africa|206139589\nMK|North Macedonia|Europe|Southern Europe|2083374\nNO|Norway|Europe|Northern Europe|5421241\nOM|Oman|Asia|Western Asia|5106626\nPK|Pakistan|Asia|Southern Asia|220892340\nPW|Palau|Oceania|Micronesia|18094\nPA|Panama|Americas|Central America|4314767\nPG|Papua New Guinea|Oceania|Melanesia|8947027\nPY|Paraguay|Americas|South America|7132538\nPE|Peru|Americas|South America|32971854\nPH|Philippines|Asia|South-Eastern Asia|109581078\nPL|Poland|Europe|Eastern Europe|37846611\nPT|Portugal|Europe|Southern Europe|10196709\nQA|Qatar|Asia|Western Asia|2881053\nRO|Romania|Europe|Eastern Europe|19237691\nRU|Russian Federation|Europe|Eastern Europe|145934462\nRW|Rwanda|Africa|Eastern Africa|12952218\nKN|Saint Kitts and Nevis|Americas|Caribbean|53199\nLC|Saint Lucia|Americas|Caribbean|183627\nVC|Saint Vincent and the Grenadines|Americas|Caribbean|110940\nWS|Samoa|Oceania|Polynesia|198414\nSM|San Marino|Europe|Southern Europe|33931\nST|Sao Tome and Principe|Africa|Middle Africa|219159\nSA|Saudi Arabia|Asia|Western Asia|34813871\nSN|Senegal|Africa|Western Africa|16743927\nRS|Serbia|Europe|Southern Europe|8737370\nSC|Seychelles|Africa|Eastern Africa|98347\nSL|Sierra Leone|Africa|Western Africa|7976983\nSG|Singapore|Asia|South-Eastern Asia|5850342\nSK|Slovakia|Europe|Eastern Europe|5459642\nSI|Slovenia|Europe|Southern Europe|2078938\nSB|Solomon Islands|Oceania|Melanesia|686884\nSO|Somalia|Africa|Eastern Africa|15893222\nZA|South Africa|Africa|Southern Africa|59308690\nSS|South Sudan|Africa|Eastern Africa|11193725\nES|Spain|Europe|Southern Europe|46754778\nLK|Sri Lanka|Asia|Southern Asia|21413249\nSD|Sudan|Africa|Northern Africa|43849260\nSR|Suriname|Americas|South America|586632\nSE|Sweden|Europe|Northern Europe|10099265\nCH|Switzerland|Europe|Western Europe|8654622\nSY|Syrian Arab Republic|Asia|Western Asia|17500658\nTJ|Tajikistan|Asia|Central Asia|9537645\nTZ|Tanzania, United Republic of|Africa|Eastern Africa|59734218\nTH|Thailand|Asia|South-Eastern Asia|69799978\nTL|Timor-Leste|Asia|South-Eastern Asia|1318445\nTG|Togo|Africa|Western Africa|8278724\nTO|Tonga|Oceania|Polynesia|105695\nTT|Trinidad and Tobago|Americas|Caribbean|1399488\nTN|Tunisia|Africa|Northern Africa|11818619\nTR|Türkiye|Asia|Western Asia|84339067\nTM|Turkmenistan|Asia|Central Asia|6031200\nTV|Tuvalu|Oceania|Polynesia|11792\nUG|Uganda|Africa|Eastern Africa|45741007\nUA|Ukraine|Europe|Eastern Europe|44134693\nAE|United Arab Emirates|Asia|Western Asia|9890402\nGB|United Kingdom of Great Britain and Northern Ireland|Europe|Northern Europe|67886011\nUS|United States of America|Americas|North America|331002651\nUY|Uruguay|Americas|South America|3473730\nUZ|Uzbekistan|Asia|Central Asia|33469203\nVU|Vanuatu|Oceania|Melanesia|307145\nVE|Venezuela (Bolivarian Republic of)|Americas|South America|28435940\nVN|Viet Nam|Asia|South-Eastern Asia|97338579\nYE|Yemen|Asia|Western Asia|29825964\nZM|Zambia|Africa|Eastern Africa|18383955\nZW|Zimbabwe|Africa|Eastern Africa|14862924`;

  const TERR_LIST = [['AI','Anguilla','Americas','Caribbean'],['AW','Aruba','Americas','Caribbean'],['BM','Bermuda','Americas','North America'],['BQ','Caribbean Netherlands','Americas','Caribbean'],['CW','Curaçao','Americas','Caribbean'],['FK','Falkland Islands (Malvinas)','Americas','South America'],['GF','French Guiana','Americas','South America'],['GL','Greenland','Americas','North America'],['GP','Guadeloupe','Americas','Caribbean'],['KY','Cayman Islands','Americas','Caribbean'],['MF','Saint Martin (French part)','Americas','Caribbean'],['MQ','Martinique','Americas','Caribbean'],['MS','Montserrat','Americas','Caribbean'],['PM','Saint Pierre and Miquelon','Americas','North America'],['PR','Puerto Rico','Americas','Caribbean'],['SX','Sint Maarten (Dutch part)','Americas','Caribbean'],['TC','Turks and Caicos Islands','Americas','Caribbean'],['VG','British Virgin Islands','Americas','Caribbean'],['VI','United States Virgin Islands','Americas','Caribbean'],['AX','Åland Islands','Europe','Northern Europe'],['FO','Faroe Islands','Europe','Northern Europe'],['GG','Guernsey','Europe','Northern Europe'],['GI','Gibraltar','Europe','Southern Europe'],['IM','Isle of Man','Europe','Northern Europe'],['JE','Jersey','Europe','Northern Europe'],['SJ','Svalbard and Jan Mayen','Europe','Northern Europe'],['VA','Holy See','Europe','Southern Europe'],['EH','Western Sahara','Africa','Northern Africa'],['IO','British Indian Ocean Territory','Africa','Eastern Africa'],['RE','Réunion','Africa','Eastern Africa'],['SH','Saint Helena, Ascension and Tristan da Cunha','Africa','Western Africa'],['YT','Mayotte','Africa','Eastern Africa'],['CC','Cocos (Keeling) Islands','Asia','South-Eastern Asia'],['CX','Christmas Island','Asia','South-Eastern Asia'],['HK','Hong Kong','Asia','Eastern Asia'],['MO','Macao','Asia','Eastern Asia'],['PS','Palestine, State of','Asia','Western Asia'],['TW','Taiwan','Asia','Eastern Asia'],['AS','American Samoa','Oceania','Polynesia'],['CK','Cook Islands','Oceania','Polynesia'],['GU','Guam','Oceania','Micronesia'],['HM','Heard Island and McDonald Islands','Oceania','Subantarctic'],['NC','New Caledonia','Oceania','Melanesia'],['NF','Norfolk Island','Oceania','Australia and New Zealand'],['NU','Niue','Oceania','Polynesia'],['PN','Pitcairn','Oceania','Polynesia'],['TK','Tokelau','Oceania','Polynesia'],['UM','United States Minor Outlying Islands','Oceania','Micronesia'],['WF','Wallis and Futuna','Oceania','Polynesia'],['AQ','Antarctica','Antarctica','Antarctica'],['BV','Bouvet Island','Antarctica','Subantarctic'],['GS','South Georgia and the South Sandwich Islands','Antarctica','Subantarctic'],['TF','French Southern Territories','Antarctica','Subantarctic']];

  function norm(s){return (s||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}+/gu,'').replace(/[^a-z0-9 ]+/g,' ').replace(/\s+/g,' ').trim();}
  function acroVariants(name){const words=name.split(/\s+/).filter(w=>/^[a-z]/i.test(w));const acro=words.map(w=>w[0]).join('').toUpperCase();if(acro.length<2) return [];return [acro, acro.split('').join('. ')+'.', acro.split('').join('.')];}
  function addNicknames(obj){const common=COMMON[obj.name];if(common) obj.name=common; obj.alt=obj.alt||[]; const mapped=NICK[obj.name]; if(mapped) obj.alt.push(...mapped); acroVariants(obj.name).forEach(v=>obj.alt.push(v)); if(obj.name==='Netherlands') obj.alt.push('The Netherlands','Holland'); if(obj.name==='United Arab Emirates') obj.alt.push('UAE'); if(obj.name==='United Kingdom') obj.alt.push('UK','Britain','Great Britain'); obj.alt=[...new Set(obj.alt.filter(Boolean))]; return obj;}
  function parseUN(csv){
    return csv.trim().split(/\n+/).map(line=>{
      const [cca2,rawName,continent,subregion,pop] = line.split('|');
      const entry = {cca2,name:COMMON[rawName]||rawName,continent,subregion,pop:Number(pop)||0,flag:`https://flagcdn.com/w320/${cca2.toLowerCase()}.png`,alt:[]};
      return addNicknames(entry);
    });
  }
  function buildTerritories(){return TERR_LIST.map(([cca2,name,continent,subregion])=>addNicknames({cca2,name:COMMON[name]||name,continent,subregion,flag:`https://flagcdn.com/w320/${cca2.toLowerCase()}.png`,alt:[]}));}

  const dataUN = parseUN(UN_CSV);
  const dataTerr = buildTerritories();
  const seen = new Set();
  const dataAll = [...dataUN, ...dataTerr].filter(x=>{if(seen.has(x.cca2)) return false; seen.add(x.cca2); return true;}).sort((a,b)=>a.name.localeCompare(b.name));

  const state = { activeTab:'UN', quizPool:[], current:null, ok:0, streak:0, timerMs:Infinity, hideTimeout:null, memory:{sequence:[], index:0}, lastImage:null, piecesRevealed:1,
    // The current game mode (classic, memory, draw, endless, connections)
    mode:'classic',
    effectsCurrent:{ blurOn:false, blurPx:0, pixelOn:false, pixel:1, zoomOn:false, zoom:2, six:false, randColor:false, gs:0, inv:0, hue:0, sat:1, con:1 },
    effectsPending:{ blurOn:false, blurPx:0, pixelOn:false, pixel:1, zoomOn:false, zoom:2, six:false, randColor:false, gs:0, inv:0, hue:0, sat:1, con:1 },
    userPresets: [],
    // Maximum mistakes allowed in connections mode (when unlimited mistakes is disabled)
    maxMistakes: 4,
    // Odd One Out specific settings
    oddMaxMistakes: 2,      // maximum mistakes allowed in odd mode (unless unlimited)
    oddMistakesUsed: 0,     // mistakes used in the current odd round
    oddUnlimitedMistakes: false, // whether unlimited mistakes is enabled for odd mode
    // Region Snapshot specific settings
    regionShowNames: false, // show country names under each draggable flag if true
    // Number of mistakes made so far in the current connections round
    connectionsMistakesUsed: 0,
    // Whether unlimited mistakes are enabled in Flag Connections
    unlimitedMistakes: false
  };
  state.customMode='UN_EASY';

  // Immediately populate the mode display with the default mode name (before any games are started).
  // We do this here because `state` is now defined and DOM elements have been queried. This ensures
  // the header shows the currently selected mode upon page load.
  if (modeDisplay && modeNames[state.mode]) {
    modeDisplay.innerHTML = modeNames[state.mode];
  }

  // Initialize unlimited mistakes setting now that `state` is defined.  If the user
  // has toggled unlimited mistakes in the settings panel prior to loading a
  // connections game, this ensures `state.unlimitedMistakes` reflects the toggle
  // state.  updateUnlimited() is defined earlier in this script.
  try {
    if (typeof updateUnlimited === 'function') updateUnlimited();
  } catch(err) {
    // ignore if updateUnlimited is not defined or throws
  }

  // ---- User presets (localStorage) ----
  const PRESET_KEY = 'uf_user_presets_v1';
  function loadPresets(){
    try{ const raw=localStorage.getItem(PRESET_KEY); state.userPresets = raw? JSON.parse(raw): []; }
    catch{ state.userPresets = []; }
  }
  function savePresets(){ try{ localStorage.setItem(PRESET_KEY, JSON.stringify(state.userPresets)); }catch{} }
  loadPresets();

  function getCustomPool(){
    if(String(state.customMode||'').startsWith('USER:')){
      const p = state.userPresets.find(x=>x.id===state.customMode);
      if(p){ const chosen=new Set(p.items||[]); return dataAll.filter(x=>chosen.has(x.cca2)); }
    }
    switch(state.customMode){
      case 'UN_EASY':{ const sorted=[...dataUN].sort((a,b)=>b.pop-a.pop); const cut=Math.ceil(sorted.length*0.20); return sorted.slice(0,cut); }
      case 'UN_MED':{ const sorted=[...dataUN].sort((a,b)=>b.pop-a.pop); const s=Math.ceil(sorted.length*0.20); const e=Math.ceil(sorted.length*0.60); return sorted.slice(s,e); }
      case 'UN_HARD':{ const sorted=[...dataUN].sort((a,b)=>b.pop-a.pop); const e=Math.ceil(sorted.length*0.60); return sorted.slice(e); }
      case 'NA': return dataAll.filter(x=>x.continent==='Americas' && (x.subregion.includes('North')||x.subregion.includes('Central')));
      case 'SA': return dataAll.filter(x=>x.subregion==='South America');
      case 'EU': return dataAll.filter(x=>x.continent==='Europe');
      case 'AS': return dataAll.filter(x=>x.continent==='Asia');
      case 'AF': return dataAll.filter(x=>x.continent==='Africa');
      case 'OC': return dataAll.filter(x=>x.continent==='Oceania');
      case 'WORLD': return dataAll;
      default: return dataAll;
    }
  }
  function getSource(){ if(state.activeTab==='UN') return dataUN; if(state.activeTab==='Territories') return dataTerr; if(state.activeTab==='ALL') return dataAll; if(state.activeTab==='Custom') return getCustomPool(); return dataAll; }
  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

  function buildFilterString(){
    const e = state.effectsCurrent;
    const parts = [];
    if(e.gs>0) parts.push(`grayscale(${e.gs})`);
    if(e.inv>0) parts.push(`invert(${e.inv})`);
    const randHue = (state.current && e.randColor && typeof state.current._randHue==='number') ? state.current._randHue : 0;
    const hueTotal = ((e.hue||0) + randHue) % 360;
    if(hueTotal!==0) parts.push(`hue-rotate(${hueTotal}deg)`);
    if(e.sat!==1) parts.push(`saturate(${e.sat})`);
    if(e.con!==1) parts.push(`contrast(${e.con})`);
    if(e.blurOn && e.blurPx>0) parts.push(`blur(${e.blurPx}px)`);
    return parts.join(' ');
  }

  function drawPieces(img, sx, sy, sw, sh, dx, dy, dw, dh){
    const cols=3, rows=2; // 6 pieces
    const pieceW = Math.floor(dw/cols), pieceH = Math.floor(dh/rows);
    const srcPW = sw/cols, srcPH = sh/rows;
    let n=0;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        n++;
        const sxi = sx + c*srcPW;
        const syi = sy + r*srcPH;
        const dxi = dx + c*pieceW;
        const dyi = dy + r*pieceH;
        if(n<=state.piecesRevealed){
          ctx.drawImage(img, sxi, syi, srcPW, srcPH, dxi, dyi, pieceW, pieceH);
        } else {
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--panel')||'#111';
          ctx.fillRect(dxi, dyi, pieceW, pieceH);
        }
      }
    }
  }

  function renderCurrent(){
    if(!state.lastImage) return;
    const img = state.lastImage;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const s=Math.min(canvas.width/img.width, canvas.height/img.height);
    const w=Math.floor(img.width*s), h=Math.floor(img.height*s);
    const x=Math.floor((canvas.width-w)/2), y=Math.floor((canvas.height-h)/2);

    let sx=0, sy=0, sw=img.width, sh=img.height;
    const e=state.effectsCurrent;
    if(e.zoomOn && e.zoom>1 && state.current && state.current._crop){ ({sx,sy,sw,sh}=state.current._crop); }

    let off=null; let octx=null;
    const pxOn = e.pixelOn && e.pixel>1;
    if(pxOn){
      const scale = Math.max(1, e.pixel);
      const sw2 = Math.max(1, Math.floor(w/scale));
      const sh2 = Math.max(1, Math.floor(h/scale));
      off=document.createElement('canvas'); off.width=sw2; off.height=sh2; octx=off.getContext('2d');
      octx.imageSmoothingEnabled=true;
      octx.drawImage(img, sx, sy, sw, sh, 0,0, sw2, sh2);
      ctx.imageSmoothingEnabled=false;
    } else {
      ctx.imageSmoothingEnabled=true;
    }

    if(e.six){
      if(pxOn){ drawPieces(off, 0,0, off.width, off.height, x, y, w, h); }
      else { drawPieces(img, sx, sy, sw, sh, x, y, w, h); }
    } else {
      if(pxOn){ ctx.drawImage(off, x, y, w, h); }
      else { ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h); }
    }

    canvas.style.filter = buildFilterString();
  }

  function pickCrop(img, zoom){
    const cropW = Math.floor(img.width / zoom);
    const cropH = Math.floor(img.height / zoom);
    const sx = Math.floor(Math.random()*(img.width - cropW));
    const sy = Math.floor(Math.random()*(img.height - cropH));
    return {sx,sy,sw:cropW,sh:cropH};
  }

  function drawFlag(entry){
    const img=new Image(); img.crossOrigin='anonymous';
    img.onload=()=>{
      state.lastImage = img;
      state.piecesRevealed = state.effectsCurrent.six ? 1 : 6;
      if(state.effectsCurrent.zoomOn && state.effectsCurrent.zoom>1){ entry._crop = pickCrop(img, state.effectsCurrent.zoom); }
      else { entry._crop = {sx:0,sy:0,sw:img.width,sh:img.height}; }
      entry._randHue = state.effectsCurrent.randColor ? Math.floor(Math.random()*360) : 0;
      renderCurrent();
    };
    img.onerror=()=>{ resultEl.innerHTML='<span class="bad">Failed to load image.</span>'; };
    img.src=entry.flag;
  }

  function updateDatalist(){ const list=getSource(); const opts=[]; list.forEach(e=>{opts.push(`<option value="${e.name}">`); (e.alt||[]).forEach(a=>opts.push(`<option value="${a}">`));}); $('#allnames').innerHTML=opts.join(''); }
  function buildLearn(){ const src=getSource(); learnList.innerHTML = src.map(x=>`<div class="item"><img loading="lazy" src="${x.flag}" alt="${x.name}"><small>${x.name}</small></div>`).join(''); }

  function startGame(){
    // Start classic mode and reset counters
    state.mode = 'classic';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = 0;
    streakEl.textContent = 0;
    resultEl.textContent = '';
    state.quizPool = shuffle(getSource().slice());
    // Hide draw header when leaving draw mode
    drawHeader.classList.add('hidden');
    // Hide region and connections panels when entering classic mode
    regionPanel.classList.add('hidden');
    // Hide connections panel when entering classic mode
    connectionsPanel.classList.add('hidden');
    // Hide odd one out panel when entering classic mode
    oddPanel.classList.add('hidden');
    // Show result area and canvas for standard play
    resultEl.classList.remove('hidden');
    canvas.classList.remove('hidden');
    // Show the generic submit button used in most modes
    submitBtn.classList.remove('hidden');
    // Ensure the answer input is visible and drawing controls are hidden
    answer.classList.remove('hidden');
    drawControls.classList.add('hidden');
    // Enable inputs and show controls
    answer.disabled = false;
    submitBtn.disabled = false;
    revealBtn.disabled = false;
    nextBtn.disabled = false;
    // Ensure the reveal and next buttons and learn panel are visible when not in endless mode
    revealBtn.classList.remove('hidden');
    nextBtn.classList.remove('hidden');
    learnPanel.classList.remove('hidden');
    // Reset effects to user-selected pending settings
    state.effectsCurrent = JSON.parse(JSON.stringify(state.effectsPending));
    // Update the mode display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    // Update the instructions for classic mode
    if (gameInstructions) {
      gameInstructions.innerHTML = '<b>Classic Mode:</b> Guess the name of the country based on its flag. Type your answer and click <b>Submit</b>, or click <b>Reveal</b> to show the correct answer. Use <b>Next</b> to move on to the next flag.';
    }
    nextFlag();
  }

  function nextFlag(){
    // Draw the next flag in the quiz. In endless hardcore mode, randomize effects per flag.
    if (state.quizPool.length === 0) {
      resultEl.innerHTML = '<span class="warn">No flags left.</span>';
      return;
    }
    state.current = state.quizPool.pop();
    if (state.mode === 'endless') {
      randomizeEffects();
    } else {
      // copy user-selected pending effects for standard and memory modes
      state.effectsCurrent = JSON.parse(JSON.stringify(state.effectsPending));
    }
    drawFlag(state.current);
    scheduleTimer();
  }

  // Randomize flag effects for endless hardcore mode
  function randomizeEffects(){
    // Select up to two distinct effect categories to randomize; others remain at defaults.
    const categories = ['blur','pixel','zoom','six','randColor','gs','inv','hue','sat','con'];
    // Randomly choose 1 or 2 categories
    const num = 1 + Math.floor(Math.random() * 2);
    const chosen = [];
    while(chosen.length < num){
      const idx = Math.floor(Math.random() * categories.length);
      const cat = categories[idx];
      if(!chosen.includes(cat)) chosen.push(cat);
    }
    // Defaults for all effects
    const p = {
      blurOn: false, blurPx: 0,
      pixelOn: false, pixel: 1,
      zoomOn: false, zoom: 1,
      six: false,
      randColor: false,
      gs: 0,
      inv: 0,
      hue: 0,
      sat: 1,
      con: 1
    };
    // Randomize selected categories
    chosen.forEach(cat => {
      switch(cat){
        case 'blur':
          p.blurOn = true;
          p.blurPx = Math.random() * 20;
          break;
        case 'pixel':
          p.pixelOn = true;
          p.pixel = Math.floor(1 + Math.random() * 60);
          break;
        case 'zoom':
          p.zoomOn = true;
          p.zoom = 1 + Math.random() * 5;
          break;
        case 'six':
          p.six = true;
          break;
        case 'randColor':
          p.randColor = true;
          break;
        case 'gs':
          p.gs = Math.random();
          break;
        case 'inv':
          p.inv = Math.random();
          break;
        case 'hue':
          p.hue = Math.random() * 360;
          break;
        case 'sat':
          p.sat = Math.random() * 3;
          break;
        case 'con':
          p.con = Math.random() * 3;
          break;
      }
    });
    state.effectsCurrent = p;
  }

  // Start Endless Hardcore mode: similar to standard mode but with random effects on each flag
  function startEndless(){
    state.mode = 'endless';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = 0;
    streakEl.textContent = 0;
    resultEl.textContent = '';
    // build quiz pool from current source
    state.quizPool = shuffle(getSource().slice());
    // Enable answer and buttons
    answer.disabled = false;
    submitBtn.disabled = false;
    // Hide the draw header in endless mode
    drawHeader.classList.add('hidden');
    // Hide region panel when entering endless mode
    regionPanel.classList.add('hidden');
    // Hide connections panel when entering endless mode
    connectionsPanel.classList.add('hidden');
    // Hide odd one out panel when entering endless mode
    oddPanel.classList.add('hidden');
    // Ensure the canvas and result elements are visible
    canvas.classList.remove('hidden');
    resultEl.classList.remove('hidden');
    // Show the generic submit button for endless mode
    submitBtn.classList.remove('hidden');
    // Ensure the answer input is visible and drawing controls are hidden
    answer.classList.remove('hidden');
    drawControls.classList.add('hidden');
    // Hide controls that could be used to cheat in endless mode
    revealBtn.classList.add('hidden');
    nextBtn.classList.add('hidden');
    learnPanel.classList.add('hidden');
    // Ensure reveal and next are also disabled
    revealBtn.disabled = true;
    nextBtn.disabled = true;
    // Start by drawing the first flag via nextFlag (randomization happens there)
    // Update mode display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    // Update instructions for Endless Hardcore mode
    if (gameInstructions) {
      gameInstructions.innerHTML = '<b>Endless Hardcore:</b> Guess each flag under random visual effects (blur, pixelation, colour shifts, etc.). Effects change with every flag. There are no hints or learning aids.';
    }
    nextFlag();
  }

  // Start Draw-from-Memory mode
  function startDraw(){
    state.mode = 'draw';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = 0;
    streakEl.textContent = 0;
    // Build quiz pool from current source
    state.quizPool = shuffle(getSource().slice());
    // Clear the result area; the country name and instructions will be set when the first flag is chosen
    resultEl.innerHTML = '';
    // Hide the answer input field but keep the submit button visible, and show drawing controls
    answer.classList.add('hidden');
    drawControls.classList.remove('hidden');
    // Hide region panel when entering draw mode
    regionPanel.classList.add('hidden');
    // Hide connections panel when entering draw mode
    connectionsPanel.classList.add('hidden');
    // Hide odd one out panel when entering draw mode
    oddPanel.classList.add('hidden');
    // Ensure canvas and result area are visible
    canvas.classList.remove('hidden');
    resultEl.classList.remove('hidden');
    // Show the generic submit button for draw mode
    submitBtn.classList.remove('hidden');
    // Hide reveal and next buttons initially in draw mode
    revealBtn.classList.add('hidden');
    revealBtn.disabled = true;
    nextBtn.classList.add('hidden');
    nextBtn.disabled = true;
    // Enable the submit button for drawing evaluation
    submitBtn.disabled = false;
    // Hide learn panel in draw mode
    learnPanel.classList.add('hidden');
    // Clear canvas and fill white background for drawing
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // Grid overlay removed; nothing to update here
    // Show the draw header
    drawHeader.classList.remove('hidden');
    // Update mode display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    // Update the instructions for draw mode
    if (gameInstructions) {
      gameInstructions.innerHTML = '<b>Draw The Flag:</b> You\'ll be shown a country name. Use the drawing tools to sketch its flag from memory. Pick colours from the palette or use the eyedropper, then click <b>Submit</b> to see how close you are.';
    }
    // Start with a new flag to draw
    nextDraw();

    // Update colour swatch in case the palette takes time to load
    updateSwatch();
  }

  // Advance to the next flag in draw-from-memory mode
  function nextDraw(){
    if(!state.quizPool || state.quizPool.length === 0){
      state.quizPool = shuffle(getSource().slice());
    }
    state.current = state.quizPool.pop();
    // Reset result message and prepare for a new drawing
    // Show the country name at the top and instructions below
    // Display the country name next to the streak in bold.  Use
    // capitalised "Flag" for a polished look.
    drawHeader.innerHTML = `<b>Draw: ${state.current.name}'s Flag</b>`;
    resultEl.innerHTML = `<span class="muted">Draw the flag from memory, then click <b>Submit</b> to see how close you are.</span>`;
    // Populate the colour picker suggestions with colours from this flag
    generatePaletteForFlag(state.current.flag);
    // Clear the drawing canvas
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // Grid overlay removed; nothing to update here
    // Hide reveal and next buttons until the user submits their drawing
    revealBtn.classList.add('hidden');
    revealBtn.disabled = true;
    nextBtn.classList.add('hidden');
    nextBtn.disabled = true;
    // Ensure the submit button is enabled for the new drawing
    submitBtn.disabled = false;
  }

  function scheduleTimer(){ if(state.hideTimeout){clearTimeout(state.hideTimeout); state.hideTimeout=null;} if(state.timerMs!==Infinity){ state.hideTimeout=setTimeout(()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); resultEl.innerHTML='<span class="warn">⏱️ Time\'s up!</span>'; }, state.timerMs); } }
  function allNames(e){ return [e.name, ...(e.alt||[])]; }

  function matches(input, entry){
    const g = norm(input);
    const currentNames = allNames(entry).map(norm);
    if (currentNames.includes(g)) return true;
    if (g.length >= 3 && currentNames.some(n => n.startsWith(g))) {
      const src = getSource();
      for (const e of src) {
        if (e === entry) continue;
        const names = allNames(e).map(norm);
        if (names.some(n => n.startsWith(g))) return false;
      }
      return true;
    }
    return false;
  }

  // Convert an RGB pixel to a coarse colour category (white, black, red, yellow, green, blue).
  // Uses HSV thresholds to classify colours. White and black are matched by brightness
  // and saturation; hue ranges segment the remaining colours. Colours that fall
  // outside these ranges default to 'red' (covering magenta and purple hues).
  function classifyColor(r, g, b) {
    const rf = r / 255, gf = g / 255, bf = b / 255;
    const max = Math.max(rf, gf, bf);
    const min = Math.min(rf, gf, bf);
    const v = max;
    const d = max - min;
    let s = 0;
    if (max !== 0) s = d / max;
    // compute hue
    let h = 0;
    if (d !== 0) {
      if (max === rf) {
        h = ((gf - bf) / d) * 60;
      } else if (max === gf) {
        h = ((bf - rf) / d) * 60 + 120;
      } else {
        h = ((rf - gf) / d) * 60 + 240;
      }
      if (h < 0) h += 360;
    }
    // classification by brightness and saturation
    if (v < 0.1) return 'black';
    if (v > 0.9 && s < 0.1) return 'white';
    // hue based categories
    if (h < 20 || h >= 340) return 'red';
    if (h < 65) return 'yellow';
    if (h < 170) return 'green';
    if (h < 275) return 'blue';
    return 'red';
  }

  // ----------------- Flag Connections Theme Generation -----------------
  // Data structure to hold themes for the flag connections mode.
  // Each theme has a name and an array of entries (flags) belonging to that theme.
  let connectionsThemes = [];
  // Flags to ensure themes are built only once
  let connectionsBuiltSimple = false;
  let connectionsBuiltColors = false;

  /**
   * Build a variety of simple categories for the Connections game.  Themes
   * include continents, subregions, name patterns (starting/ending with
   * specific letters, containing letters) and name length.  Only
   * categories containing at least 4 flags are kept.  This function
   * populates the global `connectionsThemes` array and will not run more
   * than once.
   */
  function buildSimpleConnectionsThemes() {
    if (connectionsBuiltSimple) return;
    connectionsBuiltSimple = true;
    connectionsThemes = [];
    // Restrict the pool to UN member countries only for connections themes
    const pool = dataUN;
    // Build continent themes
    const continents = {};
    for (const e of pool) {
      if (!continents[e.continent]) continents[e.continent] = [];
      continents[e.continent].push(e);
    }
    for (const cont in continents) {
      const list = continents[cont];
      if (list.length >= 4) connectionsThemes.push({ name: `Flags from ${cont}`, flags: list, type: 'continent' });
    }
    // Build subregion themes (e.g., Western Europe, Southern Asia)
    const subregions = {};
    for (const e of pool) {
      const sub = e.subregion || '';
      if (!subregions[sub]) subregions[sub] = [];
      subregions[sub].push(e);
    }
    for (const sub in subregions) {
      const list = subregions[sub];
      if (sub && list.length >= 4) connectionsThemes.push({ name: `${sub}`, flags: list, type: 'subregion' });
    }
    // Create categories for names starting with each letter
    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (const ch of alphabet) {
      const arr = pool.filter(e => e.name.toUpperCase().startsWith(ch));
      if (arr.length >= 4) connectionsThemes.push({ name: `Countries starting with ${ch}`, flags: arr, type: 'first_letter' });
    }
    // Do NOT create categories for names containing each letter, as this category is too vague
    // Create categories for names ending with each letter
    for (const ch of alphabet) {
      const arr = pool.filter(e => e.name.toUpperCase().endsWith(ch));
      if (arr.length >= 4) connectionsThemes.push({ name: `Countries ending with ${ch}`, flags: arr, type: 'last_letter' });
    }
    // Create categories based on the length of the country name (letters only)
    for (let len = 4; len <= 12; len++) {
      const arr = pool.filter(e => e.name.replace(/\s+/g, '').length === len);
      if (arr.length >= 4) connectionsThemes.push({ name: `${len}-letter names`, flags: arr, type: 'length' });
    }
    // Additional pattern-based categories for more variety.  Each pattern is an object with
    // a substring and a display name.  Categories are built from countries whose names
    // include or end with the substring, depending on the pattern type.  Only kept if
    // at least 4 matching countries are found.
    const patterns = [
      { substr: 'ISLAND', name: 'Countries containing Island', type: 'keyword' },
      { substr: 'ISLANDS', name: 'Countries containing Islands', type: 'keyword' },
      { substr: 'LAND', name: 'Countries containing Land', type: 'keyword' },
      { substr: 'STAN', name: 'Countries ending with -stan', type: 'keyword' },
      { substr: 'UNI', name: 'Countries containing United', type: 'keyword' },
      { substr: 'REPUB', name: 'Countries containing Republic', type: 'keyword' },
      { substr: 'SAINT', name: 'Countries containing Saint', type: 'keyword' },
      { substr: 'GUINEA', name: 'Countries containing Guinea', type: 'keyword' },
      { substr: 'NEW ', name: 'Countries starting with New', type: 'keyword' },
      { substr: 'KOREA', name: 'Countries containing Korea', type: 'keyword' },
      { substr: 'EMIRATES', name: 'Countries containing Emirates', type: 'keyword' },
      { substr: 'ARAB', name: 'Countries containing Arab', type: 'keyword' },
      { substr: 'SOUTH ', name: 'Countries starting with South', type: 'keyword' },
      { substr: 'NORTH ', name: 'Countries starting with North', type: 'keyword' },
      { substr: 'EAST ', name: 'Countries starting with East', type: 'keyword' },
      { substr: 'WEST ', name: 'Countries starting with West', type: 'keyword' }
    ];
    for (const p of patterns) {
      let arr;
      const sub = p.substr.toUpperCase();
      // If the pattern specifies a space at the end (e.g., "NEW ") treat it as prefix
      if (sub.endsWith(' ')) {
        const prefix = sub.trimEnd();
        arr = pool.filter(e => e.name.toUpperCase().startsWith(prefix));
      } else if (sub.startsWith('-')) {
        // Patterns starting with '-' would indicate suffix, but none are defined here
        arr = [];
      } else if (sub === 'STAN') {
        arr = pool.filter(e => e.name.toUpperCase().endsWith(sub));
      } else {
        arr = pool.filter(e => e.name.toUpperCase().includes(sub));
      }
      if (arr.length >= 4) connectionsThemes.push({ name: p.name, flags: arr, type: p.type });
    }
  }

  /**
   * Build colour-based themes by analysing flag images.  Each flag
   * is sampled at low resolution and pixels are classified into
   * coarse colours (red, yellow, green, blue, black, white).  If a
   * particular colour is present in significant quantities in a flag,
   * that flag is added to the corresponding theme.  The analysis is
   * asynchronous; themes are only added once the images have been
   * processed.  Only categories containing at least 4 flags are kept.
   */
  async function buildColorConnectionsThemes() {
    if (connectionsBuiltColors) return;
    connectionsBuiltColors = true;
    // Temporary buckets for each coarse colour
    const colorBuckets = { red: [], yellow: [], green: [], blue: [], black: [], white: [] };
    // Only use UN member flags for colour themes to exclude territories
    const promises = dataUN.map(entry => new Promise((resolve) => {
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = function() {
        try {
          const off = document.createElement('canvas');
          off.width = 100;
          off.height = 60;
          const ctx2 = off.getContext('2d');
          ctx2.drawImage(img, 0, 0, off.width, off.height);
          const pixels = ctx2.getImageData(0, 0, off.width, off.height).data;
          const counts = { red: 0, yellow: 0, green: 0, blue: 0, black: 0, white: 0 };
          for (let i = 0; i < pixels.length; i += 4) {
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            const cat = classifyColor(r, g, b);
            if (counts[cat] !== undefined) counts[cat]++;
          }
          // Determine presence thresholds; at least 100 pixels indicates the colour is
          // strongly present
          for (const c in counts) {
            if (counts[c] > 100) {
              colorBuckets[c].push(entry);
            }
          }
        } catch(err) {
          // ignore errors
        }
        resolve();
      };
      img.onerror = function() { resolve(); };
      // Use a smaller resolution version if available; flagcdn supports w160
      let url = entry.flag;
      url = url.replace('/w320/', '/w160/');
      img.src = url;
    }));
    await Promise.all(promises);
    // Convert colour buckets into themes
    for (const c in colorBuckets) {
      const list = colorBuckets[c];
      if (list.length >= 4) {
        const cap = c.charAt(0).toUpperCase() + c.slice(1);
        connectionsThemes.push({ name: `Flags with ${cap}`, flags: list, type: 'color' });
      }
    }
  }

  /**
   * Ensure that all themes required for the connections game have been built.
   * Builds simple themes synchronously and colour themes asynchronously if
   * they haven't been processed yet.
   */
  async function ensureConnectionsThemes() {
    buildSimpleConnectionsThemes();
    await buildColorConnectionsThemes();
    // Build additional connection themes (languages, population, area, tricolour, weapons, crosses)
    buildExtraConnectionsThemes();
  }

  /**
   * Build additional themed categories beyond the basic continent/letter/colour patterns.  These
   * groups include language families, population and land area extremes, tricolour flags,
   * flags featuring weapons, and flags with crosses.  Each category must contain at least
   * four UN member countries and is tagged with a unique type to avoid duplicate types
   * appearing within the same round.
   */
  let extraThemesBuilt = false;
  function buildExtraConnectionsThemes() {
    if (extraThemesBuilt) return;
    extraThemesBuilt = true;
    // Helper to resolve a list of country names into data entries
    function entriesFromNames(names) {
      return names.map(n => dataUN.find(e => e.name === n)).filter(Boolean);
    }
    // ----- Language categories -----
    const langGroups = {
      'English': [
        'United Kingdom','Ireland','United States','Canada','Australia','New Zealand','South Africa','Nigeria','Kenya','Uganda','Ghana','Jamaica','Trinidad and Tobago'
      ],
      'French': [
        'France','Belgium','Canada','Haiti','Senegal','Cote d\'Ivoire','Madagascar','DR Congo','Cameroon','Guinea','Niger','Mali','Burkina Faso','Togo'
      ],
      'Spanish': [
        'Spain','Mexico','Argentina','Chile','Colombia','Peru','Venezuela','Ecuador','Bolivia','Uruguay','Paraguay','Cuba','Dominican Republic','Costa Rica','Honduras'
      ],
      'Portuguese': [
        'Portugal','Brazil','Angola','Mozambique','Guinea-Bissau','Cabo Verde','Sao Tome and Principe','East Timor'
      ],
      'Arabic': [
        'Saudi Arabia','Algeria','Egypt','Iraq','Jordan','Kuwait','Lebanon','Libya','Mauritania','Morocco','Oman','Qatar','Syria','Tunisia','United Arab Emirates','Yemen','Sudan','Somalia','Djibouti'
      ]
    };
    Object.entries(langGroups).forEach(([lang,names]) => {
      const flags = entriesFromNames(names);
      if (flags.length >= 4) {
        connectionsThemes.push({ name: `Countries speaking ${lang}`, flags, type: 'language' });
      }
    });
    // ----- Population extremes -----
    const sortedByPop = dataUN.slice().sort((a,b) => b.pop - a.pop);
    const popTop30 = sortedByPop.slice(0,30);
    const popBottom30 = sortedByPop.slice(-30);
    if (popTop30.length >= 4) connectionsThemes.push({ name: 'Top 30 by population', flags: popTop30, type: 'population' });
    if (popBottom30.length >= 4) connectionsThemes.push({ name: 'Bottom 30 by population', flags: popBottom30, type: 'population' });
    // ----- Land area extremes -----
    // Define approximate top 30 largest countries by land area (UN member names)
    const areaTopNames = [
      'Russia','Canada','United States','China','Brazil','Australia','India','Argentina','Kazakhstan','Algeria','DR Congo','Saudi Arabia','Mexico','Indonesia','Sudan','Libya','Iran','Mongolia','Peru','Chad','Niger','Angola','Mali','South Africa','Colombia','Ethiopia','Bolivia','Mauritania','Egypt','Tanzania'
    ];
    const areaBottomNames = [
      'Monaco','Nauru','Tuvalu','San Marino','Liechtenstein','Malta','Maldives','Saint Kitts and Nevis','Grenada','Seychelles','Bahrain','Barbados','Antigua and Barbuda','Saint Vincent and the Grenadines','Kiribati','Micronesia (Federated States of)','Marshall Islands','Sao Tome and Principe','Comoros','Cape Verde','Mauritius','Dominica','Andorra','Singapore','Luxembourg','Qatar','Brunei Darussalam','Samoa','Bahamas','Trinidad and Tobago'
    ];
    const areaTop = entriesFromNames(areaTopNames);
    const areaBottom = entriesFromNames(areaBottomNames);
    if (areaTop.length >= 4) connectionsThemes.push({ name: 'Top 30 by land area', flags: areaTop, type: 'area' });
    if (areaBottom.length >= 4) connectionsThemes.push({ name: 'Bottom 30 by land area', flags: areaBottom, type: 'area' });
    // ----- Tricolour flags -----
    const tricolourNames = [
      // Vertical tricolours
      'France','Italy','Belgium','Ireland','Romania','Chad','Mali','Guinea','Cote d\'Ivoire','Senegal','Cameroon','Bulgaria','Armenia','Lithuania','Mexico','Guyana','Bolivia',
      // Horizontal tricolours
      'Netherlands','Luxembourg','Germany','Russia','Estonia','Lithuania','Hungary','Bulgaria','Armenia','Sierra Leone','Gambia','Ghana','Ethiopia'
    ];
    const tricolourFlags = entriesFromNames(tricolourNames);
    if (tricolourFlags.length >= 4) connectionsThemes.push({ name: 'Tricolour flags', flags: tricolourFlags, type: 'tricolour' });
    // ----- Flags with weapons -----
    const weaponNames = [
      'Saudi Arabia','Oman','Mozambique','Guatemala','Sri Lanka','Kenya','Angola','Zimbabwe'
    ];
    const weaponFlags = entriesFromNames(weaponNames);
    if (weaponFlags.length >= 4) connectionsThemes.push({ name: 'Flags with weapons', flags: weaponFlags, type: 'weapon' });
    // ----- Flags with crosses -----
    const crossNames = [
      'Switzerland','United Kingdom','Denmark','Sweden','Norway','Finland','Iceland','Greece','Dominican Republic','Tonga','Georgia'
    ];
    const crossFlags = entriesFromNames(crossNames);
    if (crossFlags.length >= 4) connectionsThemes.push({ name: 'Flags with crosses', flags: crossFlags, type: 'cross' });

    // ----- Flags with animals -----
    // Countries whose flags prominently feature animals such as birds, eagles or mythological creatures.
    const animalNames = [
      'Albania','Mexico','Moldova','Montenegro','Serbia','Zambia','Papua New Guinea','Zimbabwe','Uganda','Ecuador','Bolivia','Kazakhstan','Bhutan','Fiji','Belize','Samoa','Sri Lanka'
    ];
    const animalFlags = entriesFromNames(animalNames);
    if (animalFlags.length >= 4) connectionsThemes.push({ name: 'Flags with animals', flags: animalFlags, type: 'animal' });

    // ----- Flags with crescents -----
    // Countries whose flags contain a crescent (often associated with Islamic nations).
    const crescentNames = [
      'Turkey','Pakistan','Tunisia','Algeria','Mauritania','Azerbaijan','Turkmenistan','Malaysia','Maldives','Libya','Comoros'
    ];
    const crescentFlags = entriesFromNames(crescentNames);
    if (crescentFlags.length >= 4) connectionsThemes.push({ name: 'Flags with crescents', flags: crescentFlags, type: 'crescent' });

    // ----- Flags with coat of arms -----
    // Countries whose national flags display a coat of arms or elaborate shield at the centre or off-centre.
    const coatNames = [
      'Spain','Portugal','Andorra','Moldova','Montenegro','Croatia','Serbia','Slovakia','Slovenia','San Marino','Ecuador','Panama','Mexico','Bolivia','Guatemala','Paraguay'
    ];
    const coatFlags = entriesFromNames(coatNames);
    if (coatFlags.length >= 4) connectionsThemes.push({ name: 'Flags with coat of arms', flags: coatFlags, type: 'coat' });

    // ----- Flags with suns -----
    // Countries whose flags contain a sun, sunburst or rays motif.
    const sunNames = [
      'Argentina','Uruguay','Kazakhstan','Philippines','Rwanda','Namibia','Malawi','Kyrgyzstan','Myanmar','Taiwan','Japan','Bangladesh','North Macedonia'
    ];
    const sunFlags = entriesFromNames(sunNames);
    if (sunFlags.length >= 4) connectionsThemes.push({ name: 'Flags with suns', flags: sunFlags, type: 'sun' });
  }

  // ----- Flag Connections Game Implementation -----
  // Data structures for the current connections round. These variables are
  // reset whenever a new round of the connections game starts.
  let connectionsCurrentThemes = [];
  let connectionsGridData = [];
  let connectionsSelected = [];
  let connectionsSolved = [];

  // ----- Odd One Out Game Implementation -----
  // Data for the current round of the odd one out game. Each round consists of
  // four cards: three from one theme and one random intruder flag. The data
  // structures here are reset whenever a new round begins.
  let oddGridData = [];
  // Currently selected card element in the odd one out game (null if none)
  let oddSelected = null;

  /**
   * Start the Odd One Out mode. This function hides any UI from other game
   * modes, resets the score counters, ensures that the connections theme
   * categories are available, and sets up the first round of odd one out.
   */
  async function startOdd() {
    // Set mode and reset score counters
    state.mode = 'odd';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = 0;
    streakEl.textContent = 0;
    // Reset mistake counters for odd mode and read unlimited setting
    state.oddMistakesUsed = 0;
    state.oddUnlimitedMistakes = unlimitedOddMistakesToggle && unlimitedOddMistakesToggle.checked;
    // Hide panels and controls from other modes
    // Hide region panel when entering odd mode
    regionPanel.classList.add('hidden');
    drawHeader.classList.add('hidden');
    drawControls.classList.add('hidden');
    connectionsPanel.classList.add('hidden');
    canvas.classList.add('hidden');
    resultEl.classList.add('hidden');
    resultEl.innerHTML = '';
    answer.classList.add('hidden');
    answer.disabled = true;
    submitBtn.classList.add('hidden');
    submitBtn.disabled = true;
    revealBtn.classList.add('hidden');
    nextBtn.classList.add('hidden');
    revealBtn.disabled = true;
    nextBtn.disabled = true;
    learnPanel.classList.add('hidden');
    // Hide mistakes UI from connections mode
    mistakesRow.classList.add('hidden');
    mistakesPill.classList.add('hidden');
    // Show odd panel
    oddPanel.classList.remove('hidden');
    // Hide and reset odd-specific elements
    if (oddNext) { oddNext.classList.add('hidden'); oddNext.disabled = false; }
    oddStatus.textContent = '';
    oddSubmit.disabled = true;
    oddGrid.innerHTML = '';
    // Ensure the odd grid click handler is attached fresh for each new game.  Remove any previous handler and reattach it.
    oddGrid.removeEventListener('click', onOddCardClick);
    oddGrid.addEventListener('click', onOddCardClick);
    // Update the odd instructions and global instructions
    if (oddInstructionsEl) {
      oddInstructionsEl.innerHTML = '';
    }
    if (gameInstructions) {
      gameInstructions.innerHTML = '<b>Odd One Out:</b> Three of the four flags share a category; one does not. Select the flag that doesn\'t belong. You have <b>2</b> mistakes by default. Enable the unlimited setting to keep playing as long as you like.' +
        '<br><br><b>Possible category types:</b>' +
        '<ul>' +
        '<li><b>By First Letter</b>: Countries starting with the same letter</li>' +
        '<li><b>By Last Letter</b>: Countries ending with the same letter</li>' +
        '<li><b>By Name Length</b>: Countries whose names have the same number of letters</li>' +
        '<li><b>By Continent or Region</b>: Countries from the same continent or subregion</li>' +
        '<li><b>By Colour</b>: Flags that contain a common colour (red, green, blue, etc.)</li>' +
        '<li><b>By Tricolour</b>: Flags with three equal stripes</li>' +
        '<li><b>Flags with Weapons</b>: Flags featuring swords, rifles or other weapons</li>' +
        '<li><b>Flags with Crosses</b>: Flags featuring crosses or cross patterns</li>' +
        '<li><b>Flags with Animals</b>: Flags displaying animals, birds or mythical creatures</li>' +
        '<li><b>Flags with Crescents</b>: Flags containing crescent shapes</li>' +
        '<li><b>Flags with Coat of Arms</b>: Flags bearing coats of arms or shields</li>' +
        '<li><b>Flags with Suns</b>: Flags featuring sun emblems or rays</li>' +
        '<li><b>By Language</b>: Countries sharing an official language (English, French, Spanish, etc.)</li>' +
        '<li><b>By Population Size</b>: Top 30 or bottom 30 countries by population</li>' +
        '<li><b>By Land Area</b>: Top 30 or bottom 30 countries by land area</li>' +
        '<li><b>By Keyword</b>: Names containing a common word (Islands, Republic, New, Guinea, Stan, etc.)</li>' +
        '</ul>';
    }
    // Build themes if necessary
    await ensureConnectionsThemes();
    // Update mistakes display (shows circles or pill) now that state is initialised
    updateOddMistakesDisplay();
    // Start first round
    buildOddRound();
    // Update mode display
    if (modeDisplay && modeNames[state.mode]) {
      modeDisplay.innerHTML = modeNames[state.mode];
    }
  }

  /**
   * Build a new round for the odd one out game. Randomly selects a theme from
   * the available connections themes and chooses three flags from that theme.
   * Then picks one additional random flag from the UN pool that is not part
   * of the selected theme. These four flags are shuffled and rendered into
   * the odd one out grid. The odd flag is marked via a data attribute for
   * later evaluation.
   */
  function buildOddRound() {
    oddGridData = [];
    oddSelected = null;
    // Hide the next button and reset its disabled state
    if (oddNext) {
      oddNext.classList.add('hidden');
      oddNext.disabled = false;
    }
    oddGrid.innerHTML = '';
    oddSubmit.disabled = true;
    oddStatus.textContent = '';
    // Filter themes with at least three flags
    const validThemes = connectionsThemes.filter(t => Array.isArray(t.flags) && t.flags.length >= 3);
    if (validThemes.length === 0) {
      oddStatus.innerHTML = '<span class="bad">Not enough themes for odd one out.</span>';
      return;
    }
    const theme = validThemes[Math.floor(Math.random() * validThemes.length)];
    const pool = shuffle(theme.flags.slice());
    const chosen = [];
    const usedNames = new Set();
    for (const e of pool) {
      if (!usedNames.has(e.name)) {
        chosen.push(e);
        usedNames.add(e.name);
      }
      if (chosen.length >= 3) break;
    }
    // Flags outside theme
    const outsiders = dataUN.filter(e => !theme.flags.some(f => f.name === e.name));
    if (outsiders.length === 0) {
      oddStatus.innerHTML = '<span class="bad">Cannot find odd flag.</span>';
      return;
    }
    const oddEntry = outsiders[Math.floor(Math.random() * outsiders.length)];
    const items = chosen.map(e => ({ entry: e, odd: false, theme: theme.name }));
    items.push({ entry: oddEntry, odd: true, theme: theme.name });
    shuffle(items);
    oddGridData = items;
    items.forEach((item, idx) => {
      const card = document.createElement('div');
      card.className = 'flag-card';
      card.dataset.idx = idx;
      card.dataset.odd = item.odd ? 'true' : 'false';
      card.dataset.theme = item.theme;
      const img = document.createElement('img');
      img.src = item.entry.flag;
      img.alt = item.entry.name;
      img.loading = 'lazy';
      card.appendChild(img);
      oddGrid.appendChild(card);
    });
  }

  /**
   * Handler for selecting a flag in the odd one out game. Only one card
   * can be selected at a time. Clicking the same card again will deselect it.
   */
  function onOddCardClick(e) {
    const card = e.target.closest('.flag-card');
    if (!card) return;
    if (oddSelected === card) {
      card.classList.remove('selected');
      oddSelected = null;
      oddSubmit.disabled = true;
      return;
    }
    if (oddSelected) {
      oddSelected.classList.remove('selected');
    }
    card.classList.add('selected');
    oddSelected = card;
    oddSubmit.disabled = false;
  }

  /**
   * Evaluate the selected card in the odd one out game. If the selection
   * matches the intruder flag (dataset.odd === 'true'), increment correct
   * and streak counters. Otherwise, reset the streak. After evaluation,
   * highlight the odd flag and then build a new round after a short delay.
   */
  function submitOdd() {
    if (!oddSelected) return;
    // Determine if the selected card is the intruder
    const isOdd = oddSelected.dataset.odd === 'true';
    // Find the true odd entry and its details
    const oddItem = oddGridData.find(item => item.odd);
    const category = oddItem ? oddItem.theme : '';
    const oddName = oddItem && oddItem.entry ? oddItem.entry.name : '';

    // Case: correct selection
    if (isOdd) {
      // Increase score and streak
      state.ok++;
      state.streak++;
      // Update scoreboard
      okEl.textContent = state.ok;
      streakEl.textContent = state.streak;
      // Highlight the odd flag and clear others
      oddGrid.querySelectorAll('.flag-card').forEach(card => {
        card.classList.remove('selected');
        card.style.outline = '';
        if (card.dataset.odd === 'true') {
          card.style.outline = '3px solid var(--bad)';
        }
      });
      // Build and display message with category and odd name
      let message = `<span style="color:var(--ok)">✔️ Correct!</span>`;
      if (category) message += ` Category: <b>${category}</b>.`;
      if (oddName) message += ` Odd one out: <b style="color:var(--bad)">${oddName}</b>`;
      oddStatus.innerHTML = message;
      // Disable selection until next round
      oddGrid.removeEventListener('click', onOddCardClick);
      oddSubmit.disabled = true;
      // Show the next button
      if (oddNext) oddNext.classList.remove('hidden');
      return;
    }

    // Case: incorrect selection
    // Reset streak and increment mistakes used
    state.streak = 0;
    state.oddMistakesUsed++;
    // Update scoreboard
    okEl.textContent = state.ok;
    streakEl.textContent = state.streak;
    // Update mistakes display
    updateOddMistakesDisplay();
    // Determine if the player still has attempts left (either unlimited, or mistakes used < max)
    const attemptsLeft = state.oddUnlimitedMistakes || state.oddMistakesUsed < state.oddMaxMistakes;
    if (attemptsLeft) {
      // There are still chances remaining: allow another guess on the same puzzle.
      // Highlight the wrongly selected card in red, but do not reveal the odd one
      oddGrid.querySelectorAll('.flag-card').forEach(card => {
        card.classList.remove('selected');
        // Reset outline for all cards first
        if (!state.oddUnlimitedMistakes && state.oddMistakesUsed <= state.oddMaxMistakes) {
          // do nothing special here; we'll highlight the wrong selection below
        }
        card.style.outline = '';
      });
      // Highlight the chosen wrong card
      oddSelected.style.outline = '3px solid var(--bad)';
      // Clear selection so user must choose again
      oddSelected.classList.remove('selected');
      oddSelected = null;
      // Display message prompting the user to try again (without giving away the answer)
      oddStatus.innerHTML = `<span style="color:var(--bad)">✖️ Incorrect! Try again.</span>`;
      // Disable submit until a new selection is made
      oddSubmit.disabled = true;
      // Keep the click listener so the user can select again
      return;
    }
    // No attempts left: reveal the correct answer and end the round
    // Highlight the true odd card and also the wrong guess
    oddGrid.querySelectorAll('.flag-card').forEach(card => {
      card.classList.remove('selected');
      card.style.outline = '';
      if (card.dataset.odd === 'true') {
        card.style.outline = '3px solid var(--bad)';
      }
      // Also highlight the last wrong selection
      if (card === oddSelected) {
        card.style.outline = '3px solid var(--bad)';
      }
    });
    // Build message: incorrect and reveal category and odd
    let msg = `<span style="color:var(--bad)">✖️ Incorrect!</span>`;
    if (category) msg += ` Category: <b>${category}</b>.`;
    if (oddName) msg += ` Odd one out: <b style="color:var(--bad)">${oddName}</b>`;
    // Show game over message
    msg += ` <span class="bad">No mistakes remaining. Press <b>Next</b> to play again.</span>`;
    oddStatus.innerHTML = msg;
    // Disable grid interaction and submit button
    oddGrid.removeEventListener('click', onOddCardClick);
    oddSubmit.disabled = true;
    // Show and enable the next button so the user can continue
    if (oddNext) {
      oddNext.classList.remove('hidden');
      oddNext.disabled = false;
    }
  }

  /**
   * Start the Flag Connections mode. This function resets relevant game
   * state, ensures that the theme categories have been built, hides other
   * game UI, and displays the connections panel. Once themes are ready it
   * generates a fresh round of 4 hidden themes and 16 flags.
   */
  async function startConnections() {
    // Set mode and reset score counters
    state.mode = 'connections';
    state.ok = 0;
    state.streak = 0;
    okEl.textContent = state.ok;
    streakEl.textContent = state.streak;

    // Reset mistakes used for this round. This counter increases on each wrong guess.
    state.connectionsMistakesUsed = 0;
    // Update the mistakes display and scoreboard pill accordingly
    updateMistakesDisplay();
    // Hide other panels that are not used in connections mode
    // Hide region panel when entering connections mode
    regionPanel.classList.add('hidden');
    // Hide drawing header and controls
    drawHeader.classList.add('hidden');
    drawControls.classList.add('hidden');
    // Hide the canvas used for other modes
    canvas.classList.add('hidden');
    // Hide the answer input and disable it
    answer.classList.add('hidden');
    answer.disabled = true;
    // Disable reveal and next buttons
    revealBtn.disabled = true;
    nextBtn.disabled = true;
    // Clear and hide the result element
    resultEl.innerHTML = '';
    resultEl.classList.add('hidden');
    // Hide the learn/browse panel (so users cannot cheat by browsing the pool)
    learnPanel.classList.add('hidden');
    // Show the connections panel
    connectionsPanel.classList.remove('hidden');
    // Hide odd one out panel when entering connections mode
    oddPanel.classList.add('hidden');
    // Clear any previous solved groups and grid
    connectionsTop.innerHTML = '';
    connectionsGrid.innerHTML = '';
    // Clear any prior status messages (including HTML)
    connectionsStatus.innerHTML = '';
    // Disable submit button until exactly 4 selections are made
    connectionsSubmit.disabled = true;
    // Disable deselect button until there is at least one selection
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    // Hide the generic submit button used in other modes
    submitBtn.classList.add('hidden');
    submitBtn.disabled = true;
    // Build themes (if not already built)
    await ensureConnectionsThemes();
    // Generate a new round
    buildConnectionsRound();

    // Update mode and instructions display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    if (gameInstructions) {
      gameInstructions.innerHTML = '<b>Flag Connections:</b> Create four groups of four flags that share common themes. Select exactly four flags and click <b>Submit</b> to see if they form a correct group. You have four mistakes by default; enable unlimited mistakes in settings to continue playing.' +
        '<br><br><b>Possible category types:</b>' +
        '<ul>' +
        '<li><b>By First Letter</b>: Countries starting with the same letter</li>' +
        '<li><b>By Last Letter</b>: Countries ending with the same letter</li>' +
        '<li><b>By Name Length</b>: Countries whose names have the same number of letters</li>' +
        '<li><b>By Continent or Region</b>: Countries from the same continent or subregion</li>' +
        '<li><b>By Colour</b>: Flags that contain a common colour (red, green, blue, etc.)</li>' +
        '<li><b>By Tricolour</b>: Flags with three equal stripes</li>' +
        '<li><b>Flags with Weapons</b>: Flags featuring swords, rifles or other weapons</li>' +
        '<li><b>Flags with Crosses</b>: Flags featuring crosses or cross patterns</li>' +
        '<li><b>Flags with Animals</b>: Flags displaying animals, birds or mythical creatures</li>' +
        '<li><b>Flags with Crescents</b>: Flags containing crescent shapes</li>' +
        '<li><b>Flags with Coat of Arms</b>: Flags bearing coats of arms or shields</li>' +
        '<li><b>Flags with Suns</b>: Flags featuring sun emblems or rays</li>' +
        '<li><b>By Language</b>: Countries sharing an official language (English, French, Spanish, etc.)</li>' +
        '<li><b>By Population Size</b>: Top 30 or bottom 30 countries by population</li>' +
        '<li><b>By Land Area</b>: Top 30 or bottom 30 countries by land area</li>' +
        '<li><b>By Keyword</b>: Names containing a common word (Islands, Republic, New, Guinea, Stan, etc.)</li>' +
        '</ul>';
    }
  }

  /**
   * Generate a new round of the Flag Connections game. Chooses four distinct
   * themes at random from the available themes and selects four unique
   * flags for each theme. The resulting 16 flags are shuffled and rendered
   * into the connections grid. Each flag card stores its theme name via a
   * data attribute so that selections can be evaluated later.
   */
  function buildConnectionsRound() {
    // Reset per‑round state
    connectionsCurrentThemes = [];
    connectionsGridData = [];
    connectionsSelected = [];
    connectionsSolved = [];
    // Clear UI
    connectionsTop.innerHTML = '';
    connectionsGrid.innerHTML = '';
    // Clear any status message from previous round
    connectionsStatus.innerHTML = '';
    connectionsSubmit.disabled = true;
    // Disable deselect button at the start of a round
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    // Randomly pick four unique themes that have not yet been solved.
    const themesPool = connectionsThemes.slice();
    shuffle(themesPool);
    const chosenThemes = [];
    while (themesPool.length > 0 && chosenThemes.length < 4) {
      const theme = themesPool.shift();
      // Ensure each chosen theme has at least 4 flags and avoid selecting more than one theme of the same type
      if (theme && Array.isArray(theme.flags) && theme.flags.length >= 4) {
        if (!chosenThemes.some(t => t.type === theme.type)) {
          chosenThemes.push(theme);
        }
      }
    }
    // If fewer than 4 themes were available, abort
    if (chosenThemes.length < 4) {
      connectionsStatus.innerHTML = '<span class="bad">Not enough themes to play.</span>';
      return;
    }
    connectionsCurrentThemes = chosenThemes;
    // Collect flags: pick up to 4 unique flags per theme. Avoid duplicates
    const usedNames = new Set();
    for (const t of chosenThemes) {
      // Shuffle the flags list before picking
      const list = shuffle(t.flags.slice());
      let added = 0;
      for (const e of list) {
        // Ensure we don't reuse the same country across multiple themes
        if (!usedNames.has(e.name)) {
          connectionsGridData.push({ theme: t.name, entry: e });
          usedNames.add(e.name);
          added++;
        }
        if (added >= 4) break;
      }
    }
    // If we ended up with more or less than 16 flags (due to duplicates),
    // adjust by trimming or adding additional flags from the same themes.
    // Trim extras
    if (connectionsGridData.length > 16) {
      connectionsGridData = connectionsGridData.slice(0, 16);
    }
    // Add missing flags by cycling through chosen themes
    let themeIndex = 0;
    while (connectionsGridData.length < 16) {
      const t = chosenThemes[themeIndex % chosenThemes.length];
      // Pick another flag not yet used
      for (const e of t.flags) {
        if (!usedNames.has(e.name)) {
          connectionsGridData.push({ theme: t.name, entry: e });
          usedNames.add(e.name);
          break;
        }
      }
      themeIndex++;
    }
    // Shuffle the final list to randomise placement
    shuffle(connectionsGridData);
    // Render each flag into the grid
    connectionsGridData.forEach((item, idx) => {
      const card = document.createElement('div');
      card.className = 'flag-card';
      card.dataset.idx = idx;
      card.dataset.theme = item.theme;
      card.dataset.solved = 'false';
      const img = document.createElement('img');
      img.src = item.entry.flag;
      img.alt = item.entry.name;
      img.loading = 'lazy';
      card.appendChild(img);
      connectionsGrid.appendChild(card);
    });
  }

  /**
   * Handler for clicking a flag card in the connections grid. Toggles the
   * selected state of the card (up to four selections at a time) and
   * updates the submit button accordingly.
   */
  function onConnectionsCardClick(e) {
    const card = e.target.closest('.flag-card');
    if (!card) return;
    // Ignore clicks on solved cards
    if (card.dataset.solved === 'true') return;
    // Toggle selection
    if (card.classList.contains('selected')) {
      card.classList.remove('selected');
      connectionsSelected = connectionsSelected.filter(x => x !== card);
    } else {
      if (connectionsSelected.length >= 4) {
        // Only allow up to 4 selections
        return;
      }
      card.classList.add('selected');
      connectionsSelected.push(card);
    }
    // Enable submit button only when exactly four cards are selected
    connectionsSubmit.disabled = connectionsSelected.length !== 4;
    // Enable or disable deselect button based on whether any selections are present
    if (connectionsDeselect) connectionsDeselect.disabled = connectionsSelected.length === 0;
  }

  /**
   * Shuffle the unsolved flag cards within the connections grid. Applies a
   * brief fade‑out effect before reordering the DOM to create a pleasing
   * visual shuffle. The selected state is cleared on shuffle.
   */
  function shuffleConnections() {
    // Collect unsolved cards
    const cards = Array.from(connectionsGrid.children).filter(card => card.dataset.solved !== 'true');
    // Clear any selections
    connectionsSelected.forEach(card => card.classList.remove('selected'));
    connectionsSelected = [];
    connectionsSubmit.disabled = true;
    // Disable deselect button since no cards are selected after shuffle
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    // Apply fade‑out
    cards.forEach(card => card.classList.add('fade-out'));
    // After the fade, reorder the cards randomly and fade back in
    setTimeout(() => {
      shuffle(cards);
      cards.forEach(card => connectionsGrid.appendChild(card));
      cards.forEach(card => card.classList.remove('fade-out'));
    }, 200);
  }

  /**
   * Remove all current selections in the connections grid. Used when the user
   * clicks the "Deselect All" button. Clears the selected state of each
   * card, empties the list of currently selected cards, disables the
   * submit and deselect buttons, and clears any status message.
   */
  function deselectConnections() {
    connectionsSelected.forEach(card => card.classList.remove('selected'));
    connectionsSelected = [];
    connectionsSubmit.disabled = true;
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    connectionsStatus.textContent = '';
  }

  /**
   * Evaluate the current selection of four cards. If all four belong to
   * the same theme, they are moved to the solved area with an overlay
   * showing the theme name. If three belong to the same theme and one
   * does not, a “One Away” hint is shown. Otherwise, the guess is marked
   * incorrect. After evaluation, selections are cleared.
   */
  function submitConnections() {
    if (connectionsSelected.length !== 4) {
      // Should not happen since the button is disabled otherwise
      return;
    }
    // Tally the themes of selected cards
    const counts = {};
    connectionsSelected.forEach(card => {
      const t = card.dataset.theme;
      counts[t] = (counts[t] || 0) + 1;
    });
    let bestTheme = null;
    let bestCount = 0;
    for (const [theme, count] of Object.entries(counts)) {
      if (count > bestCount) {
        bestTheme = theme;
        bestCount = count;
      }
    }
    // Clear any existing status
    connectionsStatus.textContent = '';
    // Evaluate guess
    if (bestCount === 4 && bestTheme) {
      // Correct connection found. Animate the cards into the solved area.
      connectionsStatus.innerHTML = `<span style="color:var(--ok)">✔️ ${bestTheme}</span>`;
      // Copy selected cards
      const origCards = connectionsSelected.slice();
      // Create group and overlay
      const group = document.createElement('div');
      group.className = 'connection-group new';
      origCards.forEach(card => {
        const imgSrc = card.querySelector('img').src;
        const imgAlt = card.querySelector('img').alt;
        const imgEl = document.createElement('img');
        imgEl.src = imgSrc;
        imgEl.alt = imgAlt;
        group.appendChild(imgEl);
      });
      const overlay = document.createElement('div');
      overlay.className = 'theme-overlay';
      overlay.textContent = bestTheme;
      group.appendChild(overlay);
      // Hide until animation finishes
      group.style.visibility = 'hidden';
      connectionsTop.appendChild(group);
      // Create clones for animation
      const clones = [];
      origCards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const img = card.querySelector('img');
        const clone = img.cloneNode(true);
        clone.style.position = 'fixed';
        clone.style.top = `${rect.top}px`;
        clone.style.left = `${rect.left}px`;
        clone.style.width = `${rect.width}px`;
        clone.style.height = `${rect.height}px`;
        clone.style.margin = '0';
        clone.style.zIndex = '100';
        clone.style.borderRadius = getComputedStyle(card).borderRadius;
        clone.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
        document.body.appendChild(clone);
        clones.push(clone);
        card.dataset.solved = 'true';
        card.classList.remove('selected');
      });
      // Animate clones to new positions
      requestAnimationFrame(() => {
        const finalImgs = group.querySelectorAll('img');
        finalImgs.forEach((finalImg, i) => {
          const finalRect = finalImg.getBoundingClientRect();
          const clone = clones[i];
          const origRect = origCards[i].getBoundingClientRect();
          const dx = finalRect.left - origRect.left;
          const dy = finalRect.top - origRect.top;
          const scaleX = finalRect.width / origRect.width;
          const scaleY = finalRect.height / origRect.height;
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
        });
        setTimeout(() => {
          group.style.visibility = '';
          clones.forEach(cl => cl.remove());
          origCards.forEach(card => card.remove());
        }, 650);
      });
      connectionsSolved.push(bestTheme);
      connectionsSelected = [];
      connectionsSubmit.disabled = true;
      // Disable deselect button since no cards are selected
      if (connectionsDeselect) connectionsDeselect.disabled = true;
      if (connectionsSolved.length === 4) {
        connectionsStatus.innerHTML = `<span style="color:var(--ok)">🎉 You solved all connections!</span>`;
      }
    } else {
      // Wrong or one-away guess. Decrement or increment mistakes count accordingly.
      // Determine if this guess is one away or completely wrong
      const oneAway = bestCount === 3;
      if (oneAway) {
        connectionsStatus.innerHTML = `<span style="color:var(--warn)">One Away!</span>`;
      } else {
        connectionsStatus.innerHTML = `<span style="color:var(--bad)">Not a connection.</span>`;
      }
      // Increase mistakes used count
      state.connectionsMistakesUsed++;
      // Update mistakes UI
      updateMistakesDisplay();
      // If unlimited mistakes disabled and mistakes exceed maxMistakes, end the game
      if (!state.unlimitedMistakes) {
        const remaining = (state.maxMistakes || 4) - state.connectionsMistakesUsed;
        if (remaining <= 0) {
          // No more mistakes allowed: reveal all remaining connections and end the round.
          connectionsStatus.innerHTML = `<span style="color:var(--bad)">No mistakes remaining.</span>`;
          // Animate and reveal all unsolved connections, then disable further interaction.
          revealAllConnections();
          return;
        }
      }
      // Clear selections for next guess
      connectionsSelected.forEach(card => card.classList.remove('selected'));
      connectionsSelected = [];
      connectionsSubmit.disabled = true;
      // Disable deselect button as no cards are selected
      if (connectionsDeselect) connectionsDeselect.disabled = true;
    }
  }

  /**
   * Update the colour swatch to reflect the currently selected brush colour.
   * Sets both the swatch background and border to the brush colour for
   * easy visual reference.
   */
  function updateSwatch() {
    if (!colorSwatch) return;
    const col = drawColor.value;
    colorSwatch.style.backgroundColor = col;
    colorSwatch.style.borderColor = col;
  }

  /**
   * Reveal all remaining connections when the player runs out of mistakes.
   * This function groups the unsolved flags by their theme and moves them
   * into the solved area with the same animation used for correct guesses.
   * After revealing all connections, the grid is disabled so the user
   * cannot make further selections in the current round.
   */
  function revealAllConnections() {
    // Gather all unsolved cards (those not already marked as solved)
    const unsolved = Array.from(connectionsGrid.children).filter(card => card.dataset.solved !== 'true');
    if (unsolved.length === 0) {
      return;
    }
    // Group cards by their theme name
    const groups = {};
    unsolved.forEach(card => {
      const theme = card.dataset.theme;
      if (!groups[theme]) groups[theme] = [];
      groups[theme].push(card);
    });
    // For each theme group, animate the cards into the solved area
    Object.keys(groups).forEach(theme => {
      const cards = groups[theme];
      if (!cards || cards.length === 0) return;
      // Create solved group container and overlay
      const group = document.createElement('div');
      group.className = 'connection-group new';
      // Add flag images to the group
      cards.forEach(card => {
        const img = card.querySelector('img');
        const imgEl = document.createElement('img');
        imgEl.src = img.src;
        imgEl.alt = img.alt;
        group.appendChild(imgEl);
      });
      const overlay = document.createElement('div');
      overlay.className = 'theme-overlay';
      overlay.textContent = theme;
      group.appendChild(overlay);
      group.style.visibility = 'hidden';
      connectionsTop.appendChild(group);
      // Create clones for animation
      const clones = [];
      cards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const img = card.querySelector('img');
        const clone = img.cloneNode(true);
        clone.style.position = 'fixed';
        clone.style.top = `${rect.top}px`;
        clone.style.left = `${rect.left}px`;
        clone.style.width = `${rect.width}px`;
        clone.style.height = `${rect.height}px`;
        clone.style.margin = '0';
        clone.style.zIndex = '100';
        clone.style.borderRadius = getComputedStyle(card).borderRadius;
        clone.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
        document.body.appendChild(clone);
        clones.push(clone);
        // Mark original card as solved and remove selected state
        card.dataset.solved = 'true';
        card.classList.remove('selected');
      });
      // Start animation on next frame
      requestAnimationFrame(() => {
        const finalImgs = group.querySelectorAll('img');
        finalImgs.forEach((finalImg, i) => {
          const finalRect = finalImg.getBoundingClientRect();
          const origRect = cards[i].getBoundingClientRect();
          const dx = finalRect.left - origRect.left;
          const dy = finalRect.top - origRect.top;
          const scaleX = finalRect.width / origRect.width;
          const scaleY = finalRect.height / origRect.height;
          const clone = clones[i];
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
        });
        setTimeout(() => {
          group.style.visibility = '';
          clones.forEach(cl => cl.remove());
          cards.forEach(card => card.remove());
        }, 650);
      });
    });
    // Clear any selections and disable further interaction with the grid
    connectionsSelected.forEach(card => card.classList.remove('selected'));
    connectionsSelected = [];
    connectionsSubmit.disabled = true;
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    if (connectionsShuffle) connectionsShuffle.disabled = true;
    // Remove click handlers from all cards
    connectionsGrid.querySelectorAll('.flag-card').forEach(card => {
      card.removeEventListener('click', onConnectionsCardClick);
    });
  }

  /**
   * Generate a palette of colours extracted directly from a flag image.
   *
   * Unlike the coarse classification approach, this function performs a
   * simple quantisation of all pixels to identify the actual colours
   * present in the flag. The flag image is drawn into an offscreen
   * canvas, and each pixel is quantised into a lower resolution
   * colour space by rounding the R, G and B channels to the nearest
   * multiple of 32 (i.e. 5 bits per channel). This allows similar
   * shades to be grouped together while still preserving the variety
   * of distinct colours. For each quantised colour cluster the
   * average of the original RGB values is computed. The resulting
   * palette is sorted by frequency (most common colours first) and
   * used to populate the <datalist> for the brush colour picker. The
   * first colour in the list is also set as the current brush colour.
   *
   * @param {string} url URL of the flag image to sample
   */
  function generatePaletteForFlag(url) {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = function() {
      // Create an offscreen canvas to sample colours.  A modest
      // resolution balances detail with performance.
      const off = document.createElement('canvas');
      off.width = 200;
      off.height = 120;
      const octx = off.getContext('2d');
      // Draw the flag onto the offscreen canvas. Aspect ratio
      // preservation is not critical for colour sampling.
      octx.drawImage(img, 0, 0, off.width, off.height);
      const pixels = octx.getImageData(0, 0, off.width, off.height).data;
      // Map of quantised colour keys to aggregated stats
      const clusters = {};
      for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i], g = pixels[i + 1], b = pixels[i + 2];
        // Quantise each channel to 5 bits (0-255 -> 0-255 in steps of 32)
        const qR = Math.round(r / 32) * 32;
        const qG = Math.round(g / 32) * 32;
        const qB = Math.round(b / 32) * 32;
        const key = `${qR},${qG},${qB}`;
        if (!clusters[key]) {
          clusters[key] = { sumR: 0, sumG: 0, sumB: 0, count: 0 };
        }
        clusters[key].sumR += r;
        clusters[key].sumG += g;
        clusters[key].sumB += b;
        clusters[key].count++;
      }
      // Convert clusters into an array of {hex, count} objects
      const palette = Object.keys(clusters).map(key => {
        const { sumR, sumG, sumB, count } = clusters[key];
        const avgR = Math.round(sumR / count);
        const avgG = Math.round(sumG / count);
        const avgB = Math.round(sumB / count);
        const hex = '#' + [avgR, avgG, avgB]
          .map(c => c.toString(16).padStart(2, '0'))
          .join('');
        return { hex, count };
      });
      // Sort by descending frequency (largest clusters first) then
      // lexicographically for deterministic ordering
      palette.sort((a, b) => b.count - a.count || a.hex.localeCompare(b.hex));
      // Limit the palette to a reasonable number of colours (e.g. 8)
      const colors = palette.slice(0, 8).map(p => p.hex);
      const list = document.getElementById('flagColors');
      if (list) {
        list.innerHTML = colors.map(col => `<option value="${col}"></option>`).join('');
      }
      // Update the brush colour to the first colour in the palette
      if (colors.length > 0) {
        drawColor.value = colors[0];
        ctx.strokeStyle = drawColor.value;
        updateSwatch();
      }

  /**
   * Reveal all remaining connections when the player runs out of mistakes.
   * This function groups the unsolved flags by their theme and moves them
   * into the solved area with the same animation used for correct guesses.
   * After revealing all connections, the grid is disabled so the user
   * cannot make further selections in the current round.
   */
  function revealAllConnections() {
    // Gather all unsolved cards (those not already marked as solved)
    const unsolved = Array.from(connectionsGrid.children).filter(card => card.dataset.solved !== 'true');
    if (unsolved.length === 0) {
      return;
    }
    // Group cards by their theme name
    const groups = {};
    unsolved.forEach(card => {
      const theme = card.dataset.theme;
      if (!groups[theme]) groups[theme] = [];
      groups[theme].push(card);
    });
    // For each theme group, animate the cards into the solved area
    Object.keys(groups).forEach(theme => {
      const cards = groups[theme];
      if (!cards || cards.length === 0) return;
      // Create solved group container and overlay
      const group = document.createElement('div');
      group.className = 'connection-group new';
      // Add flag images to the group
      cards.forEach(card => {
        const img = card.querySelector('img');
        const imgEl = document.createElement('img');
        imgEl.src = img.src;
        imgEl.alt = img.alt;
        group.appendChild(imgEl);
      });
      const overlay = document.createElement('div');
      overlay.className = 'theme-overlay';
      overlay.textContent = theme;
      group.appendChild(overlay);
      group.style.visibility = 'hidden';
      connectionsTop.appendChild(group);
      // Create clones for animation
      const clones = [];
      cards.forEach(card => {
        const rect = card.getBoundingClientRect();
        const img = card.querySelector('img');
        const clone = img.cloneNode(true);
        clone.style.position = 'fixed';
        clone.style.top = `${rect.top}px`;
        clone.style.left = `${rect.left}px`;
        clone.style.width = `${rect.width}px`;
        clone.style.height = `${rect.height}px`;
        clone.style.margin = '0';
        clone.style.zIndex = '100';
        clone.style.borderRadius = getComputedStyle(card).borderRadius;
        clone.style.transition = 'transform 0.6s ease, opacity 0.6s ease';
        document.body.appendChild(clone);
        clones.push(clone);
        // Mark original card as solved and remove selected state
        card.dataset.solved = 'true';
        card.classList.remove('selected');
      });
      // Start animation on next frame
      requestAnimationFrame(() => {
        const finalImgs = group.querySelectorAll('img');
        finalImgs.forEach((finalImg, i) => {
          const finalRect = finalImg.getBoundingClientRect();
          const origRect = cards[i].getBoundingClientRect();
          const dx = finalRect.left - origRect.left;
          const dy = finalRect.top - origRect.top;
          const scaleX = finalRect.width / origRect.width;
          const scaleY = finalRect.height / origRect.height;
          const clone = clones[i];
          clone.style.transform = `translate(${dx}px, ${dy}px) scale(${scaleX}, ${scaleY})`;
        });
        setTimeout(() => {
          group.style.visibility = '';
          clones.forEach(cl => cl.remove());
          cards.forEach(card => card.remove());
        }, 650);
      });
    });
    // Clear any selections and disable further interaction with the grid
    connectionsSelected.forEach(card => card.classList.remove('selected'));
    connectionsSelected = [];
    connectionsSubmit.disabled = true;
    if (connectionsDeselect) connectionsDeselect.disabled = true;
    if (connectionsShuffle) connectionsShuffle.disabled = true;
    // Remove click handlers from all cards
    connectionsGrid.querySelectorAll('.flag-card').forEach(card => {
      card.removeEventListener('click', onConnectionsCardClick);
    });
  }
    };
    img.onerror = function() {
      // On error, clear the datalist to avoid stale entries
      const list = document.getElementById('flagColors');
      if (list) list.innerHTML = '';
    };
    img.src = url;
  }

  function submit(){
    if(state.mode==='draw'){
      // In draw-from-memory mode, evaluate similarity between the drawn flag and the real flag
      if(!state.current) return;
      // Disable submit button to prevent multiple submissions
      submitBtn.disabled = true;
      try {
        const drawnData = ctx.getImageData(0,0,canvas.width,canvas.height).data;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function() {
          const off = document.createElement('canvas');
          off.width = canvas.width;
          off.height = canvas.height;
          const octx = off.getContext('2d');
          octx.drawImage(img, 0, 0, off.width, off.height);
          const flagData = octx.getImageData(0,0,off.width,off.height).data;
          // Compute colour-category similarity instead of raw RGB differences.  For each pixel
          // classify both the drawn and the real flag colours into coarse categories
          // (white, black, red, yellow, green, blue) and count matches.  The final
          // percentage is the fraction of pixels whose categories match.
          let matchesCount = 0;
          const totalPixels = drawnData.length / 4;
          for(let i=0; i<drawnData.length; i+=4){
            const dc = classifyColor(drawnData[i], drawnData[i+1], drawnData[i+2]);
            const fc = classifyColor(flagData[i], flagData[i+1], flagData[i+2]);
            if(dc === fc) matchesCount++;
          }
          const closeness = totalPixels > 0 ? matchesCount / totalPixels : 0;
          const percent = closeness * 100;
          // Show similarity and also display the actual flag image below.
          const score = percent.toFixed(2);
          resultEl.innerHTML =
            'Your drawing matches the real flag by ' + score + '%'
            + '<br><span class="warn">Actual Flag:</span><br>'
            + '<img src="' + state.current.flag + '" style="max-width:100%;border-radius:8px;margin-top:4px;">';
          // Show the Next button to allow proceeding to another flag
          nextBtn.classList.remove('hidden');
          nextBtn.disabled = false;
          // Keep reveal button hidden in draw mode
          revealBtn.classList.add('hidden');
          revealBtn.disabled = true;
        };
        img.onerror = function() {
          // On error computing similarity, inform the user and show the real flag anyway
          resultEl.innerHTML = 'Could not compute similarity.'
            + '<br><span class="warn">Actual Flag:</span><br>'
            + '<img src="' + state.current.flag + '" style="max-width:100%;border-radius:8px;margin-top:4px;">';
          nextBtn.classList.remove('hidden');
          nextBtn.disabled = false;
        };
        img.src = state.current.flag;
      } catch(err) {
        // Generic error computing similarity: show message and real flag
        resultEl.innerHTML = 'Could not compute similarity.'
          + '<br><span class="warn">Actual Flag:</span><br>'
          + '<img src="' + state.current.flag + '" style="max-width:100%;border-radius:8px;margin-top:4px;">';
        nextBtn.classList.remove('hidden');
        nextBtn.disabled = false;
      }
      return;
    } else if(state.mode==='classic' || state.mode==='endless'){
      if(!state.current) return;
      const val=answer.value.trim(); if(!val) return; answer.value='';
      if(matches(val,state.current)){
        // correct answer: increment counters and move to next flag
        state.ok++; state.streak++;
        okEl.textContent = state.ok;
        streakEl.textContent = state.streak;
        if(state.mode === 'endless'){
          resultEl.innerHTML = `<span class="ok">Correct!</span>`;
        } else {
          resultEl.innerHTML = `<span class="ok">Correct!</span> ${state.current.name}`;
        }
        nextFlag();
      } else {
        // incorrect guess
        state.streak = 0;
        streakEl.textContent = 0;
        if(state.mode === 'endless'){
          // In endless mode, end the game and display Game Over on the canvas
          resultEl.innerHTML = `<span class="bad">Game Over</span>`;
          answer.disabled = true;
          submitBtn.disabled = true;
          revealBtn.disabled = true;
          nextBtn.disabled = true;
          // Clear canvas and draw Game Over text
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bad') || '#fb7185';
          ctx.font = 'bold 48px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Game Over', canvas.width/2, canvas.height/2);
        } else {
          resultEl.innerHTML = `<span class="bad">Nope.</span> (${state.current.name})`;
          if(state.effectsCurrent.six && state.piecesRevealed<6){ state.piecesRevealed++; renderCurrent(); }
        }
      }
      answer.focus();
    } else if(state.mode==='memory'){
      const seq=state.memory.sequence; const idx=state.memory.index; if(idx>=seq.length) return;
      const val=answer.value.trim(); if(!val) return; answer.value='';
      if(matches(val,seq[idx])){
        state.memory.index++;
        if(state.memory.index===seq.length){ resultEl.innerHTML='<span class="ok">You nailed all 5!</span>'; }
        else { resultEl.innerHTML=`<span class="ok">Correct</span> — ${idx+1}/5`; }
      } else {
        resultEl.innerHTML = `<span class="bad">Wrong at #${idx+1}.</span> Correct order: ${seq.map(e=>e.name).join(' • ')}`;
        state.mode='classic';
      }
      answer.focus();
    }
  }

  async function startMemory(){
    state.mode='memory'; resultEl.textContent='';
    // Hide draw header in memory mode
    drawHeader.classList.add('hidden');
    // Hide region panel and connections panel when entering memory mode
    regionPanel.classList.add('hidden');
    // Hide connections panel when entering memory mode
    connectionsPanel.classList.add('hidden');
    // Hide odd one out panel when entering memory mode
    oddPanel.classList.add('hidden');
    // Ensure canvas and result area are visible
    canvas.classList.remove('hidden');
    resultEl.classList.remove('hidden');
    // Show the generic submit button for memory mode (disabled until ready)
    submitBtn.classList.remove('hidden');
    // Ensure the answer input is visible and drawing controls are hidden when entering memory mode
    answer.classList.remove('hidden');
    drawControls.classList.add('hidden');
    // Ensure controls and learn panel are visible when entering memory mode
    revealBtn.classList.remove('hidden');
    nextBtn.classList.remove('hidden');
    learnPanel.classList.remove('hidden');
    // Update mode display
    if (modeDisplay) modeDisplay.innerHTML = modeNames[state.mode];
    // Update instructions for memory mode
    if (gameInstructions) {
      gameInstructions.innerHTML = '<b>Memory Quiz:</b> Memorise the sequence of flags shown, then type them in the correct order. Each flag appears briefly. Use <b>Submit</b> after each guess.';
    }
    const src=shuffle(getSource().slice()); state.memory.sequence=src.slice(0,5); state.memory.index=0;
    answer.disabled=true; submitBtn.disabled=true; revealBtn.disabled=true; nextBtn.disabled=true;
    const delay=ms=>new Promise(r=>setTimeout(r,ms));
    for(const e of state.memory.sequence){
      state.effectsCurrent = JSON.parse(JSON.stringify(state.effectsPending));
      drawFlag(e);
      await delay(state.timerMs===Infinity?700:Math.max(10,state.timerMs));
      ctx.clearRect(0,0,canvas.width,canvas.height);
      await delay(250);
    }
    resultEl.innerHTML='Type the 5 flags <b>in order</b> and press Enter after each.';
    answer.disabled=false; submitBtn.disabled=false; answer.value=''; answer.focus();
    revealBtn.disabled=false; nextBtn.disabled=false;
  }

  function updateTimer(){ if(timerInfinite.checked){ state.timerMs=Infinity; timerVal.textContent='∞'; } else { const v=parseFloat(timerRange.value||'5'); state.timerMs=Math.round(Math.max(0.01,Math.min(5,v))*1000); timerVal.textContent=(state.timerMs/1000).toFixed(2)+'s'; } }

  function syncPendingFromUI(){
    const p = state.effectsPending;
    p.blurOn = blurToggle.checked; p.blurPx = +blurRange.value; blurVal.textContent = p.blurPx+"px";
    p.pixelOn = pixelToggle.checked; p.pixel = +pixelRange.value; pixelVal.textContent = String(p.pixel);
    p.zoomOn = zoomToggle.checked; p.zoom = +zoomRange.value; zoomVal.textContent = p.zoom.toFixed(1)+"×";
    p.six = sixToggle.checked;
    p.randColor = randColorToggle.checked;
    p.gs = +gsRange.value; gsVal.textContent = p.gs.toFixed(2);
    p.inv = +invRange.value; invVal.textContent = p.inv.toFixed(2);
    p.hue = +hueRange.value; hueVal.textContent = p.hue+"°";
    p.sat = +satRange.value; satVal.textContent = p.sat.toFixed(2)+"×";
    p.con = +conRange.value; conVal.textContent = p.con.toFixed(2)+"×";
  }

  function onEffectUIChange(){
    syncPendingFromUI();
    document.getElementById('applyNote').classList.remove('hidden');
    // Update the preview canvas so users can see the new effects immediately
    updatePreview();
  }

  settingsBtn.addEventListener('click',()=>settingsPanel.classList.toggle('hidden'));
  closeSettings.addEventListener('click',()=>settingsPanel.classList.add('hidden'));
  ['change','input'].forEach(ev=>{
    [blurToggle,blurRange,pixelToggle,pixelRange,zoomToggle,zoomRange,sixToggle,randColorToggle,gsRange,invRange,hueRange,satRange,conRange].forEach(el=>el.addEventListener(ev,onEffectUIChange));
  });

  timerInfinite.addEventListener('change', updateTimer);
  timerRange.addEventListener('input', ()=>{timerInfinite.checked=false; updateTimer();});
  updateTimer();
  syncPendingFromUI();

  uiBtn.addEventListener('click',()=>uiPanel.classList.toggle('hidden'));
  closeUi.addEventListener('click',()=>uiPanel.classList.add('hidden'));
  themeSelect.addEventListener('change',()=>{ document.documentElement.setAttribute('data-theme', themeSelect.value); });
  accentPicker.addEventListener('input',()=>{ document.documentElement.style.setProperty('--accent', accentPicker.value); });

  document.getElementById('flagCats').addEventListener('click',(e)=>{
    const b=e.target.closest('button[data-tab]');
    if(!b) return;
    const tab=b.dataset.tab;
    [...document.querySelectorAll('#flagCats button')].forEach(x=>x.classList.toggle('active', x===b));
    state.activeTab=tab;
    if(tab==='Custom'){ customSelect.classList.remove('hidden'); createCustomBtn.classList.remove('hidden'); buildCustomOptions(); }
    else { customSelect.classList.add('hidden'); createCustomBtn.classList.add('hidden'); }
    updateDatalist(); buildLearn(); resultEl.textContent='';
  });

  // Start button chooses a mode based on the game mode selector
  startBtn.addEventListener('click', () => {
    // Determine which mode has been chosen from the mode selector. Default to
    // classic if none is selected.
    const mode = modeSelect.value || 'classic';
    if (mode === 'memory') {
      startMemory();
    } else if (mode === 'endless') {
      startEndless();
    } else if (mode === 'draw') {
      startDraw();
    } else if (mode === 'connections') {
      startConnections();
    } else if (mode === 'odd') {
      startOdd();
    } else if (mode === 'region') {
      // Start the region snapshot mode
      startRegion();
    } else {
      // 'classic' and any unknown value fallback to the classic game mode
      startGame();
    }
  });
  nextBtn.addEventListener('click', () => {
    if(state.mode === 'draw'){
      nextDraw();
    } else {
      nextFlag();
    }
  });
  revealBtn.addEventListener('click', () => {
    if(!state.current) return;
    if(state.mode === 'draw'){
      // Show the actual flag for comparison in draw mode
      resultEl.innerHTML = `<span class="warn">Actual Flag:</span><br><img src="${state.current.flag}" style="max-width:100%;border-radius:8px;margin-top:4px;"><br>${state.current.name}`;
    } else {
      state.piecesRevealed = 6;
      renderCurrent();
      resultEl.innerHTML = `<span class="warn">Answer:</span> ${state.current.name}`;
    }
  });
  submitBtn.addEventListener('click', submit);
  // Region snapshot reset button starts a new random region
  regionResetBtn.addEventListener('click', () => {
    // Clear status and start a new region round
    regionStatus.textContent = '';
    // Remove any flags previously snapped onto the map (both draggable and non-draggable)
    regionMapEl.querySelectorAll('.flag-draggable').forEach(el => el.remove());
    // Build a new random region (by calling startRegion again).  This
    // resets the map, zoom animation and flags.
    // We call startRegion() here instead of buildRegion() so that
    // the cinematic zoom is replayed for the new region.
    startRegion();
    regionResetBtn.classList.add('hidden');
  });
  answer.addEventListener('keydown', e=>{ if(e.key==='Enter') submit(); });
  // removed memoryBtn click listener (replaced by mode selector)

  // Update the stroke colour whenever the user picks a new colour
  drawColor.addEventListener('input', () => {
    ctx.strokeStyle = drawColor.value;
    updateSwatch();
  });

  // Drawing logic for draw-from-memory mode
  let drawing = false;
  let lastX = 0;
  let lastY = 0;
  // Pointer-based drawing: capture pointer to avoid accidental
  // termination when the pointer leaves the canvas. We call
  // setPointerCapture on pointerdown and releasePointerCapture on
  // pointerup. The end of a drawing stroke is handled only on
  // pointerup.
  canvas.addEventListener('pointerdown', (e) => {
    // Prevent default touch behaviour such as scrolling or pinch‑zoom when
    // interacting with the drawing canvas. Without this, some mobile
    // browsers may treat touches on the canvas as gestures, meaning
    // pointer events never reach our handlers.
    e.preventDefault();
    if (state.mode !== 'draw') return;
    // Determine canvas coordinates
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * canvas.width / rect.width;
    const y = (e.clientY - rect.top) * canvas.height / rect.height;
    // Save state for undo before any drawing operation
    saveState();
    // Handle colour picker tool: sample the clicked pixel's colour and set brush
    if (currentTool === 'picker') {
      try {
        const pixel = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
        const hex = '#' + [pixel[0], pixel[1], pixel[2]].map(v => v.toString(16).padStart(2, '0')).join('');
        drawColor.value = hex;
        ctx.strokeStyle = hex;
        // Update swatch to reflect the picked colour
        updateSwatch();
        // Automatically revert to the previously selected tool for convenience
        selectTool(prevTool || 'pen');
      } catch(err) {
        console.warn('Eyedropper failed', err);
      }
      return;
    }
    // Handle fill bucket tool
    if (currentTool === 'fill') {
      // Fill the region starting at the clicked pixel
      floodFill(x, y);
      // No further drawing for fill tool
      return;
    }
    // If the current tool is a shape, prepare to draw a shape.  Use the
    // shapeTools array to identify all supported shape types.
    if (shapeTools.includes(currentTool)) {
      drawingShape = true;
      startX = x;
      startY = y;
      // Capture a snapshot of the canvas for previewing the shape
      try {
        shapePreviewImgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      } catch(err) {
        shapePreviewImgData = null;
      }
      // Use pointer capture so we continue receiving events
      try { canvas.setPointerCapture(e.pointerId); } catch(err) {}
      return;
    }
    // Freehand drawing or erasing tools
    drawing = true;
    try {
      canvas.setPointerCapture(e.pointerId);
    } catch(err) {}
    // Configure stroke styles
    if (currentTool === 'eraser') {
      // Use destination-out blending for the eraser. This will punch holes in
      // existing drawings regardless of brush colour. A solid stroke colour
      // must still be provided (black here) but is ignored when compositing.
      ctx.globalCompositeOperation = 'destination-out';
      ctx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      // Normal drawing uses the selected colour and source-over composition.
      ctx.globalCompositeOperation = 'source-over';
      ctx.strokeStyle = drawColor.value;
    }
    ctx.lineWidth = parseFloat(drawSize.value);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(x, y);
    lastX = x;
    lastY = y;
  });
  canvas.addEventListener('pointermove', (e) => {
    // Prevent default behaviour during pointer moves to avoid scrolling.
    // Especially on mobile, this ensures that dragging your finger
    // generates pointer events instead of panning the page.
    e.preventDefault();
    if (state.mode !== 'draw') return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * canvas.width / rect.width;
    const y = (e.clientY - rect.top) * canvas.height / rect.height;
    // Preview shapes while the pointer is down
    if (drawingShape) {
      // Restore the canvas to its state at the beginning of the shape
      if (shapePreviewImgData) {
        ctx.putImageData(shapePreviewImgData, 0, 0);
      }
      // Use a dashed stroke for previews
      ctx.save();
      ctx.setLineDash([6, 4]);
      ctx.lineWidth = parseFloat(drawSize.value);
      ctx.strokeStyle = drawColor.value;
      switch (currentTool) {
        case 'line':
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.stroke();
          break;
        case 'rect': {
          const w = x - startX;
          const h = y - startY;
          ctx.strokeRect(startX, startY, w, h);
          break;
        }
        case 'circle': {
          const dx = x - startX;
          const dy = y - startY;
          const radius = Math.sqrt(dx * dx + dy * dy);
          ctx.beginPath();
          ctx.arc(startX, startY, radius, 0, Math.PI * 2);
          ctx.stroke();
          break;
        }
        case 'ellipse': {
          const rx = (x - startX) / 2;
          const ry = (y - startY) / 2;
          const cx = startX + rx;
          const cy = startY + ry;
          ctx.beginPath();
          ctx.ellipse(cx, cy, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI * 2);
          ctx.stroke();
          break;
        }
        case 'triangle':
          // Draw a right‑angled triangle preview
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.lineTo(startX, y);
          ctx.closePath();
          ctx.stroke();
          break;
        case 'pentagon': {
          // Draw a pentagon preview based on bounding box percentages
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + 0.5 * w, startY); // top
          ctx.lineTo(startX + 1.0 * w, startY + 0.38 * h);
          ctx.lineTo(startX + 0.81 * w, startY + 1.0 * h);
          ctx.lineTo(startX + 0.19 * w, startY + 1.0 * h);
          ctx.lineTo(startX, startY + 0.38 * h);
          ctx.closePath();
          ctx.stroke();
          break;
        }
        case 'hexagon': {
          // Draw a hexagon preview based on bounding box percentages
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + 0.25 * w, startY); // top‑left slanted
          ctx.lineTo(startX + 0.75 * w, startY);
          ctx.lineTo(startX + 1.0 * w, startY + 0.5 * h);
          ctx.lineTo(startX + 0.75 * w, startY + 1.0 * h);
          ctx.lineTo(startX + 0.25 * w, startY + 1.0 * h);
          ctx.lineTo(startX, startY + 0.5 * h);
          ctx.closePath();
          ctx.stroke();
          break;
        }
        case 'star': {
          // Draw a five‑pointed star preview centred in the bounding box.
          const w = x - startX;
          const h = y - startY;
          const sx = startX;
          const sy = startY;
          const wAbs = Math.abs(w);
          const hAbs = Math.abs(h);
          const cx = sx + w / 2;
          const cy = sy + h / 2;
          // Outer radius based on the smaller dimension; inner radius at half the outer
          const outer = 0.5 * Math.min(wAbs, hAbs);
          const inner = outer * 0.5;
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const angle = -Math.PI / 2 + i * (2 * Math.PI / 5);
            const ox = cx + outer * Math.cos(angle);
            const oy = cy + outer * Math.sin(angle);
            if (i === 0) ctx.moveTo(ox, oy); else ctx.lineTo(ox, oy);
            const innerAngle = angle + Math.PI / 5;
            const ix = cx + inner * Math.cos(innerAngle);
            const iy = cy + inner * Math.sin(innerAngle);
            ctx.lineTo(ix, iy);
          }
          ctx.closePath();
          ctx.stroke();
          break;
        }
        case 'heart': {
          // Draw a heart preview inside the bounding box using Bézier curves.
          const w = x - startX;
          const h = y - startY;
          const sx = Math.min(startX, x);
          const sy = Math.min(startY, y);
          const wAbs = Math.abs(w);
          const hAbs = Math.abs(h);
          ctx.beginPath();
          ctx.moveTo(sx + 0.5 * wAbs, sy + 0.35 * hAbs);
          ctx.bezierCurveTo(sx + wAbs, sy, sx + wAbs, sy + 0.7 * hAbs, sx + 0.5 * wAbs, sy + hAbs);
          ctx.bezierCurveTo(sx, sy + 0.7 * hAbs, sx, sy, sx + 0.5 * wAbs, sy + 0.35 * hAbs);
          ctx.closePath();
          ctx.stroke();
          break;
        }
        case 'diamond': {
          // Draw a diamond (rhombus) preview based on bounding box.  The
          // diamond is essentially a rotated square defined by its
          // bounding box.  It uses four points: top, right, bottom and
          // left midpoints of the bounding box.
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + w / 2, startY);
          ctx.lineTo(startX + w, startY + h / 2);
          ctx.lineTo(startX + w / 2, startY + h);
          ctx.lineTo(startX, startY + h / 2);
          ctx.closePath();
          ctx.stroke();
          break;
        }
      }
      ctx.restore();
      return;
    }
    // Handle freehand drawing and erasing
    if (drawing && (currentTool === 'pen' || currentTool === 'eraser')) {
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x;
      lastY = y;
    }
  });
  function endDrawingEvent(e) {
    // Prevent default to avoid unintended scrolling on touch devices when lifting
    // the finger off the canvas. This mirrors the pointerdown and
    // pointermove handlers to fully disable browser gesture handling on
    // our drawing canvas.
    if (e) e.preventDefault();
    if (state.mode !== 'draw') return;
    // Finalize drawing shapes or freehand on pointer up
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * canvas.width / rect.width;
    const y = (e.clientY - rect.top) * canvas.height / rect.height;
    if (drawingShape) {
      drawingShape = false;
      // Restore the canvas to its snapshot before drawing the shape
      if (shapePreviewImgData) {
        ctx.putImageData(shapePreviewImgData, 0, 0);
      }
      ctx.globalCompositeOperation = 'source-over';
      ctx.lineWidth = parseFloat(drawSize.value);
      ctx.strokeStyle = drawColor.value;
      ctx.fillStyle = drawColor.value;
      switch (currentTool) {
        case 'line':
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.stroke();
          break;
        case 'rect': {
          const w = x - startX;
          const h = y - startY;
          if (document.getElementById('shapeFill').checked) {
            ctx.fillRect(startX, startY, w, h);
          }
          ctx.strokeRect(startX, startY, w, h);
          break;
        }
        case 'circle': {
          const dx = x - startX;
          const dy = y - startY;
          const radius = Math.sqrt(dx * dx + dy * dy);
          ctx.beginPath();
          ctx.arc(startX, startY, radius, 0, Math.PI * 2);
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'ellipse': {
          const rx = (x - startX) / 2;
          const ry = (y - startY) / 2;
          const cx = startX + rx;
          const cy = startY + ry;
          ctx.beginPath();
          ctx.ellipse(cx, cy, Math.abs(rx), Math.abs(ry), 0, 0, Math.PI * 2);
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'triangle':
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(x, y);
          ctx.lineTo(startX, y);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        case 'pentagon': {
          // Finalize pentagon shape
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + 0.5 * w, startY);
          ctx.lineTo(startX + 1.0 * w, startY + 0.38 * h);
          ctx.lineTo(startX + 0.81 * w, startY + 1.0 * h);
          ctx.lineTo(startX + 0.19 * w, startY + 1.0 * h);
          ctx.lineTo(startX, startY + 0.38 * h);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'hexagon': {
          // Finalize hexagon shape
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + 0.25 * w, startY);
          ctx.lineTo(startX + 0.75 * w, startY);
          ctx.lineTo(startX + 1.0 * w, startY + 0.5 * h);
          ctx.lineTo(startX + 0.75 * w, startY + 1.0 * h);
          ctx.lineTo(startX + 0.25 * w, startY + 1.0 * h);
          ctx.lineTo(startX, startY + 0.5 * h);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'star': {
          // Finalize star shape
          const w = x - startX;
          const h = y - startY;
          const wAbs = Math.abs(w);
          const hAbs = Math.abs(h);
          // Determine centre of bounding box
          const cx = startX + w / 2;
          const cy = startY + h / 2;
          const outer = 0.5 * Math.min(wAbs, hAbs);
          const inner = outer * 0.5;
          ctx.beginPath();
          for (let i = 0; i < 5; i++) {
            const angle = -Math.PI / 2 + i * (2 * Math.PI / 5);
            const ox = cx + outer * Math.cos(angle);
            const oy = cy + outer * Math.sin(angle);
            if (i === 0) ctx.moveTo(ox, oy); else ctx.lineTo(ox, oy);
            const innerAngle = angle + Math.PI / 5;
            const ix = cx + inner * Math.cos(innerAngle);
            const iy = cy + inner * Math.sin(innerAngle);
            ctx.lineTo(ix, iy);
          }
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'heart': {
          // Finalize heart shape
          const w = x - startX;
          const h = y - startY;
          const sx2 = Math.min(startX, x);
          const sy2 = Math.min(startY, y);
          const wAbs = Math.abs(w);
          const hAbs = Math.abs(h);
          ctx.beginPath();
          ctx.moveTo(sx2 + 0.5 * wAbs, sy2 + 0.35 * hAbs);
          ctx.bezierCurveTo(sx2 + wAbs, sy2, sx2 + wAbs, sy2 + 0.7 * hAbs, sx2 + 0.5 * wAbs, sy2 + hAbs);
          ctx.bezierCurveTo(sx2, sy2 + 0.7 * hAbs, sx2, sy2, sx2 + 0.5 * wAbs, sy2 + 0.35 * hAbs);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
        case 'diamond': {
          // Finalize diamond shape using four vertices at the midpoints of each side
          const w = x - startX;
          const h = y - startY;
          ctx.beginPath();
          ctx.moveTo(startX + w / 2, startY);
          ctx.lineTo(startX + w, startY + h / 2);
          ctx.lineTo(startX + w / 2, startY + h);
          ctx.lineTo(startX, startY + h / 2);
          ctx.closePath();
          if (document.getElementById('shapeFill').checked) {
            ctx.fill();
          }
          ctx.stroke();
          break;
        }
      }
      // Clear the preview snapshot after finalizing
      shapePreviewImgData = null;
    }
    // Finish freehand drawing or eraser tool
    drawing = false;
    ctx.globalCompositeOperation = 'source-over';
    if (e && typeof e.pointerId === 'number') {
      try {
        canvas.releasePointerCapture(e.pointerId);
      } catch(err) { /* ignore if unsupported */ }
    }
  }
  canvas.addEventListener('pointerup', endDrawingEvent);
  // We intentionally do not end drawing on pointerleave to prevent
  // accidental cut‑offs; pointerup will properly end the stroke.

  /**
   * Set the current drawing tool and update the active button styling.
   * @param {string} tool Name of the tool ('pen','eraser','fill','picker','line','rect','circle','ellipse','triangle')
   */
  function selectTool(tool) {
    currentTool = tool;
    // Remove active classes from all tools and shape dropdown
    [toolPen, toolEraser, toolFill, toolPicker].forEach(btn => btn.classList.remove('active'));
    shapeSelect.classList.remove('active');
    // Highlight whichever tool was selected. If it's a shape, highlight the
    // shape dropdown and set its value accordingly.
    if (tool === 'pen') {
      toolPen.classList.add('active');
    } else if (tool === 'eraser') {
      toolEraser.classList.add('active');
    } else if (tool === 'fill') {
      toolFill.classList.add('active');
    } else if (tool === 'picker') {
      toolPicker.classList.add('active');
    } else if (shapeTools.includes(tool)) {
      shapeSelect.classList.add('active');
      // Update the shape dropdown to match the selected shape
      shapeSelect.value = tool;
    }
  }
  // Initialise default tool
  selectTool('pen');
  // Initialise the colour swatch with the default brush colour
  updateSwatch();
  // Tool button event listeners
  toolPen.addEventListener('click', () => selectTool('pen'));
  toolEraser.addEventListener('click', () => selectTool('eraser'));
  toolFill.addEventListener('click', () => selectTool('fill'));
  toolPicker.addEventListener('click', () => {
    // Remember the current tool so we can revert after picking
    prevTool = currentTool;
    selectTool('picker');
  });
  // Undo is a one-off action, does not change current tool
  toolUndo.addEventListener('click', () => undo());
  // Clear canvas is a one-off action, does not change current tool
  toolClear.addEventListener('click', () => clearCanvas());
  // Shape selection: update currentTool and highlight dropdown
  shapeSelect.addEventListener('change', () => {
    selectTool(shapeSelect.value);
  });

  // When the user presses down on the shape dropdown, automatically switch to
  // the currently selected shape if not already using a shape tool. This way
  // the dropdown is highlighted and active as soon as you open it. The
  // subsequent 'change' event (triggered when selecting a new shape) will
  // update the tool again.
  shapeSelect.addEventListener('mousedown', () => {
    if (!shapeTools.includes(currentTool)) {
      selectTool(shapeSelect.value);
    }
  });

  // ----- Flag Connections event listeners -----
  // Handle selection of flags in the connections grid
  connectionsGrid.addEventListener('click', onConnectionsCardClick);
  // Shuffle remaining unsolved flags
  connectionsShuffle.addEventListener('click', shuffleConnections);
  // Evaluate the selected flags and submit as a guess
  connectionsSubmit.addEventListener('click', submitConnections);

  // Deselect all currently selected cards
  connectionsDeselect.addEventListener('click', () => {
    deselectConnections();
  });

  // ----- Odd One Out event listeners -----
  // Handle selection of a flag in the odd one out grid. Only one card can be selected at a time.
  oddGrid.addEventListener('click', onOddCardClick);
  // Submit the selected flag for evaluation in odd mode
  oddSubmit.addEventListener('click', submitOdd);

  // Next button for odd mode: proceed to the next round if mistakes allow
  if (oddNext) {
    oddNext.addEventListener('click', () => {
      // For Odd mode, always allow moving to the next round. Reset mistakes count when not in unlimited mode,
      // and update the mistakes display so the player starts fresh. In unlimited mode we retain the count.
      if (!state.oddUnlimitedMistakes) {
        state.oddMistakesUsed = 0;
      }
      updateOddMistakesDisplay();
      // Clear outlines
      oddGrid.querySelectorAll('.flag-card').forEach(card => {
        card.style.outline = '';
      });
      oddStatus.textContent = '';
      oddNext.classList.add('hidden');
      oddGrid.addEventListener('click', onOddCardClick);
      buildOddRound();
    });
  }

  // Toggle unlimited mistakes for odd mode
  if (unlimitedOddMistakesToggle) {
    unlimitedOddMistakesToggle.addEventListener('change', () => {
      state.oddUnlimitedMistakes = unlimitedOddMistakesToggle.checked;
      updateOddMistakesDisplay();
    });
  }

  // Toggle showing country names for Region Snapshot
  if (regionNameToggle) {
    regionNameToggle.addEventListener('change', () => {
      updateRegionNameDisplay();
    });
  }

  // ----- Mode Display Updates -----
  // On initial load, show the display name of the default mode (state.mode).
  // The state object is defined later, but we can wait until DOMContentLoaded to ensure it exists.
  document.addEventListener('DOMContentLoaded', () => {
    if (modeDisplay && typeof state !== 'undefined' && modeNames[state.mode]) {
      modeDisplay.innerHTML = modeNames[state.mode];
    }
  });
  // Whenever the user selects a different mode in the drop‑down, update the mode display to show
  // the name and icon, even before the game starts. This makes the UI reflect the user's selection.
  modeSelect.addEventListener('change', () => {
    const selected = modeSelect.value;
    if (modeNames[selected] && modeDisplay) {
      modeDisplay.innerHTML = modeNames[selected];
    }
    // When switching modes via the dropdown, immediately hide the odd one out panel
    // to prevent leftover puzzles from persisting. Panels for other modes remain
    // hidden until their respective start functions run. This ensures that
    // changing the mode resets the UI state.
    if (selected !== 'odd') {
      oddPanel.classList.add('hidden');
    }
  });

  // Grid toggle removed; no event listener necessary

  function buildCustomOptions(){
    const base=[
      ['UN_EASY','UN - Easy (Top 20% by population)'],
      ['UN_MED','UN - Medium (Next 40%)'],
      ['UN_HARD','UN - Hard (Bottom 40%)'],
      ['NA','North/Central America'],
      ['SA','South America'],
      ['EU','Europe'],
      ['AS','Asia'],
      ['AF','Africa'],
      ['OC','Oceania'],
      ['WORLD','World (All)']
    ];
    const user = state.userPresets.map(p=>[p.id, `⭐ ${p.label} (${p.items.length})`]);
    const opts = [...base, ...user];
    customSelect.innerHTML = opts.map(([v,l])=>`<option value="${v}" ${v===state.customMode?'selected':''}>${l}</option>`).join('');
  }
  customSelect.addEventListener('change',()=>{ state.customMode=customSelect.value; updateDatalist(); buildLearn(); });

  // ---- Custom builder ----
  function renderCustomList(filter=''){
    const q = norm(filter);
    const pool = dataAll.filter(e=>{
      if(!q) return true;
      const names=[e.name, ...(e.alt||[])].map(norm);
      return names.some(n=>n.includes(q));
    });
    customList.innerHTML = pool.map(e=>{
      const sel = state._customSel && state._customSel.has(e.cca2);
      return `<div class="item" data-cca2="${e.cca2}" style="cursor:pointer;outline:${sel?'2px solid var(--accent)':'none'}"><img src="${e.flag}" alt="${e.name}"><small>${e.name}</small></div>`;
    }).join('');
  }
  function openCustomBuilder(){
    state._customSel = new Set();
    customName.value='';
    customSearch.value='';
    customCount.textContent='0';
    renderCustomList('');
    customPanel.classList.remove('hidden');
  }
  function closeCustomBuilder(){ customPanel.classList.add('hidden'); }

  createCustomBtn.addEventListener('click', openCustomBuilder);
  closeCustom.addEventListener('click', closeCustomBuilder);
  customSearch.addEventListener('input', ()=>renderCustomList(customSearch.value));
  customList.addEventListener('click', (e)=>{
    const card = e.target.closest('.item'); if(!card) return;
    const id = card.getAttribute('data-cca2');
    if(state._customSel.has(id)) state._customSel.delete(id); else state._customSel.add(id);
    customCount.textContent = String(state._customSel.size);
    if(state._customSel.has(id)) card.style.outline='2px solid var(--accent)'; else card.style.outline='none';
  });
  saveCustomBtn.addEventListener('click', ()=>{
    const name = customName.value.trim();
    if(!name || !state._customSel || state._customSel.size===0){ alert('Name and at least one flag required.'); return; }
    const slug = 'USER:'+name.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
    const existing = state.userPresets.find(x=>x.id===slug);
    const items = [...state._customSel];
    if(existing){ existing.label=name; existing.items=items; }
    else { state.userPresets.push({id:slug,label:name,items}); }
    savePresets();
    state.customMode = slug;
    buildCustomOptions();
    customSelect.value = slug;
    updateDatalist();
    buildLearn();
    closeCustomBuilder();
  });

  // Build initial UI
  buildCustomOptions();
  updateDatalist();
  buildLearn();

  // Enable draggable pop-up panels. Panels with a `.panel-header` inside
  // their `.pop` container can be dragged around the viewport. When the
  // user presses down on a panel header, we record the offset and then
  // update the panel's position as the pointer moves. The default
  // centering transform is removed on drag start so that left/top take
  // precedence.
  (() => {
    let dragPanel = null;
    let offsetX = 0;
    let offsetY = 0;
    document.addEventListener('pointerdown', (e) => {
      const header = e.target.closest('.panel-header');
      if (!header) return;
      const panel = header.closest('.pop');
      if (!panel) return;
      dragPanel = panel;
      const rect = dragPanel.getBoundingClientRect();
      // Set explicit left/top based on current position before removing transform
      dragPanel.style.left = rect.left + 'px';
      dragPanel.style.top = rect.top + 'px';
      // Remove horizontal centering so the panel moves according to left/top
      dragPanel.style.transform = 'none';
      // Bring to front
      dragPanel.style.zIndex = '999';
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      e.preventDefault();
    });
    document.addEventListener('pointermove', (e) => {
      if (!dragPanel) return;
      const x = e.clientX - offsetX;
      const y = e.clientY - offsetY;
      dragPanel.style.left = x + 'px';
      dragPanel.style.top = y + 'px';
    });
    document.addEventListener('pointerup', () => {
      dragPanel = null;
    });
    document.addEventListener('pointercancel', () => {
      dragPanel = null;
    });
  })();

  // Smoke tests
  try {
    const pool = dataUN;
    const fr = pool.find(x=>x.name==='France');
    const de = pool.find(x=>x.name==='Germany');
    if (fr && de) {
      console.assert(matches('France', de) === false, 'France should NOT match Germany');
      console.assert(matches('Fra', fr) === true, 'Fra should match France');
    }
    const us = dataAll.find(x=>x.name==='United States');
    if (us) console.assert(matches('Uni', us) === false, 'Uni is ambiguous among United...');
    const sk = dataAll.find(x=>x.name==='South Korea');
    if (sk) console.assert(matches('Republic of Korea', sk) === true, 'Alias should match South Korea');
    console.log('Self-tests passed.');
  } catch(err){ console.warn('Self-tests skipped', err); }
})();

  // === Name plates for Connections & Odd One Out ===
  const connOddNameToggle = document.querySelector('#connOddNameToggle');

  function _connOdd_addNamePlates(root){
    if (!root) return;
    root.querySelectorAll('.flag-card').forEach(card=>{
      if (card.querySelector('.flag-name')) return;
      let name = card.getAttribute('data-name');
      if (!name){
        const img = card.querySelector('img');
        name = (img && (img.getAttribute('alt') || (img.dataset ? img.dataset.name : ''))) || '';
      }
      if (!name) return;
      const label = document.createElement('div');
      label.className = 'flag-name';
      label.textContent = name;
      card.appendChild(label);
    });
  }

  function _connOdd_observe(grid){
    if (!grid) return;
    const obs = new MutationObserver(()=>_connOdd_addNamePlates(grid));
    obs.observe(grid, { childList:true, subtree:true });
    _connOdd_addNamePlates(grid);
  }

  function _connOdd_updateDisplay(){
    const show = !!(connOddNameToggle && connOddNameToggle.checked);
    const grids = [document.querySelector('#connectionsGrid'), document.querySelector('#oddGrid')];
    grids.forEach(el => el && el.classList.toggle('show-names', show));
    grids.forEach(_connOdd_addNamePlates);
  }

  (function _initConnOddNames(){
    const init = ()=>{
      _connOdd_observe(document.querySelector('#connectionsGrid'));
      _connOdd_observe(document.querySelector('#oddGrid'));
      _connOdd_updateDisplay();
    };
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
    if (connOddNameToggle){
      const saved = localStorage.getItem('connOddShowNames');
      if (saved !== null) connOddNameToggle.checked = (saved === '1');
      connOddNameToggle.addEventListener('change', ()=>{
        localStorage.setItem('connOddShowNames', connOddNameToggle.checked ? '1' : '0');
        _connOdd_updateDisplay();
      });
    }
  })();

</script>
</body>
</html>
